\documentclass[11pt]{article} 
\usepackage[latin1]{inputenc} 
\usepackage[T1]{fontenc} 
\usepackage{textcomp}
\usepackage{fullpage} 
\usepackage{url} 
\usepackage{ocamldoc}
\title{Koat2}
\begin{document}
\maketitle
\tableofcontents
\section{Module {\tt{Util}}}
\label{module:Util}\index{Util@\verb`Util`}


\ocamldocvspace{0.5cm}



\label{val:Util.get-underscoreall}\begin{ocamldoccode}
val get_all : {\textquotesingle}a Batteries.Option.t list -> {\textquotesingle}a list Batteries.Option.t
\end{ocamldoccode}
\index{get-underscoreall@\verb`get_all`}
\begin{ocamldocdescription}
Returns None if one of the optionals evaluates to None.
    If all optionals evaluate to Some, it returns a list of those values.


\end{ocamldocdescription}




\label{val:Util.max-underscoreoption}\begin{ocamldoccode}
val max_option :
  ({\textquotesingle}a -> {\textquotesingle}a -> bool) -> {\textquotesingle}a Batteries.Enum.t -> {\textquotesingle}a Batteries.Option.t
\end{ocamldoccode}
\index{max-underscoreoption@\verb`max_option`}
\begin{ocamldocdescription}
Computes the maximum of the enum if non-empty, else returns None.


\end{ocamldocdescription}




\label{val:Util.min-underscoreoption}\begin{ocamldoccode}
val min_option :
  ({\textquotesingle}a -> {\textquotesingle}a -> bool) -> {\textquotesingle}a Batteries.Enum.t -> {\textquotesingle}a Batteries.Option.t
\end{ocamldoccode}
\index{min-underscoreoption@\verb`min_option`}
\begin{ocamldocdescription}
Computes the maximum of the enum if non-empty, else returns None.


\end{ocamldocdescription}




\label{val:Util.intersection}\begin{ocamldoccode}
val intersection :
  ({\textquotesingle}a -> {\textquotesingle}a -> bool) ->
  {\textquotesingle}a Batteries.Enum.t -> {\textquotesingle}a Batteries.Enum.t -> {\textquotesingle}a Batteries.Enum.t
\end{ocamldoccode}
\index{intersection@\verb`intersection`}
\begin{ocamldocdescription}
Computes the intersection between both enums with the given equality function.


\end{ocamldocdescription}




\label{val:Util.without}\begin{ocamldoccode}
val without :
  ({\textquotesingle}a -> {\textquotesingle}a -> bool) ->
  {\textquotesingle}a Batteries.Enum.t -> {\textquotesingle}a Batteries.Enum.t -> {\textquotesingle}a Batteries.Enum.t
\end{ocamldoccode}
\index{without@\verb`without`}
\begin{ocamldocdescription}
Returns an enum that contains all elements that are present in the second enum but not in the first enum.


\end{ocamldocdescription}




\label{val:Util.option-underscoreto-underscorestring}\begin{ocamldoccode}
val option_to_string : ({\textquotesingle}a -> string) -> {\textquotesingle}a Batteries.Option.t -> string
\end{ocamldoccode}
\index{option-underscoreto-underscorestring@\verb`option_to_string`}




\label{val:Util.enum-underscoreto-underscorestring}\begin{ocamldoccode}
val enum_to_string : ({\textquotesingle}a -> string) -> {\textquotesingle}a Batteries.Enum.t -> string
\end{ocamldoccode}
\index{enum-underscoreto-underscorestring@\verb`enum_to_string`}




\label{val:Util.powerset}\begin{ocamldoccode}
val powerset : {\textquotesingle}a Batteries.Set.t -> {\textquotesingle}a Batteries.Set.t Batteries.Enum.t
\end{ocamldoccode}
\index{powerset@\verb`powerset`}




\label{val:Util.find-underscoremap}\begin{ocamldoccode}
val find_map :
  ({\textquotesingle}a -> {\textquotesingle}b Batteries.Option.t) -> {\textquotesingle}a Batteries.Enum.t -> {\textquotesingle}b Batteries.Option.t
\end{ocamldoccode}
\index{find-underscoremap@\verb`find_map`}




\label{val:Util.memoize}\begin{ocamldoccode}
val memoize : extractor:({\textquotesingle}a -> {\textquotesingle}c) -> ({\textquotesingle}a -> {\textquotesingle}b) -> {\textquotesingle}a -> {\textquotesingle}b
\end{ocamldoccode}
\index{memoize@\verb`memoize`}


\section{Module {\tt{Logging}}}
\label{module:Logging}\index{Logging@\verb`Logging`}


\ocamldocvspace{0.5cm}



\label{type:Logging.logger}\begin{ocamldoccode}
type logger =
  | Approximation
  | Size
  | Time
  | PRF
  | Bound
  | LocalSizeBound
  | Preprocessor
  | CFR
\end{ocamldoccode}
\index{logger@\verb`logger`}




\label{val:Logging.loggers}\begin{ocamldoccode}
val loggers : logger list
\end{ocamldoccode}
\index{loggers@\verb`loggers`}




\label{val:Logging.all}\begin{ocamldoccode}
val all : logger list
\end{ocamldoccode}
\index{all@\verb`all`}




\label{val:Logging.show-underscorelogger}\begin{ocamldoccode}
val show_logger : logger -> string
\end{ocamldoccode}
\index{show-underscorelogger@\verb`show_logger`}




\label{val:Logging.get}\begin{ocamldoccode}
val get : logger -> Batteries.Logger.log
\end{ocamldoccode}
\index{get@\verb`get`}




\label{val:Logging.with-underscoredisabled-underscoreloggers}\begin{ocamldoccode}
val with_disabled_loggers :
  (logger * Batteries.Logger.level) list ->
  (string * Batteries.Logger.level) list
\end{ocamldoccode}
\index{with-underscoredisabled-underscoreloggers@\verb`with_disabled_loggers`}




\label{val:Logging.use-underscoreloggers}\begin{ocamldoccode}
val use_loggers : (logger * Batteries.Logger.level) list -> unit
\end{ocamldoccode}
\index{use-underscoreloggers@\verb`use_loggers`}


\section{Module {\tt{MaybeChanged}}}
\label{module:MaybeChanged}\index{MaybeChanged@\verb`MaybeChanged`}


\ocamldocvspace{0.5cm}



A type that is wrapped by the MaybeChanged monad represents a value that might change during a computation.
    Once it has changed it will be forever marked as changed, but can also be further be manipulated.



\label{type:MaybeChanged.status}\begin{ocamldoccode}
type status =
  | Changed
  | Same
\end{ocamldoccode}
\index{status@\verb`status`}




\label{type:MaybeChanged.t}\begin{ocamldoccode}
type {\textquotesingle}a t = status * {\textquotesingle}a 
\end{ocamldoccode}
\index{t@\verb`t`}




\label{val:MaybeChanged.return}\begin{ocamldoccode}
val return : {\textquotesingle}a -> status * {\textquotesingle}a
\end{ocamldoccode}
\index{return@\verb`return`}




\label{val:MaybeChanged.(-gt-gt-equal)}\begin{ocamldoccode}
val (>>=) : status * {\textquotesingle}a ->
  ({\textquotesingle}a -> status * {\textquotesingle}b) -> status * {\textquotesingle}b
\end{ocamldoccode}
\index{(-gt-gt-equal)@\verb`(>>=)`}




\label{val:MaybeChanged.flat-underscoremap}\begin{ocamldoccode}
val flat_map : ({\textquotesingle}a -> status * {\textquotesingle}b) ->
  status * {\textquotesingle}a -> status * {\textquotesingle}b
\end{ocamldoccode}
\index{flat-underscoremap@\verb`flat_map`}




\label{val:MaybeChanged.map}\begin{ocamldoccode}
val map : ({\textquotesingle}a -> {\textquotesingle}b) -> {\textquotesingle}c * {\textquotesingle}a -> {\textquotesingle}c * {\textquotesingle}b
\end{ocamldoccode}
\index{map@\verb`map`}




\label{val:MaybeChanged.unpack}\begin{ocamldoccode}
val unpack : {\textquotesingle}a * {\textquotesingle}b -> {\textquotesingle}b
\end{ocamldoccode}
\index{unpack@\verb`unpack`}




\label{val:MaybeChanged.has-underscorechanged}\begin{ocamldoccode}
val has_changed : status * {\textquotesingle}a -> bool
\end{ocamldoccode}
\index{has-underscorechanged@\verb`has_changed`}




\label{val:MaybeChanged.if-underscorechanged}\begin{ocamldoccode}
val if_changed : ({\textquotesingle}a -> {\textquotesingle}a) -> status * {\textquotesingle}a -> status * {\textquotesingle}a
\end{ocamldoccode}
\index{if-underscorechanged@\verb`if_changed`}




\label{val:MaybeChanged.changed}\begin{ocamldoccode}
val changed : {\textquotesingle}a -> status * {\textquotesingle}a
\end{ocamldoccode}
\index{changed@\verb`changed`}




\label{val:MaybeChanged.same}\begin{ocamldoccode}
val same : {\textquotesingle}a -> status * {\textquotesingle}a
\end{ocamldoccode}
\index{same@\verb`same`}




\label{val:MaybeChanged.fold-underscoreenum}\begin{ocamldoccode}
val fold_enum : ({\textquotesingle}a -> {\textquotesingle}b -> {\textquotesingle}a t) ->
  {\textquotesingle}a -> {\textquotesingle}b Batteries.Enum.t -> {\textquotesingle}a t
\end{ocamldoccode}
\index{fold-underscoreenum@\verb`fold_enum`}


\section{Module {\tt{Var}}}
\label{module:Var}\index{Var@\verb`Var`}


\ocamldocvspace{0.5cm}



Provides default implementations of an ID



\label{type:Var.sort}\begin{ocamldoccode}
type sort =
  | Real
  | Int
\end{ocamldoccode}
\index{sort@\verb`sort`}
\begin{ocamldocdescription}
Finite type for giving a helper a type


\end{ocamldocdescription}




\label{val:Var.equal-underscoresort}\begin{ocamldoccode}
val equal_sort : sort -> sort -> Ppx_deriving_runtime.bool
\end{ocamldoccode}
\index{equal-underscoresort@\verb`equal_sort`}




\label{val:Var.compare-underscoresort}\begin{ocamldoccode}
val compare_sort : sort -> sort -> Ppx_deriving_runtime.int
\end{ocamldoccode}
\index{compare-underscoresort@\verb`compare_sort`}




\label{type:Var.t}\begin{ocamldoccode}
type t =
  | Var of Batteries.String.t
\end{ocamldoccode}
\begin{ocamldoccomment}
Helpers are fresh variables generated via the computation. They represent a real or an integer value.


\end{ocamldoccomment}
\begin{ocamldoccode}
  | Helper of sort * int
  | Argument of int
\end{ocamldoccode}
\index{t@\verb`t`}
\begin{ocamldocdescription}
An ID is a unique identifier for the elements of an arbitrary set (of variables)


\end{ocamldocdescription}




\label{val:Var.equal}\begin{ocamldoccode}
val equal : t -> t -> bool
\end{ocamldoccode}
\index{equal@\verb`equal`}




\label{val:Var.compare}\begin{ocamldoccode}
val compare : t -> t -> int
\end{ocamldoccode}
\index{compare@\verb`compare`}




\label{val:Var.equal}\begin{ocamldoccode}
val equal : t -> t -> bool
\end{ocamldoccode}
\index{equal@\verb`equal`}




\label{val:Var.compare}\begin{ocamldoccode}
val compare : t -> t -> int
\end{ocamldoccode}
\index{compare@\verb`compare`}




\label{val:Var.hash}\begin{ocamldoccode}
val hash : t -> int
\end{ocamldoccode}
\index{hash@\verb`hash`}




\label{val:Var.(-equal-tilde-equal)}\begin{ocamldoccode}
val (=~=) : t -> t -> bool
\end{ocamldoccode}
\index{(-equal-tilde-equal)@\verb`(=~=)`}




\label{val:Var.of-underscorestring}\begin{ocamldoccode}
val of_string : string -> t
\end{ocamldoccode}
\index{of-underscorestring@\verb`of_string`}




\label{val:Var.to-underscorestring}\begin{ocamldoccode}
val to_string : ?to_file:bool -> t -> Batteries.String.t
\end{ocamldoccode}
\index{to-underscorestring@\verb`to_string`}
\begin{ocamldocdescription}
Returns a not yet used id, which is guaranteed to be distinct from any yet existing ids.


\end{ocamldocdescription}




\label{val:Var.fresh-underscoreid}\begin{ocamldoccode}
val fresh_id : sort -> unit -> t
\end{ocamldoccode}
\index{fresh-underscoreid@\verb`fresh_id`}
\begin{ocamldocdescription}
Returns a bunch of fresh ids.


\end{ocamldocdescription}




\label{val:Var.fresh-underscoreids}\begin{ocamldoccode}
val fresh_ids : sort -> int -> t Batteries.Enum.t
\end{ocamldoccode}
\index{fresh-underscoreids@\verb`fresh_ids`}




\label{val:Var.fresh-underscoreid-underscorelist}\begin{ocamldoccode}
val fresh_id_list : sort -> int -> t list
\end{ocamldoccode}
\index{fresh-underscoreid-underscorelist@\verb`fresh_id_list`}




\label{val:Var.fresh-underscorearg-underscorelist}\begin{ocamldoccode}
val fresh_arg_list : int -> t list
\end{ocamldoccode}
\index{fresh-underscorearg-underscorelist@\verb`fresh_arg_list`}




\label{val:Var.is-underscorehelper}\begin{ocamldoccode}
val is_helper : t -> bool
\end{ocamldoccode}
\index{is-underscorehelper@\verb`is_helper`}




\label{val:Var.mk-underscorehelper}\begin{ocamldoccode}
val mk_helper : sort -> int -> t
\end{ocamldoccode}
\index{mk-underscorehelper@\verb`mk_helper`}




\label{val:Var.is-underscorereal}\begin{ocamldoccode}
val is_real : t -> bool
\end{ocamldoccode}
\index{is-underscorereal@\verb`is_real`}


\section{Module {\tt{Bound}}}
\label{module:Bound}\index{Bound@\verb`Bound`}


\ocamldocvspace{0.5cm}



A MinMaxPolynomial is a polynomial which allows the usage of min and max functions



\label{type:Bound.t}\begin{ocamldoccode}
type t 
\end{ocamldoccode}
\index{t@\verb`t`}




{\tt{include }}{\tt{PolyTypes.Evaluable}}



{\tt{include }}{\tt{PolyTypes.Math}}



{\tt{include }}{\tt{PolyTypes.PartialOrder}}



Following methods are convenience methods for the creation of polynomials.



\label{val:Bound.of-underscorepoly}\begin{ocamldoccode}
val of_poly : Polynomials.Polynomial.t -> t
\end{ocamldoccode}
\index{of-underscorepoly@\verb`of_poly`}




\label{val:Bound.of-underscoreconstant}\begin{ocamldoccode}
val of_constant : value -> t
\end{ocamldoccode}
\index{of-underscoreconstant@\verb`of_constant`}




\label{val:Bound.of-underscoreint}\begin{ocamldoccode}
val of_int : int -> t
\end{ocamldoccode}
\index{of-underscoreint@\verb`of_int`}




\label{val:Bound.to-underscoreint}\begin{ocamldoccode}
val to_int : t -> int
\end{ocamldoccode}
\index{to-underscoreint@\verb`to_int`}




\label{val:Bound.of-underscorevar}\begin{ocamldoccode}
val of_var : Var.t -> t
\end{ocamldoccode}
\index{of-underscorevar@\verb`of_var`}




\label{val:Bound.of-underscorevar-underscorestring}\begin{ocamldoccode}
val of_var_string : string -> t
\end{ocamldoccode}
\index{of-underscorevar-underscorestring@\verb`of_var_string`}




\label{val:Bound.min}\begin{ocamldoccode}
val min : t -> t -> t
\end{ocamldoccode}
\index{min@\verb`min`}




\label{val:Bound.max}\begin{ocamldoccode}
val max : t -> t -> t
\end{ocamldoccode}
\index{max@\verb`max`}




\label{val:Bound.minimum}\begin{ocamldoccode}
val minimum : t Batteries.Enum.t -> t
\end{ocamldoccode}
\index{minimum@\verb`minimum`}
\begin{ocamldocdescription}
Returns a bound representing the minimum of all the values.
    Raises an exception, if the enum is empty.
    Use the function infinity for those cases.

Returns a bound representing the maximum of all the values.
    Raises an exception, if the enum is empty.
    Use the function minus\_infinity for those cases.


\end{ocamldocdescription}




\label{val:Bound.maximum}\begin{ocamldoccode}
val maximum : t Batteries.Enum.t -> t
\end{ocamldoccode}
\index{maximum@\verb`maximum`}




\label{val:Bound.infinity}\begin{ocamldoccode}
val infinity : t
\end{ocamldoccode}
\index{infinity@\verb`infinity`}




\label{val:Bound.minus-underscoreinfinity}\begin{ocamldoccode}
val minus_infinity : t
\end{ocamldoccode}
\index{minus-underscoreinfinity@\verb`minus_infinity`}




\label{val:Bound.exp}\begin{ocamldoccode}
val exp : value -> t -> t
\end{ocamldoccode}
\index{exp@\verb`exp`}




\label{val:Bound.abs}\begin{ocamldoccode}
val abs : t -> t
\end{ocamldoccode}
\index{abs@\verb`abs`}




\label{val:Bound.max-underscoreof-underscoreoccurring-underscoreconstants}\begin{ocamldoccode}
val max_of_occurring_constants : t -> OurInt.t
\end{ocamldoccode}
\index{max-underscoreof-underscoreoccurring-underscoreconstants@\verb`max_of_occurring_constants`}




\label{val:Bound.is-underscoreinfinity}\begin{ocamldoccode}
val is_infinity : t -> bool
\end{ocamldoccode}
\index{is-underscoreinfinity@\verb`is_infinity`}




\label{val:Bound.is-underscoreminus-underscoreinfinity}\begin{ocamldoccode}
val is_minus_infinity : t -> bool
\end{ocamldoccode}
\index{is-underscoreminus-underscoreinfinity@\verb`is_minus_infinity`}




\label{val:Bound.to-underscorestring}\begin{ocamldoccode}
val to_string : t -> string
\end{ocamldoccode}
\index{to-underscorestring@\verb`to_string`}




\label{val:Bound.show}\begin{ocamldoccode}
val show : ?complexity:bool -> t -> string
\end{ocamldoccode}
\index{show@\verb`show`}




Functions to classify the quality of the bound



Following methods can be used to classify the type of the polynomial.



\label{val:Bound.substitute}\begin{ocamldoccode}
val substitute : Var.t -> replacement:t -> t -> t
\end{ocamldoccode}
\index{substitute@\verb`substitute`}
\begin{ocamldocdescription}
Substitutes every occurrence of the variable in the polynomial by the replacement polynomial.
        Ignores naming equalities.


\end{ocamldocdescription}




\label{val:Bound.substitute-underscoreall}\begin{ocamldoccode}
val substitute_all : t Batteries.Map.Make(Var).t -> t -> t
\end{ocamldoccode}
\index{substitute-underscoreall@\verb`substitute_all`}
\begin{ocamldocdescription}
Substitutes every occurrence of the variables in the polynomial by the corresponding replacement polynomial.
        Leaves all variables unchanged which are not in the replacement map.


\end{ocamldocdescription}




\label{val:Bound.substitute-underscoref}\begin{ocamldoccode}
val substitute_f : (Var.t -> t) -> t -> t
\end{ocamldoccode}
\index{substitute-underscoref@\verb`substitute_f`}
\begin{ocamldocdescription}
Substitutes every occurrence of the variables in the polynomial by the corresponding replacement polynomial.


\end{ocamldocdescription}




\label{val:Bound.appr-underscoresubstitution}\begin{ocamldoccode}
val appr_substitution :
  [ {\textasciigrave}Lower | {\textasciigrave}Upper ] ->
  lower:(Var.t -> t) -> higher:(Var.t -> t) -> t -> t
\end{ocamldoccode}
\index{appr-underscoresubstitution@\verb`appr_substitution`}




\label{val:Bound.fold}\begin{ocamldoccode}
val fold :
  const:(value -> {\textquotesingle}b) ->
  var:(Var.t -> {\textquotesingle}b) ->
  neg:({\textquotesingle}b -> {\textquotesingle}b) ->
  plus:({\textquotesingle}b -> {\textquotesingle}b -> {\textquotesingle}b) ->
  times:({\textquotesingle}b -> {\textquotesingle}b -> {\textquotesingle}b) ->
  exp:(value -> {\textquotesingle}b -> {\textquotesingle}b) -> max:({\textquotesingle}b -> {\textquotesingle}b -> {\textquotesingle}b) -> inf:{\textquotesingle}b -> t -> {\textquotesingle}b
\end{ocamldoccode}
\index{fold@\verb`fold`}
\begin{ocamldocdescription}
Replaces all arithmetical operations by new constructors.


\end{ocamldocdescription}




\label{type:Bound.complexity}\begin{ocamldoccode}
type complexity =
  | Inf
  | Polynomial of int
  | Exponential of int
\end{ocamldoccode}
\index{complexity@\verb`complexity`}




\label{val:Bound.equal-underscorecomplexity}\begin{ocamldoccode}
val equal_complexity : complexity -> complexity -> bool
\end{ocamldoccode}
\index{equal-underscorecomplexity@\verb`equal_complexity`}




\label{val:Bound.show-underscorecomplexity}\begin{ocamldoccode}
val show_complexity : complexity -> string
\end{ocamldoccode}
\index{show-underscorecomplexity@\verb`show_complexity`}




\label{val:Bound.show-underscorecomplexity-underscoretermcomp}\begin{ocamldoccode}
val show_complexity_termcomp : complexity -> string
\end{ocamldoccode}
\index{show-underscorecomplexity-underscoretermcomp@\verb`show_complexity_termcomp`}




\label{val:Bound.asymptotic-underscorecomplexity}\begin{ocamldoccode}
val asymptotic_complexity : t -> complexity
\end{ocamldoccode}
\index{asymptotic-underscorecomplexity@\verb`asymptotic_complexity`}
\begin{ocamldocdescription}
Returns an overapproximation of the asymptotic complexity of the given bound.


\end{ocamldocdescription}




\label{val:Bound.is-underscorelinear}\begin{ocamldoccode}
val is_linear : t -> bool
\end{ocamldoccode}
\index{is-underscorelinear@\verb`is_linear`}
\begin{ocamldocdescription}
Returns true iff the asymptotic complexity is n{\textasciicircum}1.


\end{ocamldocdescription}




\label{val:Bound.coeff-underscoreof-underscorevar}\begin{ocamldoccode}
val coeff_of_var : Var.t -> t -> value
\end{ocamldoccode}
\index{coeff-underscoreof-underscorevar@\verb`coeff_of_var`}
\begin{ocamldocdescription}
Needed for Atomizable but not yet implemented.


\end{ocamldocdescription}




\label{val:Bound.of-underscorecoeff-underscorelist}\begin{ocamldoccode}
val of_coeff_list : value list -> Var.t list -> t
\end{ocamldoccode}
\index{of-underscorecoeff-underscorelist@\verb`of_coeff_list`}
\begin{ocamldocdescription}
Needed for Atomizable but not yet implemented.


\end{ocamldocdescription}




\label{val:Bound.get-underscoreconstant}\begin{ocamldoccode}
val get_constant : t -> value
\end{ocamldoccode}
\index{get-underscoreconstant@\verb`get_constant`}
\begin{ocamldocdescription}
returns the constant of a bound


\end{ocamldocdescription}


\section{Module {\tt{VarSet}}}
\label{module:VarSet}\index{VarSet@\verb`VarSet`}


\ocamldocvspace{0.5cm}



{\tt{include }}{\tt{??}}



\label{val:VarSet.map-underscoreto-underscoreset}\begin{ocamldoccode}
val map_to_set : (elt -> {\textquotesingle}b) -> t -> {\textquotesingle}b Batteries.Set.t
\end{ocamldoccode}
\index{map-underscoreto-underscoreset@\verb`map_to_set`}




\label{val:VarSet.map-underscoreto-underscorelist}\begin{ocamldoccode}
val map_to_list : (elt -> {\textquotesingle}b) -> t -> {\textquotesingle}b list
\end{ocamldoccode}
\index{map-underscoreto-underscorelist@\verb`map_to_list`}




\label{val:VarSet.map-underscoreto-underscorearray}\begin{ocamldoccode}
val map_to_array : (elt -> {\textquotesingle}b) -> t -> {\textquotesingle}b array
\end{ocamldoccode}
\index{map-underscoreto-underscorearray@\verb`map_to_array`}




\label{val:VarSet.to-underscorestring}\begin{ocamldoccode}
val to_string : t -> string
\end{ocamldoccode}
\index{to-underscorestring@\verb`to_string`}




\label{val:VarSet.of-underscorestring-underscorelist}\begin{ocamldoccode}
val of_string_list : string list -> t
\end{ocamldoccode}
\index{of-underscorestring-underscorelist@\verb`of_string_list`}




\label{val:VarSet.powerset}\begin{ocamldoccode}
val powerset : t -> t Batteries.Enum.t
\end{ocamldoccode}
\index{powerset@\verb`powerset`}




\label{val:VarSet.combinations}\begin{ocamldoccode}
val combinations : int -> t -> t list
\end{ocamldoccode}
\index{combinations@\verb`combinations`}




\label{val:VarSet.sorted-underscorecombinations}\begin{ocamldoccode}
val sorted_combinations : int -> t -> t Batteries.Enum.t
\end{ocamldoccode}
\index{sorted-underscorecombinations@\verb`sorted_combinations`}


\section{Module {\tt{RenameMap}}}
\label{module:RenameMap}\index{RenameMap@\verb`RenameMap`}


\ocamldocvspace{0.5cm}



A rename map is a function which maps from a finite set of variables to another finite set of variables



\label{type:RenameMap.t}\begin{ocamldoccode}
type t 
\end{ocamldoccode}
\index{t@\verb`t`}




\label{type:RenameMap.var}\begin{ocamldoccode}
type var = Var.t 
\end{ocamldoccode}
\index{var@\verb`var`}




\label{val:RenameMap.from}\begin{ocamldoccode}
val from : (var * var) list -> t
\end{ocamldoccode}
\index{from@\verb`from`}




\label{val:RenameMap.from-underscorenative}\begin{ocamldoccode}
val from_native : (string * string) list -> t
\end{ocamldoccode}
\index{from-underscorenative@\verb`from_native`}
\begin{ocamldocdescription}
Creates a rename map from a two strings (vars) association list


\end{ocamldocdescription}




\label{val:RenameMap.id}\begin{ocamldoccode}
val id : var list -> t
\end{ocamldoccode}
\index{id@\verb`id`}
\begin{ocamldocdescription}
Creates a rename map where every variable keeps its name


\end{ocamldocdescription}




\label{val:RenameMap.find}\begin{ocamldoccode}
val find : var -> t -> default:var -> var
\end{ocamldoccode}
\index{find@\verb`find`}
\begin{ocamldocdescription}
Returns the new name of the variable or a default value, if the rename map does not assign a new name to the variable


\end{ocamldocdescription}


\section{Module {\tt{Monomials}}}
\label{module:Monomials}\index{Monomials@\verb`Monomials`}


\ocamldocvspace{0.5cm}



Provides default implementations of a monomial



\begin{ocamldoccode}
{\tt{module }}{\tt{Make}}{\tt{ : }}\end{ocamldoccode}
\label{module:Monomials.Make}\index{Make@\verb`Make`}

{\tt{functor (}}{\tt{Value}}{\tt{ : }}{\tt{PolyTypes.Ring}}{\tt{) -> }}{\tt{PolyTypes.Monomial}}{\tt{ }}{\tt{ with type value = Value.t\
                             and type valuation = Valuation.Make(Value).t}}



\begin{ocamldocdescription}
Constructs a default monomial using a list of pairs of variables and their exponents


\end{ocamldocdescription}


\section{Module {\tt{Valuation}}}
\label{module:Valuation}\index{Valuation@\verb`Valuation`}


\ocamldocvspace{0.5cm}



\begin{ocamldoccode}
{\tt{module }}{\tt{Make}}{\tt{ : }}\end{ocamldoccode}
\label{module:Valuation.Make}\index{Make@\verb`Make`}

{\tt{functor (}}{\tt{Value}}{\tt{ : }}{\tt{PolyTypes.Ring}}{\tt{) -> }}{\tt{Valuation}}{\tt{ }}{\tt{ with type value = Value.t}}



\begin{ocamldocdescription}
Constructs a valuation with the variable and value type


\end{ocamldocdescription}


\section{Module {\tt{Polynomials}}}
\label{module:Polynomials}\index{Polynomials@\verb`Polynomials`}


\ocamldocvspace{0.5cm}



Provides default implementations of a polynomial



\begin{ocamldoccode}
{\tt{module }}{\tt{PolynomialOver}}{\tt{ : }}\end{ocamldoccode}
\label{module:Polynomials.PolynomialOver}\index{PolynomialOver@\verb`PolynomialOver`}

{\tt{functor (}}{\tt{Value}}{\tt{ : }}{\tt{PolyTypes.Ring}}{\tt{) -> }}{\tt{Polynomial}}{\tt{ }}{\tt{ with type value = Value.t\
                     and type valuation = Valuation.Make(Value).t\
                     and type monomial = Monomials.Make(Value).t}}



\begin{ocamldocdescription}
Constructs a default polynomial using a list of monomials and their coefficients


\end{ocamldocdescription}




\begin{ocamldoccode}
{\tt{module }}{\tt{Polynomial}}{\tt{ : }}\end{ocamldoccode}
\label{module:Polynomials.Polynomial}\index{Polynomial@\verb`Polynomial`}

\begin{ocamldocsigend}


{\tt{include }}{\tt{??}}

\label{val:Polynomials.Polynomial.separate-underscoreby-underscoresign}\begin{ocamldoccode}
val separate_by_sign : t -> t * t
\end{ocamldoccode}
\index{separate-underscoreby-underscoresign@\verb`separate_by_sign`}


\label{val:Polynomials.Polynomial.max-underscoreof-underscoreoccurring-underscoreconstants}\begin{ocamldoccode}
val max_of_occurring_constants : t -> OurInt.t
\end{ocamldoccode}
\index{max-underscoreof-underscoreoccurring-underscoreconstants@\verb`max_of_occurring_constants`}
\end{ocamldocsigend}






\begin{ocamldoccode}
{\tt{module }}{\tt{ParameterPolynomial}}{\tt{ : }}\end{ocamldoccode}
\label{module:Polynomials.ParameterPolynomial}\index{ParameterPolynomial@\verb`ParameterPolynomial`}

\begin{ocamldocsigend}


{\tt{include }}{\tt{??}}

\label{val:Polynomials.ParameterPolynomial.eval-underscorecoefficients}\begin{ocamldoccode}
val eval_coefficients :
  (Var.t -> OurInt.t) ->
  PolynomialOver(PolynomialOver(OurInt)).t -> PolynomialOver(OurInt).t
\end{ocamldoccode}
\index{eval-underscorecoefficients@\verb`eval_coefficients`}


\label{val:Polynomials.ParameterPolynomial.flatten}\begin{ocamldoccode}
val flatten : t -> PolynomialOver(OurInt).t
\end{ocamldoccode}
\index{flatten@\verb`flatten`}


\label{val:Polynomials.ParameterPolynomial.of-underscorepolynomial}\begin{ocamldoccode}
val of_polynomial : PolynomialOver(OurInt).t -> t
\end{ocamldoccode}
\index{of-underscorepolynomial@\verb`of_polynomial`}
\end{ocamldocsigend}




\section{Module {\tt{ScaledMonomials}}}
\label{module:ScaledMonomials}\index{ScaledMonomials@\verb`ScaledMonomials`}


\ocamldocvspace{0.5cm}



\begin{ocamldoccode}
{\tt{module }}{\tt{Make}}{\tt{ : }}\end{ocamldoccode}
\label{module:ScaledMonomials.Make}\index{Make@\verb`Make`}

{\tt{functor (}}{\tt{Value}}{\tt{ : }}{\tt{PolyTypes.Ring}}{\tt{) -> }}{\tt{PolyTypes.ScaledMonomial}}{\tt{ }}{\tt{ with type value = Value.t\
                                   and type valuation = Valuation.Make(Value).t\
                                   and type monomial = Monomials.Make(Value).t}}



\begin{ocamldocdescription}
Internal


\end{ocamldocdescription}


\section{Module {\tt{OurInt}} : Implementation of an integer-ring using Big\_int.}
\label{module:OurInt}\index{OurInt@\verb`OurInt`}




\ocamldocvspace{0.5cm}



{\tt{include }}{\tt{struct ... end}}



\label{val:OurInt.(-equal-tilde-equal)}\begin{ocamldoccode}
val (=~=) : t -> t -> bool
\end{ocamldoccode}
\index{(-equal-tilde-equal)@\verb`(=~=)`}
\begin{ocamldocdescription}
Comparator for two integers.


\end{ocamldocdescription}




\label{val:OurInt.pow}\begin{ocamldoccode}
val pow : t -> int -> t
\end{ocamldoccode}
\index{pow@\verb`pow`}
\begin{ocamldocdescription}
Calculates i{\textasciicircum}n.


\end{ocamldocdescription}




\label{val:OurInt.max}\begin{ocamldoccode}
val max :
  Compare.bat__compare_t -> Compare.bat__compare_t -> Compare.bat__compare_t
\end{ocamldoccode}
\index{max@\verb`max`}
\begin{ocamldocdescription}
Returns maximum of first and second integer.


\end{ocamldocdescription}




\label{val:OurInt.min}\begin{ocamldoccode}
val min :
  Compare.bat__compare_t -> Compare.bat__compare_t -> Compare.bat__compare_t
\end{ocamldoccode}
\index{min@\verb`min`}
\begin{ocamldocdescription}
Returns minimum of first and second integer.


\end{ocamldocdescription}


\section{Module {\tt{PolyTypes}}}
\label{module:PolyTypes}\index{PolyTypes@\verb`PolyTypes`}


\ocamldocvspace{0.5cm}



Provides all module types related to polynomials



\begin{ocamldoccode}
{\tt{module type }}{\tt{BasePartialOrder}}{\tt{ = }}\end{ocamldoccode}
\label{moduletype:PolyTypes.BasePartialOrder}\index{BasePartialOrder@\verb`BasePartialOrder`}

\begin{ocamldocsigend}


\label{type:PolyTypes.BasePartialOrder.t}\begin{ocamldoccode}
type t 
\end{ocamldoccode}
\index{t@\verb`t`}


\label{val:PolyTypes.BasePartialOrder.(-equal-tilde-equal)}\begin{ocamldoccode}
val (=~=) : t -> t -> bool
\end{ocamldoccode}
\index{(-equal-tilde-equal)@\verb`(=~=)`}


\label{val:PolyTypes.BasePartialOrder.(-gt)}\begin{ocamldoccode}
val (>) : t ->
  t -> bool Batteries.Option.t
\end{ocamldoccode}
\index{(-gt)@\verb`(>)`}
\end{ocamldocsigend}


\begin{ocamldocdescription}
Modules including BasePartialOrder fulfil all requirements to become a partial order.
    They can be typeclass-like extended by MakePartialOrder.


\end{ocamldocdescription}




\begin{ocamldoccode}
{\tt{module type }}{\tt{PartialOrder}}{\tt{ = }}\end{ocamldoccode}
\label{moduletype:PolyTypes.PartialOrder}\index{PartialOrder@\verb`PartialOrder`}

\begin{ocamldocsigend}


{\tt{include }}{\tt{PolyTypes.BasePartialOrder}}

\label{val:PolyTypes.PartialOrder.(-lt)}\begin{ocamldoccode}
val (<) : t -> t -> bool Batteries.Option.t
\end{ocamldoccode}
\index{(-lt)@\verb`(<)`}


\label{val:PolyTypes.PartialOrder.(-gt-equal)}\begin{ocamldoccode}
val (>=) : t -> t -> bool Batteries.Option.t
\end{ocamldoccode}
\index{(-gt-equal)@\verb`(>=)`}


\label{val:PolyTypes.PartialOrder.(-lt-equal)}\begin{ocamldoccode}
val (<=) : t -> t -> bool Batteries.Option.t
\end{ocamldoccode}
\index{(-lt-equal)@\verb`(<=)`}
\end{ocamldocsigend}


\begin{ocamldocdescription}
Modules including PartialOrder hold a type that defines a partial order on its elements


\end{ocamldocdescription}




\begin{ocamldoccode}
{\tt{module }}{\tt{MakePartialOrder}}{\tt{ : }}\end{ocamldoccode}
\label{module:PolyTypes.MakePartialOrder}\index{MakePartialOrder@\verb`MakePartialOrder`}

{\tt{functor (}}{\tt{Base}}{\tt{ : }}{\tt{BasePartialOrder}}{\tt{) -> }}\begin{ocamldocsigend}


{\tt{include }}{\tt{Base}}\end{ocamldocsigend}




\begin{ocamldocdescription}
Extends a BasePartialOrder to get all the methods of a partial order


\end{ocamldocdescription}




\begin{ocamldoccode}
{\tt{module type }}{\tt{Valuation}}{\tt{ = }}\end{ocamldoccode}
\label{moduletype:PolyTypes.Valuation}\index{Valuation@\verb`Valuation`}

\begin{ocamldocsigend}


\label{type:PolyTypes.Valuation.t}\begin{ocamldoccode}
type t 
\end{ocamldoccode}
\index{t@\verb`t`}


\label{type:PolyTypes.Valuation.var}\begin{ocamldoccode}
type var = Var.t 
\end{ocamldoccode}
\index{var@\verb`var`}


\label{type:PolyTypes.Valuation.value}\begin{ocamldoccode}
type value 
\end{ocamldoccode}
\index{value@\verb`value`}


\label{val:PolyTypes.Valuation.from}\begin{ocamldoccode}
val from : (var * value) list ->
  t
\end{ocamldoccode}
\index{from@\verb`from`}


\label{val:PolyTypes.Valuation.from-underscorenative}\begin{ocamldoccode}
val from_native : (string * int) list -> t
\end{ocamldoccode}
\index{from-underscorenative@\verb`from_native`}
\begin{ocamldocdescription}
Creates a valuation from a string (var) to int (value) association list


\end{ocamldocdescription}


\label{val:PolyTypes.Valuation.zero}\begin{ocamldoccode}
val zero : var list -> t
\end{ocamldoccode}
\index{zero@\verb`zero`}
\begin{ocamldocdescription}
Creates a valuation where every variable is assigned the value zero


\end{ocamldocdescription}


\label{val:PolyTypes.Valuation.eval}\begin{ocamldoccode}
val eval : var -> t -> value
\end{ocamldoccode}
\index{eval@\verb`eval`}
\begin{ocamldocdescription}
Returns the value of the variable.
        !! If the valuation does not provide a value for a variable, an exception is raised. !!


\end{ocamldocdescription}


\label{val:PolyTypes.Valuation.eval-underscoreopt}\begin{ocamldoccode}
val eval_opt : var ->
  t -> value Batteries.Option.t
\end{ocamldoccode}
\index{eval-underscoreopt@\verb`eval_opt`}
\begin{ocamldocdescription}
Returns the value of the variable, if the valuation defines one for it.


\end{ocamldocdescription}


\label{val:PolyTypes.Valuation.is-underscoredefined}\begin{ocamldoccode}
val is_defined : t -> var -> bool
\end{ocamldoccode}
\index{is-underscoredefined@\verb`is_defined`}


\label{val:PolyTypes.Valuation.vars}\begin{ocamldoccode}
val vars : t -> var list
\end{ocamldoccode}
\index{vars@\verb`vars`}
\begin{ocamldocdescription}
Returns a list of the variables for which the valuation is defined


\end{ocamldocdescription}


\label{val:PolyTypes.Valuation.bindings}\begin{ocamldoccode}
val bindings : t ->
  (var * value) Batteries.Enum.t
\end{ocamldoccode}
\index{bindings@\verb`bindings`}
\begin{ocamldocdescription}
Returns the var to value bindings.


\end{ocamldocdescription}


\label{val:PolyTypes.Valuation.to-underscorestring}\begin{ocamldoccode}
val to_string : t -> string
\end{ocamldoccode}
\index{to-underscorestring@\verb`to_string`}
\begin{ocamldocdescription}
Converts the valuation into a string using the print function


\end{ocamldocdescription}
\end{ocamldocsigend}


\begin{ocamldocdescription}
A valuation is a function which maps from a finite set of variables to values


\end{ocamldocdescription}




\begin{ocamldoccode}
{\tt{module type }}{\tt{Evaluable}}{\tt{ = }}\end{ocamldoccode}
\label{moduletype:PolyTypes.Evaluable}\index{Evaluable@\verb`Evaluable`}

\begin{ocamldocsigend}


\label{type:PolyTypes.Evaluable.t}\begin{ocamldoccode}
type t 
\end{ocamldoccode}
\index{t@\verb`t`}


\label{type:PolyTypes.Evaluable.value}\begin{ocamldoccode}
type value 
\end{ocamldoccode}
\index{value@\verb`value`}


\label{type:PolyTypes.Evaluable.valuation}\begin{ocamldoccode}
type valuation 
\end{ocamldoccode}
\index{valuation@\verb`valuation`}


\label{val:PolyTypes.Evaluable.(-equal-tilde-equal)}\begin{ocamldoccode}
val (=~=) : t -> t -> bool
\end{ocamldoccode}
\index{(-equal-tilde-equal)@\verb`(=~=)`}


\label{val:PolyTypes.Evaluable.equal}\begin{ocamldoccode}
val equal : t -> t -> bool
\end{ocamldoccode}
\index{equal@\verb`equal`}
\begin{ocamldocdescription}
Stable structural equality, but not actual equality


\end{ocamldocdescription}


\label{val:PolyTypes.Evaluable.compare}\begin{ocamldoccode}
val compare : t -> t -> int
\end{ocamldoccode}
\index{compare@\verb`compare`}
\begin{ocamldocdescription}
Stable structural compare, but not an actual compare


\end{ocamldocdescription}


\label{val:PolyTypes.Evaluable.to-underscorestring}\begin{ocamldoccode}
val to_string : ?to_file:bool -> t -> string
\end{ocamldoccode}
\index{to-underscorestring@\verb`to_string`}


\label{val:PolyTypes.Evaluable.vars}\begin{ocamldoccode}
val vars : t -> VarSet.t
\end{ocamldoccode}
\index{vars@\verb`vars`}
\begin{ocamldocdescription}
Returns a set of the variables which occur in the evaluable


\end{ocamldocdescription}


\label{val:PolyTypes.Evaluable.eval}\begin{ocamldoccode}
val eval : t ->
  valuation -> value
\end{ocamldoccode}
\index{eval@\verb`eval`}
\begin{ocamldocdescription}
Assigns each variable inside the polynomial the value of the valuation and returns the arithmetically computed result. 
        !! If the valuation does not provide a value for a variable, an exception is raised. !!


\end{ocamldocdescription}


\label{val:PolyTypes.Evaluable.eval-underscoref}\begin{ocamldoccode}
val eval_f : t ->
  (Var.t -> value) -> value
\end{ocamldoccode}
\index{eval-underscoref@\verb`eval_f`}


\label{val:PolyTypes.Evaluable.rename}\begin{ocamldoccode}
val rename : RenameMap.t -> t -> t
\end{ocamldoccode}
\index{rename@\verb`rename`}
\begin{ocamldocdescription}
Assigns the variables of the evaluable new names based on the rename map.


\end{ocamldocdescription}


\label{val:PolyTypes.Evaluable.degree}\begin{ocamldoccode}
val degree : t -> int
\end{ocamldoccode}
\index{degree@\verb`degree`}
\end{ocamldocsigend}


\begin{ocamldocdescription}
Evaluable is a unified interface of all parts of a polynomial


\end{ocamldocdescription}




\begin{ocamldoccode}
{\tt{module type }}{\tt{Monomial}}{\tt{ = }}\end{ocamldoccode}
\label{moduletype:PolyTypes.Monomial}\index{Monomial@\verb`Monomial`}

\begin{ocamldocsigend}


\label{type:PolyTypes.Monomial.t}\begin{ocamldoccode}
type t 
\end{ocamldoccode}
\index{t@\verb`t`}


{\tt{include }}{\tt{PolyTypes.Evaluable}}

\label{val:PolyTypes.Monomial.make}\begin{ocamldoccode}
val make : (Var.t * int) list -> t
\end{ocamldoccode}
\index{make@\verb`make`}


\label{val:PolyTypes.Monomial.lift}\begin{ocamldoccode}
val lift : Var.t -> int -> t
\end{ocamldoccode}
\index{lift@\verb`lift`}


\label{val:PolyTypes.Monomial.degree-underscorevariable}\begin{ocamldoccode}
val degree_variable : Var.t -> t -> int
\end{ocamldoccode}
\index{degree-underscorevariable@\verb`degree_variable`}
\begin{ocamldocdescription}
Returns the degree of the given variable.


\end{ocamldocdescription}


\label{val:PolyTypes.Monomial.delete-underscorevar}\begin{ocamldoccode}
val delete_var : Var.t -> t -> t
\end{ocamldoccode}
\index{delete-underscorevar@\verb`delete_var`}
\begin{ocamldocdescription}
Deletes all occurences of the given variable.


\end{ocamldocdescription}


\label{val:PolyTypes.Monomial.is-underscoreunivariate-underscorelinear}\begin{ocamldoccode}
val is_univariate_linear : t -> bool
\end{ocamldoccode}
\index{is-underscoreunivariate-underscorelinear@\verb`is_univariate_linear`}
\begin{ocamldocdescription}
Returns if the monomial is of the simplified form x{\textasciicircum}1 for any variable x.


\end{ocamldocdescription}


\label{val:PolyTypes.Monomial.mul}\begin{ocamldoccode}
val mul : t -> t -> t
\end{ocamldoccode}
\index{mul@\verb`mul`}
\begin{ocamldocdescription}
Multiplies two monomials. The result is always a monomial.


\end{ocamldocdescription}


\label{val:PolyTypes.Monomial.one}\begin{ocamldoccode}
val one : t
\end{ocamldoccode}
\index{one@\verb`one`}
\begin{ocamldocdescription}
Returns a monomial representing the numeric value one (1).


\end{ocamldocdescription}


\label{val:PolyTypes.Monomial.fold}\begin{ocamldoccode}
val fold :
  const:(value -> {\textquotesingle}b) ->
  var:(Var.t -> {\textquotesingle}b) ->
  times:({\textquotesingle}b -> {\textquotesingle}b -> {\textquotesingle}b) -> pow:({\textquotesingle}b -> int -> {\textquotesingle}b) -> t -> {\textquotesingle}b
\end{ocamldoccode}
\index{fold@\verb`fold`}
\begin{ocamldocdescription}
Replaces all arithmetical operations by new constructors.


\end{ocamldocdescription}
\end{ocamldocsigend}


\begin{ocamldocdescription}
A monomial is a finite product of powers


\end{ocamldocdescription}




\begin{ocamldoccode}
{\tt{module type }}{\tt{ScaledMonomial}}{\tt{ = }}\end{ocamldoccode}
\label{moduletype:PolyTypes.ScaledMonomial}\index{ScaledMonomial@\verb`ScaledMonomial`}

\begin{ocamldocsigend}


\label{type:PolyTypes.ScaledMonomial.t}\begin{ocamldoccode}
type t 
\end{ocamldoccode}
\index{t@\verb`t`}


\label{type:PolyTypes.ScaledMonomial.monomial}\begin{ocamldoccode}
type monomial 
\end{ocamldoccode}
\index{monomial@\verb`monomial`}


{\tt{include }}{\tt{PolyTypes.Evaluable}}

{\tt{include }}{\tt{PolyTypes.PartialOrder}}

\label{val:PolyTypes.ScaledMonomial.make}\begin{ocamldoccode}
val make : value -> monomial -> t
\end{ocamldoccode}
\index{make@\verb`make`}


\label{val:PolyTypes.ScaledMonomial.lift}\begin{ocamldoccode}
val lift : monomial -> t
\end{ocamldoccode}
\index{lift@\verb`lift`}


\label{val:PolyTypes.ScaledMonomial.mul}\begin{ocamldoccode}
val mul : t ->
  t -> t
\end{ocamldoccode}
\index{mul@\verb`mul`}


\label{val:PolyTypes.ScaledMonomial.mult-underscorewith-underscoreconst}\begin{ocamldoccode}
val mult_with_const : value -> t -> t
\end{ocamldoccode}
\index{mult-underscorewith-underscoreconst@\verb`mult_with_const`}


\label{val:PolyTypes.ScaledMonomial.one}\begin{ocamldoccode}
val one : t
\end{ocamldoccode}
\index{one@\verb`one`}


\label{val:PolyTypes.ScaledMonomial.coeff}\begin{ocamldoccode}
val coeff : t -> value
\end{ocamldoccode}
\index{coeff@\verb`coeff`}


\label{val:PolyTypes.ScaledMonomial.monomial}\begin{ocamldoccode}
val monomial : t -> monomial
\end{ocamldoccode}
\index{monomial@\verb`monomial`}


\label{val:PolyTypes.ScaledMonomial.fold}\begin{ocamldoccode}
val fold :
  const:(value -> {\textquotesingle}b) ->
  var:(Var.t -> {\textquotesingle}b) ->
  times:({\textquotesingle}b -> {\textquotesingle}b -> {\textquotesingle}b) ->
  pow:({\textquotesingle}b -> int -> {\textquotesingle}b) -> t -> {\textquotesingle}b
\end{ocamldoccode}
\index{fold@\verb`fold`}
\end{ocamldocsigend}


\begin{ocamldocdescription}
A scaled monomial is a monomial multiplied with a coefficient


\end{ocamldocdescription}




\begin{ocamldoccode}
{\tt{module type }}{\tt{BaseMath}}{\tt{ = }}\end{ocamldoccode}
\label{moduletype:PolyTypes.BaseMath}\index{BaseMath@\verb`BaseMath`}

\begin{ocamldocsigend}


\label{type:PolyTypes.BaseMath.t}\begin{ocamldoccode}
type t 
\end{ocamldoccode}
\index{t@\verb`t`}


\label{val:PolyTypes.BaseMath.zero}\begin{ocamldoccode}
val zero : t
\end{ocamldoccode}
\index{zero@\verb`zero`}


\label{val:PolyTypes.BaseMath.one}\begin{ocamldoccode}
val one : t
\end{ocamldoccode}
\index{one@\verb`one`}


\label{val:PolyTypes.BaseMath.neg}\begin{ocamldoccode}
val neg : t -> t
\end{ocamldoccode}
\index{neg@\verb`neg`}


\label{val:PolyTypes.BaseMath.add}\begin{ocamldoccode}
val add : t -> t -> t
\end{ocamldoccode}
\index{add@\verb`add`}


\label{val:PolyTypes.BaseMath.mul}\begin{ocamldoccode}
val mul : t -> t -> t
\end{ocamldoccode}
\index{mul@\verb`mul`}


\label{val:PolyTypes.BaseMath.pow}\begin{ocamldoccode}
val pow : t -> int -> t
\end{ocamldoccode}
\index{pow@\verb`pow`}
\end{ocamldocsigend}


\begin{ocamldocdescription}
Modules including BaseMath define basic math operations.
    They can be typeclass-like extended by MakeMath


\end{ocamldocdescription}




\begin{ocamldoccode}
{\tt{module type }}{\tt{Math}}{\tt{ = }}\end{ocamldoccode}
\label{moduletype:PolyTypes.Math}\index{Math@\verb`Math`}

\begin{ocamldocsigend}


{\tt{include }}{\tt{PolyTypes.BaseMath}}

\label{val:PolyTypes.Math.sum}\begin{ocamldoccode}
val sum : t Batteries.Enum.t -> t
\end{ocamldoccode}
\index{sum@\verb`sum`}


\label{val:PolyTypes.Math.product}\begin{ocamldoccode}
val product : t Batteries.Enum.t -> t
\end{ocamldoccode}
\index{product@\verb`product`}


\label{val:PolyTypes.Math.sub}\begin{ocamldoccode}
val sub : t -> t -> t
\end{ocamldoccode}
\index{sub@\verb`sub`}


\label{val:PolyTypes.Math.(-plus)}\begin{ocamldoccode}
val (+) : t -> t -> t
\end{ocamldoccode}
\index{(-plus)@\verb`(+)`}


\label{val:PolyTypes.Math.(-minus)}\begin{ocamldoccode}
val (-) : t -> t -> t
\end{ocamldoccode}
\index{(-minus)@\verb`(-)`}


\label{val:PolyTypes.Math.( -star )}\begin{ocamldoccode}
val ( * ) : t -> t -> t
\end{ocamldoccode}
\index{( -star )@\verb`( * )`}


\label{val:PolyTypes.Math.( -star-star )}\begin{ocamldoccode}
val ( ** ) : t -> int -> t
\end{ocamldoccode}
\index{( -star-star )@\verb`( ** )`}


\label{val:PolyTypes.Math.(-tilde-minus)}\begin{ocamldoccode}
val (~-) : t -> t
\end{ocamldoccode}
\index{(-tilde-minus)@\verb`(~-)`}
\end{ocamldocsigend}


\begin{ocamldocdescription}
Modules including Math hold a type that defines basic math operations on its elements


\end{ocamldocdescription}




\begin{ocamldoccode}
{\tt{module }}{\tt{MakeMath}}{\tt{ : }}\end{ocamldoccode}
\label{module:PolyTypes.MakeMath}\index{MakeMath@\verb`MakeMath`}

{\tt{functor (}}{\tt{Base}}{\tt{ : }}{\tt{BaseMath}}{\tt{) -> }}\begin{ocamldocsigend}


{\tt{include }}{\tt{Base}}

\label{val:PolyTypes.MakeMath.sum}\begin{ocamldoccode}
val sum : t Batteries.Enum.t -> t
\end{ocamldoccode}
\index{sum@\verb`sum`}


\label{val:PolyTypes.MakeMath.product}\begin{ocamldoccode}
val product : t Batteries.Enum.t -> t
\end{ocamldoccode}
\index{product@\verb`product`}


\label{val:PolyTypes.MakeMath.sub}\begin{ocamldoccode}
val sub : t -> t -> t
\end{ocamldoccode}
\index{sub@\verb`sub`}
\end{ocamldocsigend}




\begin{ocamldocdescription}
Extends a BaseMath module to get all math methods


\end{ocamldocdescription}




\begin{ocamldoccode}
{\tt{module type }}{\tt{Ring}}{\tt{ = }}\end{ocamldoccode}
\label{moduletype:PolyTypes.Ring}\index{Ring@\verb`Ring`}

\begin{ocamldocsigend}


\label{type:PolyTypes.Ring.t}\begin{ocamldoccode}
type t 
\end{ocamldoccode}
\index{t@\verb`t`}


\label{val:PolyTypes.Ring.equal}\begin{ocamldoccode}
val equal : t -> t -> bool
\end{ocamldoccode}
\index{equal@\verb`equal`}


{\tt{include }}{\tt{PolyTypes.BaseMath}}

\label{val:PolyTypes.Ring.equal}\begin{ocamldoccode}
val equal : t -> t -> bool
\end{ocamldoccode}
\index{equal@\verb`equal`}


\label{val:PolyTypes.Ring.(-equal-tilde-equal)}\begin{ocamldoccode}
val (=~=) : t -> t -> bool
\end{ocamldoccode}
\index{(-equal-tilde-equal)@\verb`(=~=)`}
\begin{ocamldocdescription}
Stable structural compare, but not an actual compare


\end{ocamldocdescription}


\label{val:PolyTypes.Ring.compare}\begin{ocamldoccode}
val compare : t -> t -> int
\end{ocamldoccode}
\index{compare@\verb`compare`}


\label{val:PolyTypes.Ring.of-underscoreint}\begin{ocamldoccode}
val of_int : int -> t
\end{ocamldoccode}
\index{of-underscoreint@\verb`of_int`}


\label{val:PolyTypes.Ring.to-underscoreint}\begin{ocamldoccode}
val to_int : t -> int
\end{ocamldoccode}
\index{to-underscoreint@\verb`to_int`}


\label{val:PolyTypes.Ring.to-underscorestring}\begin{ocamldoccode}
val to_string : t -> string
\end{ocamldoccode}
\index{to-underscorestring@\verb`to_string`}
\end{ocamldocsigend}






\begin{ocamldoccode}
{\tt{module type }}{\tt{Polynomial}}{\tt{ = }}\end{ocamldoccode}
\label{moduletype:PolyTypes.Polynomial}\index{Polynomial@\verb`Polynomial`}

\begin{ocamldocsigend}


\label{type:PolyTypes.Polynomial.t}\begin{ocamldoccode}
type t 
\end{ocamldoccode}
\index{t@\verb`t`}


{\tt{include }}{\tt{PolyTypes.Evaluable}}

{\tt{include }}{\tt{PolyTypes.Math}}

{\tt{include }}{\tt{PolyTypes.PartialOrder}}

{\tt{include }}{\tt{PolyTypes.Ring}}

\label{type:PolyTypes.Polynomial.monomial}\begin{ocamldoccode}
type monomial 
\end{ocamldoccode}
\index{monomial@\verb`monomial`}


\label{type:PolyTypes.Polynomial.scaled-underscoremonomial}\begin{ocamldoccode}
type scaled_monomial 
\end{ocamldoccode}
\index{scaled-underscoremonomial@\verb`scaled_monomial`}


Following methods are convenience methods for the creation of polynomials.

\label{val:PolyTypes.Polynomial.make}\begin{ocamldoccode}
val make : (value * monomial) list -> t
\end{ocamldoccode}
\index{make@\verb`make`}


\label{val:PolyTypes.Polynomial.lift}\begin{ocamldoccode}
val lift : value -> monomial -> t
\end{ocamldoccode}
\index{lift@\verb`lift`}


\label{val:PolyTypes.Polynomial.of-underscorescaled}\begin{ocamldoccode}
val of_scaled : scaled_monomial list -> t
\end{ocamldoccode}
\index{of-underscorescaled@\verb`of_scaled`}


\label{val:PolyTypes.Polynomial.of-underscorevar}\begin{ocamldoccode}
val of_var : Var.t -> t
\end{ocamldoccode}
\index{of-underscorevar@\verb`of_var`}


\label{val:PolyTypes.Polynomial.of-underscoreconstant}\begin{ocamldoccode}
val of_constant : value -> t
\end{ocamldoccode}
\index{of-underscoreconstant@\verb`of_constant`}


\label{val:PolyTypes.Polynomial.var}\begin{ocamldoccode}
val var : string -> t
\end{ocamldoccode}
\index{var@\verb`var`}


\label{val:PolyTypes.Polynomial.value}\begin{ocamldoccode}
val value : int -> t
\end{ocamldoccode}
\index{value@\verb`value`}


\label{val:PolyTypes.Polynomial.real-underscorehelper}\begin{ocamldoccode}
val real_helper : int -> t
\end{ocamldoccode}
\index{real-underscorehelper@\verb`real_helper`}


\label{val:PolyTypes.Polynomial.int-underscorehelper}\begin{ocamldoccode}
val int_helper : int -> t
\end{ocamldoccode}
\index{int-underscorehelper@\verb`int_helper`}


\label{val:PolyTypes.Polynomial.of-underscorepower}\begin{ocamldoccode}
val of_power : Var.t -> int -> t
\end{ocamldoccode}
\index{of-underscorepower@\verb`of_power`}


\label{val:PolyTypes.Polynomial.of-underscoremonomial}\begin{ocamldoccode}
val of_monomial : monomial -> t
\end{ocamldoccode}
\index{of-underscoremonomial@\verb`of_monomial`}


\label{val:PolyTypes.Polynomial.of-underscorecoeff-underscorelist}\begin{ocamldoccode}
val of_coeff_list : value list -> Var.t list -> t
\end{ocamldoccode}
\index{of-underscorecoeff-underscorelist@\verb`of_coeff_list`}


Following methods return information over the polynomial.

\label{val:PolyTypes.Polynomial.coeff}\begin{ocamldoccode}
val coeff : monomial -> t -> value
\end{ocamldoccode}
\index{coeff@\verb`coeff`}
\begin{ocamldocdescription}
Returns the coefficient of the monomial.


\end{ocamldocdescription}


\label{val:PolyTypes.Polynomial.coeff-underscoreof-underscorevar}\begin{ocamldoccode}
val coeff_of_var : Var.t -> t -> value
\end{ocamldoccode}
\index{coeff-underscoreof-underscorevar@\verb`coeff_of_var`}


\label{val:PolyTypes.Polynomial.monomials}\begin{ocamldoccode}
val monomials : t -> monomial list
\end{ocamldoccode}
\index{monomials@\verb`monomials`}
\begin{ocamldocdescription}
Returns the monomials of the polynomial without the empty monomial.


\end{ocamldocdescription}


\label{val:PolyTypes.Polynomial.get-underscoreconstant}\begin{ocamldoccode}
val get_constant : t -> value
\end{ocamldoccode}
\index{get-underscoreconstant@\verb`get_constant`}
\begin{ocamldocdescription}
Returns the constant of the polynomial.


\end{ocamldocdescription}


\label{val:PolyTypes.Polynomial.to-underscorestring}\begin{ocamldoccode}
val to_string : t -> string
\end{ocamldoccode}
\index{to-underscorestring@\verb`to_string`}


\label{val:PolyTypes.Polynomial.to-underscorestring-underscoreto-underscorefile}\begin{ocamldoccode}
val to_string_to_file : t -> string
\end{ocamldoccode}
\index{to-underscorestring-underscoreto-underscorefile@\verb`to_string_to_file`}


Following methods return if the atom has certain properties.

\label{val:PolyTypes.Polynomial.is-underscorevar}\begin{ocamldoccode}
val is_var : t -> bool
\end{ocamldoccode}
\index{is-underscorevar@\verb`is_var`}
\begin{ocamldocdescription}
Returns if the polynomial is equivalent to a term x{\textasciicircum}1 for any variable x.


\end{ocamldocdescription}


\label{val:PolyTypes.Polynomial.is-underscorevar-underscoreplus-underscoreconstant}\begin{ocamldoccode}
val is_var_plus_constant : t -> bool
\end{ocamldoccode}
\index{is-underscorevar-underscoreplus-underscoreconstant@\verb`is_var_plus_constant`}
\begin{ocamldocdescription}
Returns if the polynomial is equivalent to a term x{\textasciicircum}1 + c for any variable x and any constant c.


\end{ocamldocdescription}


\label{val:PolyTypes.Polynomial.is-underscoresum-underscoreof-underscorevars-underscoreplus-underscoreconstant}\begin{ocamldoccode}
val is_sum_of_vars_plus_constant : t -> bool
\end{ocamldoccode}
\index{is-underscoresum-underscoreof-underscorevars-underscoreplus-underscoreconstant@\verb`is_sum_of_vars_plus_constant`}
\begin{ocamldocdescription}
Returns if the polynomial is equivalent to a term x\_1{\textasciicircum}1 + $\ldots$ + x\_n{\textasciicircum}1 + c for any variables x\_1, $\ldots$, x\_n and any constant c.


\end{ocamldocdescription}


\label{val:PolyTypes.Polynomial.is-underscoreunivariate-underscorelinear}\begin{ocamldoccode}
val is_univariate_linear : t -> bool
\end{ocamldoccode}
\index{is-underscoreunivariate-underscorelinear@\verb`is_univariate_linear`}
\begin{ocamldocdescription}
Returns if the polyomial is linear and contains at most one active variable.


\end{ocamldocdescription}


\label{val:PolyTypes.Polynomial.is-underscoreconst}\begin{ocamldoccode}
val is_const : t -> bool
\end{ocamldoccode}
\index{is-underscoreconst@\verb`is_const`}
\begin{ocamldocdescription}
Returns if the value of the polynomial is not be affected by any variable.


\end{ocamldocdescription}


\label{val:PolyTypes.Polynomial.is-underscorelinear}\begin{ocamldoccode}
val is_linear : t -> bool
\end{ocamldoccode}
\index{is-underscorelinear@\verb`is_linear`}
\begin{ocamldocdescription}
Returns if the polynomial is linear.


\end{ocamldocdescription}


\label{val:PolyTypes.Polynomial.is-underscorezero}\begin{ocamldoccode}
val is_zero : t -> bool
\end{ocamldoccode}
\index{is-underscorezero@\verb`is_zero`}
\begin{ocamldocdescription}
Returns if the value of the polynomial is the constant value zero (0).


\end{ocamldocdescription}


\label{val:PolyTypes.Polynomial.is-underscoreone}\begin{ocamldoccode}
val is_one : t -> bool
\end{ocamldoccode}
\index{is-underscoreone@\verb`is_one`}
\begin{ocamldocdescription}
Returns if the value of the polynomial is the constant value one (1).


\end{ocamldocdescription}


Misc

\label{val:PolyTypes.Polynomial.eval-underscorepartial}\begin{ocamldoccode}
val eval_partial : t -> valuation -> t
\end{ocamldoccode}
\index{eval-underscorepartial@\verb`eval_partial`}
\begin{ocamldocdescription}
Creates a polynomial where every variable for which a value is assigned by the valuation is replaced by this value.


\end{ocamldocdescription}


\label{val:PolyTypes.Polynomial.instantiate}\begin{ocamldoccode}
val instantiate : (value -> t) ->
  t -> t
\end{ocamldoccode}
\index{instantiate@\verb`instantiate`}
\begin{ocamldocdescription}
Maps all coefficients to elements from the polynomial.


\end{ocamldocdescription}


\label{val:PolyTypes.Polynomial.substitute}\begin{ocamldoccode}
val substitute : Var.t ->
  replacement:t ->
  t -> t
\end{ocamldoccode}
\index{substitute@\verb`substitute`}
\begin{ocamldocdescription}
Substitutes every occurrence of the variable in the polynomial by the replacement polynomial.
        Ignores naming equalities.


\end{ocamldocdescription}


\label{val:PolyTypes.Polynomial.substitute-underscoref}\begin{ocamldoccode}
val substitute_f : (Var.t -> t) ->
  t -> t
\end{ocamldoccode}
\index{substitute-underscoref@\verb`substitute_f`}
\begin{ocamldocdescription}
Substitutes every occurrence of the variables in the polynomial by the corresponding replacement polynomial.


\end{ocamldocdescription}


\label{val:PolyTypes.Polynomial.substitute-underscoreall}\begin{ocamldoccode}
val substitute_all : t Batteries.Map.Make(Var).t ->
  t -> t
\end{ocamldoccode}
\index{substitute-underscoreall@\verb`substitute_all`}
\begin{ocamldocdescription}
Substitutes every occurrence of the variables in the polynomial by the corresponding replacement polynomial.
        Leaves all variables unchanged which are not in the replacement map.


\end{ocamldocdescription}


\label{val:PolyTypes.Polynomial.delete-underscoremonomial}\begin{ocamldoccode}
val delete_monomial : monomial ->
  t -> t
\end{ocamldoccode}
\index{delete-underscoremonomial@\verb`delete_monomial`}
\begin{ocamldocdescription}
Removes all summands from the polynomial which are equivalent to the monomial.


\end{ocamldocdescription}


\label{val:PolyTypes.Polynomial.simplify}\begin{ocamldoccode}
val simplify : t -> t
\end{ocamldoccode}
\index{simplify@\verb`simplify`}
\begin{ocamldocdescription}
Returns a simplified version of the polynomial.
        Subsequent calls to simplify will not lead to a further simplification.


\end{ocamldocdescription}


\label{val:PolyTypes.Polynomial.mult-underscorewith-underscoreconst}\begin{ocamldoccode}
val mult_with_const : value -> t -> t
\end{ocamldoccode}
\index{mult-underscorewith-underscoreconst@\verb`mult_with_const`}
\begin{ocamldocdescription}
Multiplies the polynomial with a constant value.
        The result is always a polynomial.


\end{ocamldocdescription}


\label{val:PolyTypes.Polynomial.fold}\begin{ocamldoccode}
val fold :
  const:(value -> {\textquotesingle}b) ->
  var:(Var.t -> {\textquotesingle}b) ->
  neg:({\textquotesingle}b -> {\textquotesingle}b) ->
  plus:({\textquotesingle}b -> {\textquotesingle}b -> {\textquotesingle}b) ->
  times:({\textquotesingle}b -> {\textquotesingle}b -> {\textquotesingle}b) ->
  pow:({\textquotesingle}b -> int -> {\textquotesingle}b) -> t -> {\textquotesingle}b
\end{ocamldoccode}
\index{fold@\verb`fold`}
\begin{ocamldocdescription}
Replaces all arithmetical operations by new constructors.


\end{ocamldocdescription}
\end{ocamldocsigend}


\begin{ocamldocdescription}
A Polynomial represents a mathematical polynomial


\end{ocamldocdescription}


\section{Module {\tt{Atoms}} : Provides default implementations of an atom.}
\label{module:Atoms}\index{Atoms@\verb`Atoms`}




\ocamldocvspace{0.5cm}



Provides default implementations of an atom, i.e., for two objects q and p (e.g. polynomials, bounds), and a comparator \~{}, the expression  q \~{} p is an atom.



\begin{ocamldoccode}
{\tt{module }}{\tt{AtomOver}}{\tt{ : }}\end{ocamldoccode}
\label{module:Atoms.AtomOver}\index{AtomOver@\verb`AtomOver`}

{\tt{functor (}}{\tt{P}}{\tt{ : }}{\tt{ConstraintTypes.Atomizable}}{\tt{) -> }}{\tt{ConstraintTypes.Atom}}{\tt{ }}{\tt{\
       with type polynomial = P.t\
        and type value = P.value\
        and module P = P}}



\begin{ocamldocdescription}
Constructs a default constraint using a simple record


\end{ocamldocdescription}




\begin{ocamldoccode}
{\tt{module }}{\tt{Atom}}{\tt{ : }}\end{ocamldoccode}
\label{module:Atoms.Atom}\index{Atom@\verb`Atom`}

\begin{ocamldocsigend}


{\tt{include }}{\tt{??}}

\label{val:Atoms.Atom.max-underscoreof-underscoreoccurring-underscoreconstants}\begin{ocamldoccode}
val max_of_occurring_constants : t -> OurInt.t
\end{ocamldoccode}
\index{max-underscoreof-underscoreoccurring-underscoreconstants@\verb`max_of_occurring_constants`}
\end{ocamldocsigend}


\begin{ocamldocdescription}
Provides an implementation of atoms over polynomials.


\end{ocamldocdescription}




\begin{ocamldoccode}
{\tt{module }}{\tt{ParameterAtom}}{\tt{ : }}\end{ocamldoccode}
\label{module:Atoms.ParameterAtom}\index{ParameterAtom@\verb`ParameterAtom`}

\begin{ocamldocsigend}


{\tt{include }}{\tt{??}}

\label{val:Atoms.ParameterAtom.get-underscorecoefficient}\begin{ocamldoccode}
val get_coefficient : Var.t -> t -> value
\end{ocamldoccode}
\index{get-underscorecoefficient@\verb`get_coefficient`}
\begin{ocamldocdescription}
Returns the coefficient of a variable which is normalised to the lhs.


\end{ocamldocdescription}


\label{val:Atoms.ParameterAtom.get-underscoreconstant}\begin{ocamldoccode}
val get_constant : t -> value
\end{ocamldoccode}
\index{get-underscoreconstant@\verb`get_constant`}
\begin{ocamldocdescription}
Returns the single right hand side constant of the atom.


\end{ocamldocdescription}
\end{ocamldocsigend}


\begin{ocamldocdescription}
Provides an implementation of atoms over parameter polynomials.


\end{ocamldocdescription}




\begin{ocamldoccode}
{\tt{module }}{\tt{BoundAtom}}{\tt{ : }}\end{ocamldoccode}
\label{module:Atoms.BoundAtom}\index{BoundAtom@\verb`BoundAtom`}

\begin{ocamldocsigend}


{\tt{include }}{\tt{??}}\end{ocamldocsigend}


\begin{ocamldocdescription}
Provides an implementation of atoms over bounds.


\end{ocamldocdescription}


\section{Module {\tt{Formulas}}}
\label{module:Formulas}\index{Formulas@\verb`Formulas`}


\ocamldocvspace{0.5cm}



Provides default implementations of a constraint



\begin{ocamldoccode}
{\tt{module }}{\tt{FormulaOver}}{\tt{ : }}\end{ocamldoccode}
\label{module:Formulas.FormulaOver}\index{FormulaOver@\verb`FormulaOver`}

{\tt{functor (}}{\tt{C}}{\tt{ : }}{\tt{ConstraintTypes.Constraint}}{\tt{) -> }}{\tt{ConstraintTypes.Formula}}{\tt{ }}{\tt{\
       with type constr = C.t\
        and type atom = C.atom\
        and type polynomial = C.polynomial\
        and type value = C.value}}



\begin{ocamldocdescription}
Constructs a default constraint using a list of atoms each comparing two polynomials


\end{ocamldocdescription}




\begin{ocamldoccode}
{\tt{module }}{\tt{Formula}}{\tt{ : }}\end{ocamldoccode}
\label{module:Formulas.Formula}\index{Formula@\verb`Formula`}

\begin{ocamldocsigend}


{\tt{include }}{\tt{??}}

\label{val:Formulas.Formula.max-underscoreof-underscoreoccurring-underscoreconstants}\begin{ocamldoccode}
val max_of_occurring_constants : t -> OurInt.t
\end{ocamldoccode}
\index{max-underscoreof-underscoreoccurring-underscoreconstants@\verb`max_of_occurring_constants`}
\end{ocamldocsigend}






\begin{ocamldoccode}
{\tt{module }}{\tt{ParameterFormula}}{\tt{ : }}\end{ocamldoccode}
\label{module:Formulas.ParameterFormula}\index{ParameterFormula@\verb`ParameterFormula`}

\begin{ocamldocsigend}


{\tt{include }}{\tt{??}}\end{ocamldocsigend}




\section{Module {\tt{Constraints}} : Provides default implementations of a constraint.}
\label{module:Constraints}\index{Constraints@\verb`Constraints`}




\ocamldocvspace{0.5cm}



Provides default implementations of a constraint, i.e., a conjunction of atoms.



\begin{ocamldoccode}
{\tt{module }}{\tt{ConstraintOver}}{\tt{ : }}\end{ocamldoccode}
\label{module:Constraints.ConstraintOver}\index{ConstraintOver@\verb`ConstraintOver`}

{\tt{functor (}}{\tt{A}}{\tt{ : }}{\tt{ConstraintTypes.Atom}}{\tt{) -> }}{\tt{ConstraintTypes.Constraint}}{\tt{ }}{\tt{\
       with type polynomial = A.polynomial\
        and type value = A.value\
        and type atom = A.t\
        and type t = A.t list}}



\begin{ocamldocdescription}
Constructs a default constraint using a list of atoms each comparing two polynomials.


\end{ocamldocdescription}




\begin{ocamldoccode}
{\tt{module }}{\tt{Constraint}}{\tt{ : }}\end{ocamldoccode}
\label{module:Constraints.Constraint}\index{Constraint@\verb`Constraint`}

\begin{ocamldocsigend}


{\tt{include }}{\tt{??}}

\label{val:Constraints.Constraint.drop-underscorenonlinear}\begin{ocamldoccode}
val drop_nonlinear : t -> t
\end{ocamldoccode}
\index{drop-underscorenonlinear@\verb`drop_nonlinear`}
\begin{ocamldocdescription}
Drops all nonlinear atoms from the constraints. 
      Example: (a $>$ 0 \&\& b{\textasciicircum}2 $<$ 2) gets transformed to (a $>$ 0)


\end{ocamldocdescription}


The result of the following drop methods is not equivalent to the input constraint. 
      But each satisfying valuation of the input constraint is still a model of the new constraint.

\label{val:Constraints.Constraint.get-underscorecoefficient-underscorevector}\begin{ocamldoccode}
val get_coefficient_vector : Var.t -> t -> value list
\end{ocamldoccode}
\index{get-underscorecoefficient-underscorevector@\verb`get_coefficient_vector`}
\begin{ocamldocdescription}
Returns the row of all coefficients of a variable in a constraint$\ldots$used for farkas quantor elimination


\end{ocamldocdescription}


\label{val:Constraints.Constraint.get-underscorematrix}\begin{ocamldoccode}
val get_matrix : VarSet.t -> t -> value list list
\end{ocamldoccode}
\index{get-underscorematrix@\verb`get_matrix`}


\label{val:Constraints.Constraint.get-underscoreconstant-underscorevector}\begin{ocamldoccode}
val get_constant_vector : t -> value list
\end{ocamldoccode}
\index{get-underscoreconstant-underscorevector@\verb`get_constant_vector`}
\begin{ocamldocdescription}
Returns the row of all coefficients of a variable in a constraint$\ldots$used for farkas quantor elimination


\end{ocamldocdescription}


\label{val:Constraints.Constraint.dualise}\begin{ocamldoccode}
val dualise : Var.t list -> value list list -> polynomial list -> t
\end{ocamldoccode}
\index{dualise@\verb`dualise`}


\label{val:Constraints.Constraint.max-underscoreof-underscoreoccurring-underscoreconstants}\begin{ocamldoccode}
val max_of_occurring_constants : t -> OurInt.t
\end{ocamldoccode}
\index{max-underscoreof-underscoreoccurring-underscoreconstants@\verb`max_of_occurring_constants`}
\end{ocamldocsigend}


\begin{ocamldocdescription}
Provides an implementation of constraints consisting of atoms over polynomials.


\end{ocamldocdescription}




\begin{ocamldoccode}
{\tt{module }}{\tt{ParameterConstraint}}{\tt{ : }}\end{ocamldoccode}
\label{module:Constraints.ParameterConstraint}\index{ParameterConstraint@\verb`ParameterConstraint`}

\begin{ocamldocsigend}


{\tt{include }}{\tt{??}}

\label{val:Constraints.ParameterConstraint.get-underscorecoefficient-underscorevector}\begin{ocamldoccode}
val get_coefficient_vector : Var.t -> t -> value list
\end{ocamldoccode}
\index{get-underscorecoefficient-underscorevector@\verb`get_coefficient_vector`}
\begin{ocamldocdescription}
Returns the row of all coefficients of a variable in a constraint$\ldots$used for farkas quantor elimination


\end{ocamldocdescription}


\label{val:Constraints.ParameterConstraint.get-underscorematrix}\begin{ocamldoccode}
val get_matrix : VarSet.t -> t -> value list list
\end{ocamldoccode}
\index{get-underscorematrix@\verb`get_matrix`}


\label{val:Constraints.ParameterConstraint.get-underscoreconstant-underscorevector}\begin{ocamldoccode}
val get_constant_vector : t -> value list
\end{ocamldoccode}
\index{get-underscoreconstant-underscorevector@\verb`get_constant_vector`}
\begin{ocamldocdescription}
Returns the row of all coefficients of a variable in a constraint$\ldots$used for farkas quantor elimination


\end{ocamldocdescription}


\label{val:Constraints.ParameterConstraint.farkas-underscoretransform}\begin{ocamldoccode}
val farkas_transform :
  Constraints.Constraint.t -> Atoms.ParameterAtom.t -> Constraints.Constraint.t
\end{ocamldoccode}
\index{farkas-underscoretransform@\verb`farkas_transform`}
\end{ocamldocsigend}


\begin{ocamldocdescription}
Provides an implementation of constraints consisting of atoms over parameter polynomials.


\end{ocamldocdescription}




\begin{ocamldoccode}
{\tt{module }}{\tt{BoundConstraint}}{\tt{ : }}\end{ocamldoccode}
\label{module:Constraints.BoundConstraint}\index{BoundConstraint@\verb`BoundConstraint`}

\begin{ocamldocsigend}


{\tt{include }}{\tt{??}}\end{ocamldocsigend}


\begin{ocamldocdescription}
Provides an implementation of constraints consisting of atoms over bounds.


\end{ocamldocdescription}


\section{Module {\tt{ConstraintTypes}}}
\label{module:ConstraintTypes}\index{ConstraintTypes@\verb`ConstraintTypes`}


\ocamldocvspace{0.5cm}



Provides all module types related to constraints



\begin{ocamldoccode}
{\tt{module type }}{\tt{Atomizable}}{\tt{ = }}\end{ocamldoccode}
\label{moduletype:ConstraintTypes.Atomizable}\index{Atomizable@\verb`Atomizable`}

\begin{ocamldocsigend}


\label{type:ConstraintTypes.Atomizable.t}\begin{ocamldoccode}
type t 
\end{ocamldoccode}
\index{t@\verb`t`}


\label{type:ConstraintTypes.Atomizable.value}\begin{ocamldoccode}
type value 
\end{ocamldoccode}
\index{value@\verb`value`}


{\tt{include }}{\tt{Ring}}

\label{val:ConstraintTypes.Atomizable.sub}\begin{ocamldoccode}
val sub : t ->
  t -> t
\end{ocamldoccode}
\index{sub@\verb`sub`}


\label{val:ConstraintTypes.Atomizable.of-underscoreconstant}\begin{ocamldoccode}
val of_constant : value -> t
\end{ocamldoccode}
\index{of-underscoreconstant@\verb`of_constant`}


\label{val:ConstraintTypes.Atomizable.of-underscorevar}\begin{ocamldoccode}
val of_var : Var.t -> t
\end{ocamldoccode}
\index{of-underscorevar@\verb`of_var`}


\label{val:ConstraintTypes.Atomizable.vars}\begin{ocamldoccode}
val vars : t -> VarSet.t
\end{ocamldoccode}
\index{vars@\verb`vars`}


\label{val:ConstraintTypes.Atomizable.rename}\begin{ocamldoccode}
val rename : RenameMap.t -> t -> t
\end{ocamldoccode}
\index{rename@\verb`rename`}


\label{val:ConstraintTypes.Atomizable.is-underscorelinear}\begin{ocamldoccode}
val is_linear : t -> bool
\end{ocamldoccode}
\index{is-underscorelinear@\verb`is_linear`}


\label{val:ConstraintTypes.Atomizable.coeff-underscoreof-underscorevar}\begin{ocamldoccode}
val coeff_of_var : Var.t -> t -> value
\end{ocamldoccode}
\index{coeff-underscoreof-underscorevar@\verb`coeff_of_var`}


\label{val:ConstraintTypes.Atomizable.get-underscoreconstant}\begin{ocamldoccode}
val get_constant : t -> value
\end{ocamldoccode}
\index{get-underscoreconstant@\verb`get_constant`}


\label{val:ConstraintTypes.Atomizable.of-underscorecoeff-underscorelist}\begin{ocamldoccode}
val of_coeff_list : value list ->
  Var.t list -> t
\end{ocamldoccode}
\index{of-underscorecoeff-underscorelist@\verb`of_coeff_list`}
\end{ocamldocsigend}






\begin{ocamldoccode}
{\tt{module type }}{\tt{Atom}}{\tt{ = }}\end{ocamldoccode}
\label{moduletype:ConstraintTypes.Atom}\index{Atom@\verb`Atom`}

\begin{ocamldocsigend}


\begin{ocamldoccode}
{\tt{module }}{\tt{Comparator}}{\tt{ : }}\end{ocamldoccode}
\label{module:ConstraintTypes.Atom.Comparator}\index{Comparator@\verb`Comparator`}
\begin{ocamldocsigend}


\label{type:ConstraintTypes.Atom.Comparator.t}\begin{ocamldoccode}
type t =
  | GT
  | GE
  | LT
  | LE
\end{ocamldoccode}
\index{t@\verb`t`}
\begin{ocamldocdescription}
The different comparators.
              GT $\rightarrow$ a $>$ b.
              GE $\rightarrow$ a $\geq$ b.
              LT $\rightarrow$ a $<$ b.
              LE $\rightarrow$ a $\leq$ b.


\end{ocamldocdescription}


\label{val:ConstraintTypes.Atom.Comparator.values}\begin{ocamldoccode}
val values : t list
\end{ocamldoccode}
\index{values@\verb`values`}
\begin{ocamldocdescription}
Returns a list of all possible comparators


\end{ocamldocdescription}


\label{val:ConstraintTypes.Atom.Comparator.str-underscorevalues}\begin{ocamldoccode}
val str_values : string list
\end{ocamldoccode}
\index{str-underscorevalues@\verb`str_values`}
\begin{ocamldocdescription}
Returns a list of all possible comparators with their string representation


\end{ocamldocdescription}


\label{val:ConstraintTypes.Atom.Comparator.to-underscorestring}\begin{ocamldoccode}
val to_string : ?to_file:bool -> t -> string
\end{ocamldoccode}
\index{to-underscorestring@\verb`to_string`}
\end{ocamldocsigend}


\begin{ocamldocdescription}
A comparator sets two values in a binary relation


\end{ocamldocdescription}


\label{type:ConstraintTypes.Atom.polynomial}\begin{ocamldoccode}
type polynomial 
\end{ocamldoccode}
\index{polynomial@\verb`polynomial`}


\label{type:ConstraintTypes.Atom.value}\begin{ocamldoccode}
type value 
\end{ocamldoccode}
\index{value@\verb`value`}


\begin{ocamldoccode}
{\tt{module }}{\tt{P}}{\tt{ : }}\end{ocamldoccode}
\label{module:ConstraintTypes.Atom.P}\index{P@\verb`P`}
{\tt{ConstraintTypes.Atomizable}}{\tt{ }}{\tt{\
               with type t = polynomial\
                and type value = value}}



\label{type:ConstraintTypes.Atom.t}\begin{ocamldoccode}
type t 
\end{ocamldoccode}
\index{t@\verb`t`}


Following methods are convenience methods for the creation of atoms.

\label{val:ConstraintTypes.Atom.mk}\begin{ocamldoccode}
val mk : Comparator.t ->
  polynomial ->
  polynomial -> t
\end{ocamldoccode}
\index{mk@\verb`mk`}


\label{val:ConstraintTypes.Atom.mk-underscoregt}\begin{ocamldoccode}
val mk_gt : polynomial ->
  polynomial -> t
\end{ocamldoccode}
\index{mk-underscoregt@\verb`mk_gt`}


\label{val:ConstraintTypes.Atom.mk-underscorege}\begin{ocamldoccode}
val mk_ge : polynomial ->
  polynomial -> t
\end{ocamldoccode}
\index{mk-underscorege@\verb`mk_ge`}


\label{val:ConstraintTypes.Atom.mk-underscorelt}\begin{ocamldoccode}
val mk_lt : polynomial ->
  polynomial -> t
\end{ocamldoccode}
\index{mk-underscorelt@\verb`mk_lt`}


\label{val:ConstraintTypes.Atom.mk-underscorele}\begin{ocamldoccode}
val mk_le : polynomial ->
  polynomial -> t
\end{ocamldoccode}
\index{mk-underscorele@\verb`mk_le`}


\begin{ocamldoccode}
{\tt{module }}{\tt{Infix}}{\tt{ : }}\end{ocamldoccode}
\label{module:ConstraintTypes.Atom.Infix}\index{Infix@\verb`Infix`}
\begin{ocamldocsigend}


\label{val:ConstraintTypes.Atom.Infix.(-gt)}\begin{ocamldoccode}
val (>) :
  ConstraintTypes.Atom.polynomial ->
  ConstraintTypes.Atom.polynomial -> ConstraintTypes.Atom.t
\end{ocamldoccode}
\index{(-gt)@\verb`(>)`}


\label{val:ConstraintTypes.Atom.Infix.(-gt-equal)}\begin{ocamldoccode}
val (>=) :
  ConstraintTypes.Atom.polynomial ->
  ConstraintTypes.Atom.polynomial -> ConstraintTypes.Atom.t
\end{ocamldoccode}
\index{(-gt-equal)@\verb`(>=)`}


\label{val:ConstraintTypes.Atom.Infix.(-lt)}\begin{ocamldoccode}
val (<) :
  ConstraintTypes.Atom.polynomial ->
  ConstraintTypes.Atom.polynomial -> ConstraintTypes.Atom.t
\end{ocamldoccode}
\index{(-lt)@\verb`(<)`}


\label{val:ConstraintTypes.Atom.Infix.(-lt-equal)}\begin{ocamldoccode}
val (<=) :
  ConstraintTypes.Atom.polynomial ->
  ConstraintTypes.Atom.polynomial -> ConstraintTypes.Atom.t
\end{ocamldoccode}
\index{(-lt-equal)@\verb`(<=)`}
\end{ocamldocsigend}




Following methods return certain properties of the atom.

\label{val:ConstraintTypes.Atom.(-equal-tilde-equal)}\begin{ocamldoccode}
val (=~=) : t -> t -> bool
\end{ocamldoccode}
\index{(-equal-tilde-equal)@\verb`(=~=)`}


\label{val:ConstraintTypes.Atom.equal}\begin{ocamldoccode}
val equal : t -> t -> bool
\end{ocamldoccode}
\index{equal@\verb`equal`}
\begin{ocamldocdescription}
Stable structural equality, but not an actual equality


\end{ocamldocdescription}


\label{val:ConstraintTypes.Atom.compare}\begin{ocamldoccode}
val compare : t -> t -> int
\end{ocamldoccode}
\index{compare@\verb`compare`}
\begin{ocamldocdescription}
Stable structural compare, but not an actual compare


\end{ocamldocdescription}


\label{val:ConstraintTypes.Atom.neg}\begin{ocamldoccode}
val neg : t -> t
\end{ocamldoccode}
\index{neg@\verb`neg`}


\label{val:ConstraintTypes.Atom.to-underscorestring}\begin{ocamldoccode}
val to_string : ?to_file:bool -> ?comp:string -> t -> string
\end{ocamldoccode}
\index{to-underscorestring@\verb`to_string`}


\label{val:ConstraintTypes.Atom.vars}\begin{ocamldoccode}
val vars : t -> VarSet.t
\end{ocamldoccode}
\index{vars@\verb`vars`}
\begin{ocamldocdescription}
Returns the set of variables which are active in the atom.
            A variable is active, if it's value has an effect on the evaluation of the atom.


\end{ocamldocdescription}


\label{val:ConstraintTypes.Atom.normalised-underscorelhs}\begin{ocamldoccode}
val normalised_lhs : t -> polynomial
\end{ocamldoccode}
\index{normalised-underscorelhs@\verb`normalised_lhs`}
\begin{ocamldocdescription}
Returns a normalised form of the atom, where the returned polynomial represents the atom in the form p $\leq$ 0.


\end{ocamldocdescription}


Following methods manipulate atoms and return the manipulated versions.

\label{val:ConstraintTypes.Atom.rename}\begin{ocamldoccode}
val rename : t -> RenameMap.t -> t
\end{ocamldoccode}
\index{rename@\verb`rename`}
\begin{ocamldocdescription}
Assigns the variables of the atom new names based on the rename map.


\end{ocamldocdescription}


\label{val:ConstraintTypes.Atom.fold}\begin{ocamldoccode}
val fold : subject:(polynomial -> {\textquotesingle}b) ->
  le:({\textquotesingle}b -> {\textquotesingle}b -> {\textquotesingle}c) -> t -> {\textquotesingle}c
\end{ocamldoccode}
\index{fold@\verb`fold`}
\begin{ocamldocdescription}
Replaces all operations by new constructors.


\end{ocamldocdescription}


\label{val:ConstraintTypes.Atom.is-underscorelinear}\begin{ocamldoccode}
val is_linear : t -> bool
\end{ocamldoccode}
\index{is-underscorelinear@\verb`is_linear`}
\begin{ocamldocdescription}
Returns if both polynomials are linear.


\end{ocamldocdescription}


\label{val:ConstraintTypes.Atom.get-underscorecoefficient}\begin{ocamldoccode}
val get_coefficient : Var.t -> t -> value
\end{ocamldoccode}
\index{get-underscorecoefficient@\verb`get_coefficient`}
\begin{ocamldocdescription}
Returns the coefficient of a variable which is normalised to the lhs.


\end{ocamldocdescription}


\label{val:ConstraintTypes.Atom.get-underscoreconstant}\begin{ocamldoccode}
val get_constant : t -> value
\end{ocamldoccode}
\index{get-underscoreconstant@\verb`get_constant`}
\begin{ocamldocdescription}
Returns the single right hand side constant of the atom.


\end{ocamldocdescription}
\end{ocamldocsigend}


\begin{ocamldocdescription}
An atom is a comparison between two polynomials


\end{ocamldocdescription}




\begin{ocamldoccode}
{\tt{module type }}{\tt{Constraint}}{\tt{ = }}\end{ocamldoccode}
\label{moduletype:ConstraintTypes.Constraint}\index{Constraint@\verb`Constraint`}

\begin{ocamldocsigend}


\label{type:ConstraintTypes.Constraint.value}\begin{ocamldoccode}
type value 
\end{ocamldoccode}
\index{value@\verb`value`}


\label{type:ConstraintTypes.Constraint.polynomial}\begin{ocamldoccode}
type polynomial 
\end{ocamldoccode}
\index{polynomial@\verb`polynomial`}


\label{type:ConstraintTypes.Constraint.atom}\begin{ocamldoccode}
type atom 
\end{ocamldoccode}
\index{atom@\verb`atom`}


\label{type:ConstraintTypes.Constraint.t}\begin{ocamldoccode}
type t 
\end{ocamldoccode}
\index{t@\verb`t`}


\begin{ocamldoccode}
{\tt{module }}{\tt{A}}{\tt{ : }}\end{ocamldoccode}
\label{module:ConstraintTypes.Constraint.A}\index{A@\verb`A`}
{\tt{ConstraintTypes.Atom}}{\tt{ }}{\tt{\
               with type t = atom\
                and type polynomial = polynomial\
                and type value = value}}



Following methods are convenience methods for the creation of atoms.

\label{val:ConstraintTypes.Constraint.lift}\begin{ocamldoccode}
val lift : atom -> t
\end{ocamldoccode}
\index{lift@\verb`lift`}


\label{val:ConstraintTypes.Constraint.mk}\begin{ocamldoccode}
val mk : atom list -> t
\end{ocamldoccode}
\index{mk@\verb`mk`}


\label{val:ConstraintTypes.Constraint.mk-underscoretrue}\begin{ocamldoccode}
val mk_true : t
\end{ocamldoccode}
\index{mk-underscoretrue@\verb`mk_true`}


\label{val:ConstraintTypes.Constraint.mk-underscoreand}\begin{ocamldoccode}
val mk_and : t ->
  t -> t
\end{ocamldoccode}
\index{mk-underscoreand@\verb`mk_and`}


\label{val:ConstraintTypes.Constraint.map-underscorepolynomial}\begin{ocamldoccode}
val map_polynomial : (polynomial ->
   polynomial) ->
  t -> t
\end{ocamldoccode}
\index{map-underscorepolynomial@\verb`map_polynomial`}


\label{val:ConstraintTypes.Constraint.mk-underscoreeq}\begin{ocamldoccode}
val mk_eq : polynomial ->
  polynomial -> t
\end{ocamldoccode}
\index{mk-underscoreeq@\verb`mk_eq`}
\begin{ocamldocdescription}
Creates a constraint that expresses the equality of the two polynomials.


\end{ocamldocdescription}


\label{val:ConstraintTypes.Constraint.mk-underscoregt}\begin{ocamldoccode}
val mk_gt : polynomial ->
  polynomial -> t
\end{ocamldoccode}
\index{mk-underscoregt@\verb`mk_gt`}


\label{val:ConstraintTypes.Constraint.mk-underscorege}\begin{ocamldoccode}
val mk_ge : polynomial ->
  polynomial -> t
\end{ocamldoccode}
\index{mk-underscorege@\verb`mk_ge`}


\label{val:ConstraintTypes.Constraint.mk-underscorelt}\begin{ocamldoccode}
val mk_lt : polynomial ->
  polynomial -> t
\end{ocamldoccode}
\index{mk-underscorelt@\verb`mk_lt`}


\label{val:ConstraintTypes.Constraint.mk-underscorele}\begin{ocamldoccode}
val mk_le : polynomial ->
  polynomial -> t
\end{ocamldoccode}
\index{mk-underscorele@\verb`mk_le`}


\begin{ocamldoccode}
{\tt{module }}{\tt{Infix}}{\tt{ : }}\end{ocamldoccode}
\label{module:ConstraintTypes.Constraint.Infix}\index{Infix@\verb`Infix`}
\begin{ocamldocsigend}


\label{val:ConstraintTypes.Constraint.Infix.(-equal)}\begin{ocamldoccode}
val (=) :
  ConstraintTypes.Constraint.polynomial ->
  ConstraintTypes.Constraint.polynomial -> ConstraintTypes.Constraint.t
\end{ocamldoccode}
\index{(-equal)@\verb`(=)`}


\label{val:ConstraintTypes.Constraint.Infix.(-gt)}\begin{ocamldoccode}
val (>) :
  ConstraintTypes.Constraint.polynomial ->
  ConstraintTypes.Constraint.polynomial -> ConstraintTypes.Constraint.t
\end{ocamldoccode}
\index{(-gt)@\verb`(>)`}


\label{val:ConstraintTypes.Constraint.Infix.(-gt-equal)}\begin{ocamldoccode}
val (>=) :
  ConstraintTypes.Constraint.polynomial ->
  ConstraintTypes.Constraint.polynomial -> ConstraintTypes.Constraint.t
\end{ocamldoccode}
\index{(-gt-equal)@\verb`(>=)`}


\label{val:ConstraintTypes.Constraint.Infix.(-lt)}\begin{ocamldoccode}
val (<) :
  ConstraintTypes.Constraint.polynomial ->
  ConstraintTypes.Constraint.polynomial -> ConstraintTypes.Constraint.t
\end{ocamldoccode}
\index{(-lt)@\verb`(<)`}


\label{val:ConstraintTypes.Constraint.Infix.(-lt-equal)}\begin{ocamldoccode}
val (<=) :
  ConstraintTypes.Constraint.polynomial ->
  ConstraintTypes.Constraint.polynomial -> ConstraintTypes.Constraint.t
\end{ocamldoccode}
\index{(-lt-equal)@\verb`(<=)`}


\label{val:ConstraintTypes.Constraint.Infix.(-ampersand-ampersand)}\begin{ocamldoccode}
val (&&) :
  ConstraintTypes.Constraint.t ->
  ConstraintTypes.Constraint.t -> ConstraintTypes.Constraint.t
\end{ocamldoccode}
\index{(-ampersand-ampersand)@\verb`(&&)`}
\end{ocamldocsigend}




\label{val:ConstraintTypes.Constraint.all}\begin{ocamldoccode}
val all : t list -> t
\end{ocamldoccode}
\index{all@\verb`all`}


\label{val:ConstraintTypes.Constraint.turn}\begin{ocamldoccode}
val turn : t -> t
\end{ocamldoccode}
\index{turn@\verb`turn`}


Following methods return certain properties of the constraint.

\label{val:ConstraintTypes.Constraint.is-underscoretrue}\begin{ocamldoccode}
val is_true : t -> bool
\end{ocamldoccode}
\index{is-underscoretrue@\verb`is_true`}
\begin{ocamldocdescription}
Returns if the constraint is a tautology


\end{ocamldocdescription}


\label{val:ConstraintTypes.Constraint.(-equal-tilde-equal)}\begin{ocamldoccode}
val (=~=) : t -> t -> bool
\end{ocamldoccode}
\index{(-equal-tilde-equal)@\verb`(=~=)`}


\label{val:ConstraintTypes.Constraint.equal}\begin{ocamldoccode}
val equal : t -> t -> bool
\end{ocamldoccode}
\index{equal@\verb`equal`}
\begin{ocamldocdescription}
Stable structural equality, but not an actual equality


\end{ocamldocdescription}


\label{val:ConstraintTypes.Constraint.compare}\begin{ocamldoccode}
val compare : t -> t -> int
\end{ocamldoccode}
\index{compare@\verb`compare`}
\begin{ocamldocdescription}
Stable structural compare, but not an actual compare


\end{ocamldocdescription}


\label{val:ConstraintTypes.Constraint.vars}\begin{ocamldoccode}
val vars : t -> VarSet.t
\end{ocamldoccode}
\index{vars@\verb`vars`}
\begin{ocamldocdescription}
Returns the set of variables which are active in the constraint.
            A variable is active, if it's value has an effect on the evaluation of the constraint.


\end{ocamldocdescription}


\label{val:ConstraintTypes.Constraint.to-underscorestring}\begin{ocamldoccode}
val to_string :
  ?to_file:bool ->
  ?comp:string -> ?conj:string -> t -> string
\end{ocamldoccode}
\index{to-underscorestring@\verb`to_string`}


Following methods manipulate atoms and return the manipulated versions.

\label{val:ConstraintTypes.Constraint.rename}\begin{ocamldoccode}
val rename : t -> RenameMap.t -> t
\end{ocamldoccode}
\index{rename@\verb`rename`}
\begin{ocamldocdescription}
Assigns the variables of the constraint new names based on the rename map


\end{ocamldocdescription}


\label{val:ConstraintTypes.Constraint.atom-underscorelist}\begin{ocamldoccode}
val atom_list : t -> atom list
\end{ocamldoccode}
\index{atom-underscorelist@\verb`atom_list`}


\label{val:ConstraintTypes.Constraint.fold}\begin{ocamldoccode}
val fold :
  subject:(polynomial -> {\textquotesingle}b) ->
  le:({\textquotesingle}b -> {\textquotesingle}b -> {\textquotesingle}c) ->
  correct:{\textquotesingle}d -> conj:({\textquotesingle}d -> {\textquotesingle}c -> {\textquotesingle}d) -> t -> {\textquotesingle}d
\end{ocamldoccode}
\index{fold@\verb`fold`}
\begin{ocamldocdescription}
Replaces all operations by new constructors.


\end{ocamldocdescription}


\label{val:ConstraintTypes.Constraint.drop-underscorenonlinear}\begin{ocamldoccode}
val drop_nonlinear : t -> t
\end{ocamldoccode}
\index{drop-underscorenonlinear@\verb`drop_nonlinear`}
\begin{ocamldocdescription}
Drops all nonlinear atoms from the constraints. 
          Example: (a $>$ 0 \&\& b{\textasciicircum}2 $<$ 2) gets transformed to (a $>$ 0)


\end{ocamldocdescription}


\label{val:ConstraintTypes.Constraint.get-underscorecoefficient-underscorevector}\begin{ocamldoccode}
val get_coefficient_vector : Var.t ->
  t -> value list
\end{ocamldoccode}
\index{get-underscorecoefficient-underscorevector@\verb`get_coefficient_vector`}
\begin{ocamldocdescription}
Returns the row of all coefficients of a variable in a constraint$\ldots$used for farkas quantor elimination


\end{ocamldocdescription}


\label{val:ConstraintTypes.Constraint.get-underscorematrix}\begin{ocamldoccode}
val get_matrix : VarSet.t ->
  t -> value list list
\end{ocamldoccode}
\index{get-underscorematrix@\verb`get_matrix`}


\label{val:ConstraintTypes.Constraint.get-underscoreconstant-underscorevector}\begin{ocamldoccode}
val get_constant_vector : t -> value list
\end{ocamldoccode}
\index{get-underscoreconstant-underscorevector@\verb`get_constant_vector`}
\begin{ocamldocdescription}
Returns the row of all coefficients of a variable in a constraint$\ldots$used for farkas quantor elimination


\end{ocamldocdescription}


\label{val:ConstraintTypes.Constraint.dualise}\begin{ocamldoccode}
val dualise : Var.t list ->
  value list list ->
  polynomial list -> t
\end{ocamldoccode}
\index{dualise@\verb`dualise`}
\end{ocamldocsigend}


\begin{ocamldocdescription}
A constraint is a conjunction of atoms


\end{ocamldocdescription}




\begin{ocamldoccode}
{\tt{module type }}{\tt{Formula}}{\tt{ = }}\end{ocamldoccode}
\label{moduletype:ConstraintTypes.Formula}\index{Formula@\verb`Formula`}

\begin{ocamldocsigend}


\label{type:ConstraintTypes.Formula.atom}\begin{ocamldoccode}
type atom 
\end{ocamldoccode}
\index{atom@\verb`atom`}


\label{type:ConstraintTypes.Formula.constr}\begin{ocamldoccode}
type constr 
\end{ocamldoccode}
\index{constr@\verb`constr`}


\label{type:ConstraintTypes.Formula.polynomial}\begin{ocamldoccode}
type polynomial 
\end{ocamldoccode}
\index{polynomial@\verb`polynomial`}


\label{type:ConstraintTypes.Formula.value}\begin{ocamldoccode}
type value 
\end{ocamldoccode}
\index{value@\verb`value`}


\label{type:ConstraintTypes.Formula.t}\begin{ocamldoccode}
type t 
\end{ocamldoccode}
\index{t@\verb`t`}


Following methods are convenience methods for the creation of atoms.

\label{val:ConstraintTypes.Formula.lift}\begin{ocamldoccode}
val lift : atom -> t
\end{ocamldoccode}
\index{lift@\verb`lift`}


\label{val:ConstraintTypes.Formula.mk}\begin{ocamldoccode}
val mk : constr -> t
\end{ocamldoccode}
\index{mk@\verb`mk`}


\label{val:ConstraintTypes.Formula.mk-underscoretrue}\begin{ocamldoccode}
val mk_true : t
\end{ocamldoccode}
\index{mk-underscoretrue@\verb`mk_true`}


\label{val:ConstraintTypes.Formula.mk-underscoreand}\begin{ocamldoccode}
val mk_and : t ->
  t -> t
\end{ocamldoccode}
\index{mk-underscoreand@\verb`mk_and`}


\label{val:ConstraintTypes.Formula.mk-underscoreor}\begin{ocamldoccode}
val mk_or : t ->
  t -> t
\end{ocamldoccode}
\index{mk-underscoreor@\verb`mk_or`}


\label{val:ConstraintTypes.Formula.neg}\begin{ocamldoccode}
val neg : t -> t
\end{ocamldoccode}
\index{neg@\verb`neg`}


\label{val:ConstraintTypes.Formula.implies}\begin{ocamldoccode}
val implies : t ->
  t -> t
\end{ocamldoccode}
\index{implies@\verb`implies`}


\label{val:ConstraintTypes.Formula.constraints}\begin{ocamldoccode}
val constraints : t -> constr list
\end{ocamldoccode}
\index{constraints@\verb`constraints`}


\label{val:ConstraintTypes.Formula.map-underscorepolynomial}\begin{ocamldoccode}
val map_polynomial : (polynomial -> polynomial) ->
  t -> t
\end{ocamldoccode}
\index{map-underscorepolynomial@\verb`map_polynomial`}


\label{val:ConstraintTypes.Formula.mk-underscoreeq}\begin{ocamldoccode}
val mk_eq : polynomial ->
  polynomial -> t
\end{ocamldoccode}
\index{mk-underscoreeq@\verb`mk_eq`}
\begin{ocamldocdescription}
Creates a constraint that expresses the equality of the two polynomials.


\end{ocamldocdescription}


\label{val:ConstraintTypes.Formula.mk-underscoregt}\begin{ocamldoccode}
val mk_gt : polynomial ->
  polynomial -> t
\end{ocamldoccode}
\index{mk-underscoregt@\verb`mk_gt`}


\label{val:ConstraintTypes.Formula.mk-underscorege}\begin{ocamldoccode}
val mk_ge : polynomial ->
  polynomial -> t
\end{ocamldoccode}
\index{mk-underscorege@\verb`mk_ge`}


\label{val:ConstraintTypes.Formula.mk-underscorelt}\begin{ocamldoccode}
val mk_lt : polynomial ->
  polynomial -> t
\end{ocamldoccode}
\index{mk-underscorelt@\verb`mk_lt`}


\label{val:ConstraintTypes.Formula.mk-underscorele}\begin{ocamldoccode}
val mk_le : polynomial ->
  polynomial -> t
\end{ocamldoccode}
\index{mk-underscorele@\verb`mk_le`}


\label{val:ConstraintTypes.Formula.mk-underscoreuneq}\begin{ocamldoccode}
val mk_uneq : polynomial ->
  polynomial -> t
\end{ocamldoccode}
\index{mk-underscoreuneq@\verb`mk_uneq`}


\label{val:ConstraintTypes.Formula.le-underscorethan-underscoreany}\begin{ocamldoccode}
val le_than_any : polynomial ->
  polynomial list -> t
\end{ocamldoccode}
\index{le-underscorethan-underscoreany@\verb`le_than_any`}


\label{val:ConstraintTypes.Formula.le-underscorethan-underscoreall}\begin{ocamldoccode}
val le_than_all : polynomial ->
  polynomial list -> t
\end{ocamldoccode}
\index{le-underscorethan-underscoreall@\verb`le_than_all`}


\label{val:ConstraintTypes.Formula.all}\begin{ocamldoccode}
val all : t list -> t
\end{ocamldoccode}
\index{all@\verb`all`}


\label{val:ConstraintTypes.Formula.any}\begin{ocamldoccode}
val any : t list -> t
\end{ocamldoccode}
\index{any@\verb`any`}


\label{val:ConstraintTypes.Formula.turn}\begin{ocamldoccode}
val turn : t -> t
\end{ocamldoccode}
\index{turn@\verb`turn`}


\begin{ocamldoccode}
{\tt{module }}{\tt{Infix}}{\tt{ : }}\end{ocamldoccode}
\label{module:ConstraintTypes.Formula.Infix}\index{Infix@\verb`Infix`}
\begin{ocamldocsigend}


\label{val:ConstraintTypes.Formula.Infix.(-equal)}\begin{ocamldoccode}
val (=) :
  ConstraintTypes.Formula.polynomial ->
  ConstraintTypes.Formula.polynomial -> ConstraintTypes.Formula.t
\end{ocamldoccode}
\index{(-equal)@\verb`(=)`}


\label{val:ConstraintTypes.Formula.Infix.(-gt)}\begin{ocamldoccode}
val (>) :
  ConstraintTypes.Formula.polynomial ->
  ConstraintTypes.Formula.polynomial -> ConstraintTypes.Formula.t
\end{ocamldoccode}
\index{(-gt)@\verb`(>)`}


\label{val:ConstraintTypes.Formula.Infix.(-gt-equal)}\begin{ocamldoccode}
val (>=) :
  ConstraintTypes.Formula.polynomial ->
  ConstraintTypes.Formula.polynomial -> ConstraintTypes.Formula.t
\end{ocamldoccode}
\index{(-gt-equal)@\verb`(>=)`}


\label{val:ConstraintTypes.Formula.Infix.(-lt)}\begin{ocamldoccode}
val (<) :
  ConstraintTypes.Formula.polynomial ->
  ConstraintTypes.Formula.polynomial -> ConstraintTypes.Formula.t
\end{ocamldoccode}
\index{(-lt)@\verb`(<)`}


\label{val:ConstraintTypes.Formula.Infix.(-lt-equal)}\begin{ocamldoccode}
val (<=) :
  ConstraintTypes.Formula.polynomial ->
  ConstraintTypes.Formula.polynomial -> ConstraintTypes.Formula.t
\end{ocamldoccode}
\index{(-lt-equal)@\verb`(<=)`}


\label{val:ConstraintTypes.Formula.Infix.(-ampersand-ampersand)}\begin{ocamldoccode}
val (&&) :
  ConstraintTypes.Formula.t ->
  ConstraintTypes.Formula.t -> ConstraintTypes.Formula.t
\end{ocamldoccode}
\index{(-ampersand-ampersand)@\verb`(&&)`}


\label{val:ConstraintTypes.Formula.Infix.(-pipe-pipe)}\begin{ocamldoccode}
val (||) :
  ConstraintTypes.Formula.t ->
  ConstraintTypes.Formula.t -> ConstraintTypes.Formula.t
\end{ocamldoccode}
\index{(-pipe-pipe)@\verb`("|"|)`}


\label{val:ConstraintTypes.Formula.Infix.(-equal-gt)}\begin{ocamldoccode}
val (=>) :
  ConstraintTypes.Formula.t ->
  ConstraintTypes.Formula.t -> ConstraintTypes.Formula.t
\end{ocamldoccode}
\index{(-equal-gt)@\verb`(=>)`}


\label{val:ConstraintTypes.Formula.Infix.(-lt-equal-gt)}\begin{ocamldoccode}
val (<=>) :
  ConstraintTypes.Formula.t ->
  ConstraintTypes.Formula.t -> ConstraintTypes.Formula.t
\end{ocamldoccode}
\index{(-lt-equal-gt)@\verb`(<=>)`}
\end{ocamldocsigend}




Following methods return certain properties of the formula.

\label{val:ConstraintTypes.Formula.vars}\begin{ocamldoccode}
val vars : t -> VarSet.t
\end{ocamldoccode}
\index{vars@\verb`vars`}
\begin{ocamldocdescription}
Returns the set of variables which are active in the formula.
            A variable is active, if it's value has an effect on the evaluation of the constraint.


\end{ocamldocdescription}


\label{val:ConstraintTypes.Formula.to-underscorestring}\begin{ocamldoccode}
val to_string : t -> string
\end{ocamldoccode}
\index{to-underscorestring@\verb`to_string`}


Following methods manipulate atoms and return the manipulated versions.

\label{val:ConstraintTypes.Formula.rename}\begin{ocamldoccode}
val rename : t -> RenameMap.t -> t
\end{ocamldoccode}
\index{rename@\verb`rename`}
\begin{ocamldocdescription}
Assigns the variables of the constraint new names based on the rename map


\end{ocamldocdescription}


\label{val:ConstraintTypes.Formula.fold}\begin{ocamldoccode}
val fold :
  subject:(polynomial -> {\textquotesingle}b) ->
  le:({\textquotesingle}b -> {\textquotesingle}b -> {\textquotesingle}c) ->
  correct:{\textquotesingle}d ->
  conj:({\textquotesingle}d -> {\textquotesingle}c -> {\textquotesingle}d) ->
  wrong:{\textquotesingle}e -> disj:({\textquotesingle}e -> {\textquotesingle}d -> {\textquotesingle}e) -> t -> {\textquotesingle}e
\end{ocamldoccode}
\index{fold@\verb`fold`}
\begin{ocamldocdescription}
Replaces all operations by new constructors.


\end{ocamldocdescription}
\end{ocamldocsigend}


\begin{ocamldocdescription}
A formula is a propositional formula


\end{ocamldocdescription}


\section{Module {\tt{SMT}}}
\label{module:SMT}\index{SMT@\verb`SMT`}


\ocamldocvspace{0.5cm}



Provides different implementations of SMT solvers



\begin{ocamldoccode}
{\tt{module }}{\tt{Z3Solver}}{\tt{ : }}\end{ocamldoccode}
\label{module:SMT.Z3Solver}\index{Z3Solver@\verb`Z3Solver`}

\begin{ocamldocsigend}


\label{val:SMT.Z3Solver.satisfiable}\begin{ocamldoccode}
val satisfiable : Formulas.Formula.t -> bool
\end{ocamldoccode}
\index{satisfiable@\verb`satisfiable`}


\label{val:SMT.Z3Solver.unsatisfiable}\begin{ocamldoccode}
val unsatisfiable : Formulas.Formula.t -> bool
\end{ocamldoccode}
\index{unsatisfiable@\verb`unsatisfiable`}


\label{val:SMT.Z3Solver.tautology}\begin{ocamldoccode}
val tautology : Formulas.Formula.t -> bool
\end{ocamldoccode}
\index{tautology@\verb`tautology`}


\label{val:SMT.Z3Solver.equivalent}\begin{ocamldoccode}
val equivalent : Formulas.Formula.t -> Formulas.Formula.t -> bool
\end{ocamldoccode}
\index{equivalent@\verb`equivalent`}


\label{val:SMT.Z3Solver.get-underscoremodel}\begin{ocamldoccode}
val get_model :
  ?coeffs_to_minimise:Var.t list ->
  Formulas.Formula.t -> Polynomials.Polynomial.valuation Batteries.Option.t
\end{ocamldoccode}
\index{get-underscoremodel@\verb`get_model`}


\label{val:SMT.Z3Solver.check-underscorepositivity}\begin{ocamldoccode}
val check_positivity : Formulas.Formula.t -> Polynomials.Polynomial.t -> bool
\end{ocamldoccode}
\index{check-underscorepositivity@\verb`check_positivity`}


\label{val:SMT.Z3Solver.check-underscorenegativity}\begin{ocamldoccode}
val check_negativity : Formulas.Formula.t -> Polynomials.Polynomial.t -> bool
\end{ocamldoccode}
\index{check-underscorenegativity@\verb`check_negativity`}
\end{ocamldocsigend}


\begin{ocamldocdescription}
A unified interface for SMT solvers (currently supported: Z3)


\end{ocamldocdescription}




\begin{ocamldoccode}
{\tt{module }}{\tt{IncrementalZ3Solver}}{\tt{ : }}\end{ocamldoccode}
\label{module:SMT.IncrementalZ3Solver}\index{IncrementalZ3Solver@\verb`IncrementalZ3Solver`}

\begin{ocamldocsigend}


\label{type:SMT.IncrementalZ3Solver.t}\begin{ocamldoccode}
type t 
\end{ocamldoccode}
\index{t@\verb`t`}


\label{val:SMT.IncrementalZ3Solver.create}\begin{ocamldoccode}
val create : ?model:bool -> unit -> t
\end{ocamldoccode}
\index{create@\verb`create`}
\begin{ocamldocdescription}
Creates a new incremental smt solver.


\end{ocamldocdescription}


\label{val:SMT.IncrementalZ3Solver.push}\begin{ocamldoccode}
val push : t -> unit
\end{ocamldoccode}
\index{push@\verb`push`}
\begin{ocamldocdescription}
Creates a backtracking point.


\end{ocamldocdescription}


\label{val:SMT.IncrementalZ3Solver.pop}\begin{ocamldoccode}
val pop : t -> unit
\end{ocamldoccode}
\index{pop@\verb`pop`}
\begin{ocamldocdescription}
Backtrack one backtracking point. Note that an exception is thrown if Pop is called without a corresponding push.


\end{ocamldocdescription}


\label{val:SMT.IncrementalZ3Solver.satisfiable}\begin{ocamldoccode}
val satisfiable : t -> bool
\end{ocamldoccode}
\index{satisfiable@\verb`satisfiable`}
\begin{ocamldocdescription}
Checks if the current state is satisfiable.


\end{ocamldocdescription}


\label{val:SMT.IncrementalZ3Solver.unsatisfiable}\begin{ocamldoccode}
val unsatisfiable : t -> bool
\end{ocamldoccode}
\index{unsatisfiable@\verb`unsatisfiable`}
\begin{ocamldocdescription}
Checks if the current state is satisfiable.


\end{ocamldocdescription}


\label{val:SMT.IncrementalZ3Solver.add}\begin{ocamldoccode}
val add : t -> Formulas.Formula.t -> unit
\end{ocamldoccode}
\index{add@\verb`add`}
\begin{ocamldocdescription}
Asserts the formula.


\end{ocamldocdescription}


\label{val:SMT.IncrementalZ3Solver.minimize}\begin{ocamldoccode}
val minimize : t -> Var.t -> unit
\end{ocamldoccode}
\index{minimize@\verb`minimize`}
\begin{ocamldocdescription}
Minimizes the variable.


\end{ocamldocdescription}


\label{val:SMT.IncrementalZ3Solver.maximize}\begin{ocamldoccode}
val maximize : t -> Var.t -> unit
\end{ocamldoccode}
\index{maximize@\verb`maximize`}
\begin{ocamldocdescription}
Maximizes the variable.


\end{ocamldocdescription}


\label{val:SMT.IncrementalZ3Solver.minimize-underscoreabsolute}\begin{ocamldoccode}
val minimize_absolute : t -> Var.t list -> unit
\end{ocamldoccode}
\index{minimize-underscoreabsolute@\verb`minimize_absolute`}
\begin{ocamldocdescription}
Sets the variables, which absolute value should be minimized.


\end{ocamldocdescription}


\label{val:SMT.IncrementalZ3Solver.model}\begin{ocamldoccode}
val model : t ->
  Polynomials.Polynomial.valuation Batteries.Option.t
\end{ocamldoccode}
\index{model@\verb`model`}
\begin{ocamldocdescription}
Returns a model of the current state, if the state is satisfiable.


\end{ocamldocdescription}
\end{ocamldocsigend}




\section{Module {\tt{Program}}}
\label{module:Program}\index{Program@\verb`Program`}


\ocamldocvspace{0.5cm}



Provides default modules to create locations, transitions and transitionsystems



\label{type:Program.t}\begin{ocamldoccode}
type t 
\end{ocamldoccode}
\index{t@\verb`t`}




\label{val:Program.add-underscorelocations}\begin{ocamldoccode}
val add_locations :
  ProgramTypes.Location.t Batteries.Enum.t ->
  ProgramTypes.TransitionGraph.t -> ProgramTypes.TransitionGraph.t
\end{ocamldoccode}
\index{add-underscorelocations@\verb`add_locations`}




\label{val:Program.add-underscoretransitions}\begin{ocamldoccode}
val add_transitions :
  ProgramTypes.Transition.t Batteries.Enum.t ->
  ProgramTypes.TransitionGraph.t -> ProgramTypes.TransitionGraph.t
\end{ocamldoccode}
\index{add-underscoretransitions@\verb`add_transitions`}




\label{val:Program.remove-underscorelocation}\begin{ocamldoccode}
val remove_location : t -> ProgramTypes.Location.t -> t
\end{ocamldoccode}
\index{remove-underscorelocation@\verb`remove_location`}
\begin{ocamldocdescription}
Removes the location from the program and all edges to it.


\end{ocamldocdescription}




\label{val:Program.remove-underscoretransition}\begin{ocamldoccode}
val remove_transition : t -> ProgramTypes.Transition.t -> t
\end{ocamldoccode}
\index{remove-underscoretransition@\verb`remove_transition`}




\label{val:Program.map-underscoregraph}\begin{ocamldoccode}
val map_graph :
  (ProgramTypes.TransitionGraph.t -> ProgramTypes.TransitionGraph.t) ->
  t -> t
\end{ocamldoccode}
\index{map-underscoregraph@\verb`map_graph`}




\label{val:Program.mk}\begin{ocamldoccode}
val mk :
  ProgramTypes.Transition.t Batteries.Enum.t -> ProgramTypes.TransitionGraph.t
\end{ocamldoccode}
\index{mk@\verb`mk`}




\label{val:Program.rename}\begin{ocamldoccode}
val rename : t -> t
\end{ocamldoccode}
\index{rename@\verb`rename`}




\label{val:Program.from}\begin{ocamldoccode}
val from : ProgramTypes.Transition.t list -> ProgramTypes.Location.t -> t
\end{ocamldoccode}
\index{from@\verb`from`}




\label{val:Program.graph}\begin{ocamldoccode}
val graph : t -> ProgramTypes.TransitionGraph.t
\end{ocamldoccode}
\index{graph@\verb`graph`}




\label{val:Program.add-underscoreinvariant}\begin{ocamldoccode}
val add_invariant :
  ProgramTypes.Location.t -> Constraints.Constraint.t -> t -> t
\end{ocamldoccode}
\index{add-underscoreinvariant@\verb`add_invariant`}
\begin{ocamldocdescription}
Adds the invariant to the location of the program.


\end{ocamldocdescription}




\label{val:Program.pre}\begin{ocamldoccode}
val pre :
  t ->
  ProgramTypes.Transition.t -> ProgramTypes.Transition.t Batteries.Enum.t
\end{ocamldoccode}
\index{pre@\verb`pre`}
\begin{ocamldocdescription}
Returns a set of all transitions which occur directly before the given transition in the graph. 
       Corresponds to pre(t).


\end{ocamldocdescription}




\label{val:Program.is-underscoreinitial}\begin{ocamldoccode}
val is_initial : t -> ProgramTypes.Transition.t -> bool
\end{ocamldoccode}
\index{is-underscoreinitial@\verb`is_initial`}
\begin{ocamldocdescription}
Returns if the given transition is an initial transition.


\end{ocamldocdescription}




\label{val:Program.is-underscoreinitial-underscorelocation}\begin{ocamldoccode}
val is_initial_location : t -> ProgramTypes.Location.t -> bool
\end{ocamldoccode}
\index{is-underscoreinitial-underscorelocation@\verb`is_initial_location`}
\begin{ocamldocdescription}
Returns if the given transition is an initial transition.


\end{ocamldocdescription}




\label{val:Program.equivalent}\begin{ocamldoccode}
val equivalent : t -> t -> bool
\end{ocamldoccode}
\index{equivalent@\verb`equivalent`}




\label{val:Program.to-underscorestring}\begin{ocamldoccode}
val to_string : t -> string
\end{ocamldoccode}
\index{to-underscorestring@\verb`to_string`}




\label{val:Program.to-underscoresimple-underscorestring}\begin{ocamldoccode}
val to_simple_string : t -> string
\end{ocamldoccode}
\index{to-underscoresimple-underscorestring@\verb`to_simple_string`}




\label{val:Program.vars}\begin{ocamldoccode}
val vars : t -> VarSet.t
\end{ocamldoccode}
\index{vars@\verb`vars`}




\label{val:Program.input-underscorevars}\begin{ocamldoccode}
val input_vars : t -> VarSet.t
\end{ocamldoccode}
\index{input-underscorevars@\verb`input_vars`}




\label{val:Program.transitions}\begin{ocamldoccode}
val transitions : t -> ProgramTypes.TransitionSet.t
\end{ocamldoccode}
\index{transitions@\verb`transitions`}




\label{val:Program.locations}\begin{ocamldoccode}
val locations :
  ProgramTypes.Transition.t Batteries.Enum.t ->
  ProgramTypes.Location.t Batteries.Enum.t
\end{ocamldoccode}
\index{locations@\verb`locations`}
\begin{ocamldocdescription}
Returns all locations which occur in the transitions, but each location only once.


\end{ocamldocdescription}




\label{val:Program.start}\begin{ocamldoccode}
val start : t -> ProgramTypes.Location.t
\end{ocamldoccode}
\index{start@\verb`start`}




\label{val:Program.sccs}\begin{ocamldoccode}
val sccs : t -> ProgramTypes.TransitionSet.t Batteries.Enum.t
\end{ocamldoccode}
\index{sccs@\verb`sccs`}




\label{val:Program.parallelTransitions}\begin{ocamldoccode}
val parallelTransitions :
  t ->
  ProgramTypes.Location.t * TransitionLabel.t * ProgramTypes.Location.t ->
  ProgramTypes.TransitionSet.t
\end{ocamldoccode}
\index{parallelTransitions@\verb`parallelTransitions`}




\label{val:Program.non-underscoretrivial-underscoretransitions}\begin{ocamldoccode}
val non_trivial_transitions : t -> ProgramTypes.TransitionSet.t
\end{ocamldoccode}
\index{non-underscoretrivial-underscoretransitions@\verb`non_trivial_transitions`}
\begin{ocamldocdescription}
Returns all transitions, that belong to an SCC.


\end{ocamldocdescription}




\label{val:Program.to-underscorefile}\begin{ocamldoccode}
val to_file : t -> string -> unit
\end{ocamldoccode}
\index{to-underscorefile@\verb`to_file`}


\section{Module {\tt{RVGTypes}}}
\label{module:RVGTypes}\index{RVGTypes@\verb`RVGTypes`}


\ocamldocvspace{0.5cm}



\begin{ocamldoccode}
{\tt{module }}{\tt{RV}}{\tt{ : }}\end{ocamldoccode}
\label{module:RVGTypes.RV}\index{RV@\verb`RV`}

\begin{ocamldocsigend}


\label{type:RVGTypes.RV.t}\begin{ocamldoccode}
type t = ProgramTypes.Transition.t * Var.t 
\end{ocamldoccode}
\index{t@\verb`t`}


\label{val:RVGTypes.RV.same}\begin{ocamldoccode}
val same : t -> t -> bool
\end{ocamldoccode}
\index{same@\verb`same`}


\label{val:RVGTypes.RV.equivalent}\begin{ocamldoccode}
val equivalent : t -> t -> bool
\end{ocamldoccode}
\index{equivalent@\verb`equivalent`}


\label{val:RVGTypes.RV.compare-underscoresame}\begin{ocamldoccode}
val compare_same : t -> t -> int
\end{ocamldoccode}
\index{compare-underscoresame@\verb`compare_same`}


\label{val:RVGTypes.RV.compare-underscoreequivalent}\begin{ocamldoccode}
val compare_equivalent : t -> t -> int
\end{ocamldoccode}
\index{compare-underscoreequivalent@\verb`compare_equivalent`}


\label{val:RVGTypes.RV.to-underscoreid-underscorestring}\begin{ocamldoccode}
val to_id_string : t -> string
\end{ocamldoccode}
\index{to-underscoreid-underscorestring@\verb`to_id_string`}


\label{val:RVGTypes.RV.hash}\begin{ocamldoccode}
val hash : t -> int
\end{ocamldoccode}
\index{hash@\verb`hash`}


\label{val:RVGTypes.RV.transition}\begin{ocamldoccode}
val transition : t -> ProgramTypes.Transition.t
\end{ocamldoccode}
\index{transition@\verb`transition`}


\label{val:RVGTypes.RV.variable}\begin{ocamldoccode}
val variable : t -> Var.t
\end{ocamldoccode}
\index{variable@\verb`variable`}
\end{ocamldocsigend}






\begin{ocamldoccode}
{\tt{module }}{\tt{RVG}}{\tt{ : }}\end{ocamldoccode}
\label{module:RVGTypes.RVG}\index{RVG@\verb`RVG`}

\begin{ocamldocsigend}


{\tt{include }}{\tt{??}}

\label{val:RVGTypes.RVG.rvs-underscoreto-underscoreid-underscorestring}\begin{ocamldoccode}
val rvs_to_id_string : RVGTypes.RV.t list -> string
\end{ocamldoccode}
\index{rvs-underscoreto-underscoreid-underscorestring@\verb`rvs_to_id_string`}


\label{val:RVGTypes.RVG.pre}\begin{ocamldoccode}
val pre : t -> RVGTypes.RV.t -> RVGTypes.RV.t Batteries.Enum.t
\end{ocamldoccode}
\index{pre@\verb`pre`}


\label{val:RVGTypes.RVG.entry-underscorepoints}\begin{ocamldoccode}
val entry_points : t -> RVGTypes.RV.t list -> RVGTypes.RV.t Batteries.Enum.t
\end{ocamldoccode}
\index{entry-underscorepoints@\verb`entry_points`}
\begin{ocamldocdescription}
Returns all the entry points of the SCC.
      Those are all result variables that are in the RVG, but not in the SCC and lead to any result variable in the RVG.


\end{ocamldocdescription}


\label{val:RVGTypes.RVG.transitions}\begin{ocamldoccode}
val transitions :
  RVGTypes.RV.t list -> ProgramTypes.Transition.t Batteries.Enum.t
\end{ocamldoccode}
\index{transitions@\verb`transitions`}
\begin{ocamldocdescription}
Returns all transitions that are used in the SCC of the RVG.


\end{ocamldocdescription}


\label{val:RVGTypes.RVG.rvg}\begin{ocamldoccode}
val rvg : [ {\textasciigrave}Lower | {\textasciigrave}Upper ] -> Program.t -> t
\end{ocamldoccode}
\index{rvg@\verb`rvg`}
\end{ocamldocsigend}




\section{Module {\tt{ProgramTypes}}}
\label{module:ProgramTypes}\index{ProgramTypes@\verb`ProgramTypes`}


\ocamldocvspace{0.5cm}



\begin{ocamldoccode}
{\tt{module }}{\tt{Location}}{\tt{ : }}\end{ocamldoccode}
\label{module:ProgramTypes.Location}\index{Location@\verb`Location`}

\begin{ocamldocsigend}


\label{type:ProgramTypes.Location.t}\begin{ocamldoccode}
type t 
\end{ocamldoccode}
\index{t@\verb`t`}


\label{val:ProgramTypes.Location.equal}\begin{ocamldoccode}
val equal : t -> t -> bool
\end{ocamldoccode}
\index{equal@\verb`equal`}


\label{val:ProgramTypes.Location.compare}\begin{ocamldoccode}
val compare : t -> t -> int
\end{ocamldoccode}
\index{compare@\verb`compare`}


\label{val:ProgramTypes.Location.hash}\begin{ocamldoccode}
val hash : t -> int
\end{ocamldoccode}
\index{hash@\verb`hash`}


\label{val:ProgramTypes.Location.to-underscorestring}\begin{ocamldoccode}
val to_string : t -> string
\end{ocamldoccode}
\index{to-underscorestring@\verb`to_string`}


\label{val:ProgramTypes.Location.of-underscorestring}\begin{ocamldoccode}
val of_string : string -> t
\end{ocamldoccode}
\index{of-underscorestring@\verb`of_string`}
\end{ocamldocsigend}


\begin{ocamldocdescription}
A location is a node of a transition system and can be connected to other locations via transitions


\end{ocamldocdescription}




\begin{ocamldoccode}
{\tt{module }}{\tt{LocationSet}}{\tt{ : }}\end{ocamldoccode}
\label{module:ProgramTypes.LocationSet}\index{LocationSet@\verb`LocationSet`}

{\tt{module type of }}{\tt{Set.Make(Location)}}





\begin{ocamldoccode}
{\tt{module }}{\tt{Transition}}{\tt{ : }}\end{ocamldoccode}
\label{module:ProgramTypes.Transition}\index{Transition@\verb`Transition`}

\begin{ocamldocsigend}


\label{type:ProgramTypes.Transition.t}\begin{ocamldoccode}
type t = ProgramTypes.Location.t * TransitionLabel.t * ProgramTypes.Location.t 
\end{ocamldoccode}
\index{t@\verb`t`}


\label{val:ProgramTypes.Transition.same}\begin{ocamldoccode}
val same : t -> t -> bool
\end{ocamldoccode}
\index{same@\verb`same`}


\label{val:ProgramTypes.Transition.equivalent}\begin{ocamldoccode}
val equivalent : t -> t -> bool
\end{ocamldoccode}
\index{equivalent@\verb`equivalent`}


\label{val:ProgramTypes.Transition.compare-underscoresame}\begin{ocamldoccode}
val compare_same : t -> t -> int
\end{ocamldoccode}
\index{compare-underscoresame@\verb`compare_same`}


\label{val:ProgramTypes.Transition.compare-underscoreequivalent}\begin{ocamldoccode}
val compare_equivalent : t -> t -> int
\end{ocamldoccode}
\index{compare-underscoreequivalent@\verb`compare_equivalent`}


\label{val:ProgramTypes.Transition.hash}\begin{ocamldoccode}
val hash : t -> int
\end{ocamldoccode}
\index{hash@\verb`hash`}


\label{val:ProgramTypes.Transition.to-underscoreid-underscorestring}\begin{ocamldoccode}
val to_id_string : t -> string
\end{ocamldoccode}
\index{to-underscoreid-underscorestring@\verb`to_id_string`}


\label{val:ProgramTypes.Transition.to-underscorestring}\begin{ocamldoccode}
val to_string : ?to_file:bool -> t -> string
\end{ocamldoccode}
\index{to-underscorestring@\verb`to_string`}


\label{val:ProgramTypes.Transition.src}\begin{ocamldoccode}
val src : t -> ProgramTypes.Location.t
\end{ocamldoccode}
\index{src@\verb`src`}


\label{val:ProgramTypes.Transition.label}\begin{ocamldoccode}
val label : t -> TransitionLabel.t
\end{ocamldoccode}
\index{label@\verb`label`}


\label{val:ProgramTypes.Transition.target}\begin{ocamldoccode}
val target : t -> ProgramTypes.Location.t
\end{ocamldoccode}
\index{target@\verb`target`}


\label{val:ProgramTypes.Transition.id}\begin{ocamldoccode}
val id : t -> int
\end{ocamldoccode}
\index{id@\verb`id`}


\label{val:ProgramTypes.Transition.cost}\begin{ocamldoccode}
val cost : t -> Polynomials.Polynomial.t
\end{ocamldoccode}
\index{cost@\verb`cost`}
\begin{ocamldocdescription}
Adds the invariant to this transition.


\end{ocamldocdescription}


\label{val:ProgramTypes.Transition.add-underscoreinvariant}\begin{ocamldoccode}
val add_invariant : Constraints.Constraint.t ->
  t -> t
\end{ocamldoccode}
\index{add-underscoreinvariant@\verb`add_invariant`}


\label{val:ProgramTypes.Transition.rename}\begin{ocamldoccode}
val rename : Var.t list -> t -> t
\end{ocamldoccode}
\index{rename@\verb`rename`}
\end{ocamldocsigend}






\begin{ocamldoccode}
{\tt{module }}{\tt{TransitionSet}}{\tt{ : }}\end{ocamldoccode}
\label{module:ProgramTypes.TransitionSet}\index{TransitionSet@\verb`TransitionSet`}

\begin{ocamldocsigend}


{\tt{include }}{\tt{??}}

\label{val:ProgramTypes.TransitionSet.powerset}\begin{ocamldoccode}
val powerset : t -> t Batteries.Enum.t
\end{ocamldoccode}
\index{powerset@\verb`powerset`}


\label{val:ProgramTypes.TransitionSet.to-underscorestring}\begin{ocamldoccode}
val to_string : t -> string
\end{ocamldoccode}
\index{to-underscorestring@\verb`to_string`}
\end{ocamldocsigend}






\begin{ocamldoccode}
{\tt{module }}{\tt{TransitionGraph}}{\tt{ : }}\end{ocamldoccode}
\label{module:ProgramTypes.TransitionGraph}\index{TransitionGraph@\verb`TransitionGraph`}

\begin{ocamldocsigend}


{\tt{include }}{\tt{??}}

\label{val:ProgramTypes.TransitionGraph.locations}\begin{ocamldoccode}
val locations : t -> ProgramTypes.LocationSet.t
\end{ocamldoccode}
\index{locations@\verb`locations`}


\label{val:ProgramTypes.TransitionGraph.transitions}\begin{ocamldoccode}
val transitions : t -> ProgramTypes.TransitionSet.t
\end{ocamldoccode}
\index{transitions@\verb`transitions`}


\label{val:ProgramTypes.TransitionGraph.loc-underscoretransitions}\begin{ocamldoccode}
val loc_transitions :
  t -> ProgramTypes.Location.t list -> ProgramTypes.TransitionSet.t
\end{ocamldoccode}
\index{loc-underscoretransitions@\verb`loc_transitions`}


\label{val:ProgramTypes.TransitionGraph.equivalent}\begin{ocamldoccode}
val equivalent : t -> t -> bool
\end{ocamldoccode}
\index{equivalent@\verb`equivalent`}
\begin{ocamldocdescription}
Replaces the first edge by the second edge.


\end{ocamldocdescription}


\label{val:ProgramTypes.TransitionGraph.replace-underscoreedge-underscoree}\begin{ocamldoccode}
val replace_edge_e :
  ProgramTypes.Transition.t -> ProgramTypes.Transition.t -> t -> t
\end{ocamldoccode}
\index{replace-underscoreedge-underscoree@\verb`replace_edge_e`}
\begin{ocamldocdescription}
Adds the invariant to the location of the graph.


\end{ocamldocdescription}


\label{val:ProgramTypes.TransitionGraph.add-underscoreinvariant}\begin{ocamldoccode}
val add_invariant :
  ProgramTypes.Location.t -> Constraints.Constraint.t -> t -> t
\end{ocamldoccode}
\index{add-underscoreinvariant@\verb`add_invariant`}
\end{ocamldocsigend}






\begin{ocamldoccode}
{\tt{module }}{\tt{TransitionGraphWeight}}{\tt{ : }}\end{ocamldoccode}
\label{module:ProgramTypes.TransitionGraphWeight}\index{TransitionGraphWeight@\verb`TransitionGraphWeight`}

{\tt{functor (}}{\tt{Value}}{\tt{ : }}{\tt{PolyTypes.Ring}}{\tt{) -> }}\begin{ocamldocsigend}


\label{type:ProgramTypes.TransitionGraphWeight.t}\begin{ocamldoccode}
type t = Value.t 
\end{ocamldoccode}
\index{t@\verb`t`}


\label{type:ProgramTypes.TransitionGraphWeight.edge}\begin{ocamldoccode}
type edge = ProgramTypes.TransitionGraph.E.t 
\end{ocamldoccode}
\index{edge@\verb`edge`}


\label{val:ProgramTypes.TransitionGraphWeight.weight}\begin{ocamldoccode}
val weight : edge -> Value.t
\end{ocamldoccode}
\index{weight@\verb`weight`}


\label{val:ProgramTypes.TransitionGraphWeight.compare}\begin{ocamldoccode}
val compare : {\textquotesingle}a -> {\textquotesingle}b -> int
\end{ocamldoccode}
\index{compare@\verb`compare`}


\label{val:ProgramTypes.TransitionGraphWeight.add}\begin{ocamldoccode}
val add : Value.t -> Value.t -> Value.t
\end{ocamldoccode}
\index{add@\verb`add`}


\label{val:ProgramTypes.TransitionGraphWeight.zero}\begin{ocamldoccode}
val zero : Value.t
\end{ocamldoccode}
\index{zero@\verb`zero`}
\end{ocamldocsigend}






\section{Module {\tt{LocalSizeBound}}}
\label{module:LocalSizeBound}\index{LocalSizeBound@\verb`LocalSizeBound`}


\ocamldocvspace{0.5cm}



A templated bound is a bound of a certain templated form.
    The different templates are not disjunctive.
    The upcoming template set always includes the previous one.



\label{type:LocalSizeBound.t}\begin{ocamldoccode}
type t 
\end{ocamldoccode}
\index{t@\verb`t`}
\begin{ocamldocdescription}
Always smaller or equal to a scaling factor multiplied with the sum of all prevariables and a constant. Examples: x'$=$x+y , x'$=$2*(x+y+z) 
    s * (e + sum {\tt{x1;...;xn}})


\end{ocamldocdescription}




\label{val:LocalSizeBound.mk}\begin{ocamldoccode}
val mk :
  ?s:int ->
  ?c:int ->
  ?pos_abs:string list ->
  ?pos_pure:string list ->
  ?neg_abs:string list ->
  ?neg_pure:string list -> [ {\textasciigrave}Lower | {\textasciigrave}Upper ] -> t
\end{ocamldoccode}
\index{mk@\verb`mk`}
\begin{ocamldocdescription}
Creates a templated bound from the template and a string list which represents the variable set.


\end{ocamldocdescription}




\label{val:LocalSizeBound.is-underscorefinite-underscorebound}\begin{ocamldoccode}
val is_finite_bound : t -> bool
\end{ocamldoccode}
\index{is-underscorefinite-underscorebound@\verb`is_finite_bound`}
\begin{ocamldocdescription}
Returns true if the given local size bound is an actual bound and false, if the local size bound is infinity or -infinity


\end{ocamldocdescription}




\label{val:LocalSizeBound.equal}\begin{ocamldoccode}
val equal : t -> t -> bool
\end{ocamldoccode}
\index{equal@\verb`equal`}
\begin{ocamldocdescription}
Returns if the templated bounds represent the same bound.


\end{ocamldocdescription}




\label{val:LocalSizeBound.factor}\begin{ocamldoccode}
val factor : t -> int
\end{ocamldoccode}
\index{factor@\verb`factor`}
\begin{ocamldocdescription}
Returns the factor of the local sizebound. Raises unbounded, if the local size bound is unbounded


\end{ocamldocdescription}




\label{val:LocalSizeBound.constant}\begin{ocamldoccode}
val constant : t -> int
\end{ocamldoccode}
\index{constant@\verb`constant`}
\begin{ocamldocdescription}
Returns the constant of the local sizebound. Raises unbounded, if the local size bound is unbounded


\end{ocamldocdescription}




\label{val:LocalSizeBound.vars}\begin{ocamldoccode}
val vars : t -> VarSet.t
\end{ocamldoccode}
\index{vars@\verb`vars`}
\begin{ocamldocdescription}
Returns a set of of variables which affect the local sizebound


\end{ocamldocdescription}




Returns a set of all variables which monotonical increasingly or monotonical decreasingly affect the local sizebound



\label{val:LocalSizeBound.vars-underscoreof-underscoresign}\begin{ocamldoccode}
val vars_of_sign : [ {\textasciigrave}Neg | {\textasciigrave}Pos ] -> t -> VarSet.t
\end{ocamldoccode}
\index{vars-underscoreof-underscoresign@\verb`vars_of_sign`}
\begin{ocamldocdescription}
Those are variables with a positive coefficient or a negative coefficient.


\end{ocamldocdescription}




\label{val:LocalSizeBound.vars-underscoreof-underscorepurity}\begin{ocamldoccode}
val vars_of_purity : [ {\textasciigrave}Abs | {\textasciigrave}Pure ] -> t -> VarSet.t
\end{ocamldoccode}
\index{vars-underscoreof-underscorepurity@\verb`vars_of_purity`}




\label{val:LocalSizeBound.pre-underscorekind}\begin{ocamldoccode}
val pre_kind : [ {\textasciigrave}Lower | {\textasciigrave}Upper ] * [ {\textasciigrave}Neg | {\textasciigrave}Pos ] -> [ {\textasciigrave}Lower | {\textasciigrave}Upper ]
\end{ocamldoccode}
\index{pre-underscorekind@\verb`pre_kind`}




\label{val:LocalSizeBound.to-underscorestring}\begin{ocamldoccode}
val to_string : t -> string
\end{ocamldoccode}
\index{to-underscorestring@\verb`to_string`}
\begin{ocamldocdescription}
Converts the templated bound to a string.


\end{ocamldocdescription}




\label{val:LocalSizeBound.as-underscoresubstituted-underscorebound}\begin{ocamldoccode}
val as_substituted_bound :
  ([ {\textasciigrave}Lower | {\textasciigrave}Upper ] -> Var.t -> Bound.t) -> t -> Bound.t
\end{ocamldoccode}
\index{as-underscoresubstituted-underscorebound@\verb`as_substituted_bound`}
\begin{ocamldocdescription}
Takes a function that returns sizebounds for each variable and a local sizebound.
    Returns a bound representing the local sizebound with each variable substituted in a way that the bound is valid.


\end{ocamldocdescription}




\label{val:LocalSizeBound.as-underscorebound}\begin{ocamldoccode}
val as_bound : t -> Bound.t
\end{ocamldoccode}
\index{as-underscorebound@\verb`as_bound`}
\begin{ocamldocdescription}
Converts the templated bound to an actual bound.


\end{ocamldocdescription}




\label{val:LocalSizeBound.default}\begin{ocamldoccode}
val default : [ {\textasciigrave}Lower | {\textasciigrave}Upper ] -> Bound.t
\end{ocamldoccode}
\index{default@\verb`default`}




\label{val:LocalSizeBound.as-underscoreformula}\begin{ocamldoccode}
val as_formula : Var.t -> t -> Formulas.Formula.t
\end{ocamldoccode}
\index{as-underscoreformula@\verb`as_formula`}
\begin{ocamldocdescription}
Returns a formula which expresses that the variable is smaller or equal to the bound, e.g. x $\leq$ b.


\end{ocamldocdescription}




\label{val:LocalSizeBound.find-underscorebound}\begin{ocamldoccode}
val find_bound :
  [ {\textasciigrave}Lower | {\textasciigrave}Upper ] ->
  VarSet.t ->
  Var.t ->
  Formulas.Formula.t -> Polynomials.Polynomial.t -> int -> t
\end{ocamldoccode}
\index{find-underscorebound@\verb`find_bound`}
\begin{ocamldocdescription}
Tries to find a templated bound of any of the defined templates.


\end{ocamldocdescription}




\label{val:LocalSizeBound.sizebound-underscorelocal}\begin{ocamldoccode}
val sizebound_local :
  Program.t ->
  [ {\textasciigrave}Lower | {\textasciigrave}Upper ] ->
  ProgramTypes.Transition.t -> Var.t -> t Batteries.Option.t
\end{ocamldoccode}
\index{sizebound-underscorelocal@\verb`sizebound_local`}
\begin{ocamldocdescription}
Returns a local sizebound of the specified kind for the variable of the transition. 
    A local sizebound is expressed in relation to the values directly before executing the transition.


\end{ocamldocdescription}




\label{val:LocalSizeBound.sizebound-underscorelocal-underscorerv}\begin{ocamldoccode}
val sizebound_local_rv :
  Program.t ->
  [ {\textasciigrave}Lower | {\textasciigrave}Upper ] ->
  ProgramTypes.Transition.t * Var.t -> t Batteries.Option.t
\end{ocamldoccode}
\index{sizebound-underscorelocal-underscorerv@\verb`sizebound_local_rv`}




\label{val:LocalSizeBound.sizebound-underscorelocal-underscorescc}\begin{ocamldoccode}
val sizebound_local_scc :
  Program.t ->
  [ {\textasciigrave}Lower | {\textasciigrave}Upper ] ->
  (ProgramTypes.Transition.t * Var.t) list ->
  ([ {\textasciigrave}Lower | {\textasciigrave}Upper ] -> ProgramTypes.Transition.t * Var.t -> t)
  Batteries.Option.t
\end{ocamldoccode}
\index{sizebound-underscorelocal-underscorescc@\verb`sizebound_local_scc`}
\begin{ocamldocdescription}
If for all result variables of the given kind a local sizebound is defined, this function returns a local sizebound function.
    Otherwise it returns None.


\end{ocamldocdescription}




\label{val:LocalSizeBound.reset}\begin{ocamldoccode}
val reset : unit -> unit
\end{ocamldoccode}
\index{reset@\verb`reset`}
\begin{ocamldocdescription}
Resets all cached data.
    Useful for testing in the same OCaml instance.


\end{ocamldocdescription}


\section{Module {\tt{TransitionLabel}}}
\label{module:TransitionLabel}\index{TransitionLabel@\verb`TransitionLabel`}


\ocamldocvspace{0.5cm}



\begin{ocamldoccode}
{\tt{module }}{\tt{Guard}}{\tt{ : }}\end{ocamldoccode}
\label{module:TransitionLabel.Guard}\index{Guard@\verb`Guard`}

{\tt{Constraints.Constraint}}

\begin{ocamldocdescription}
A transition is an edge of a transition system.
    It connects two locations and is annotated with a guard and an update
    A guard has to be fulfiled for a state to reach another state via the transition
    An update assigns variables a new value as a linear combination of the old values


\end{ocamldocdescription}




\label{type:TransitionLabel.polynomial}\begin{ocamldoccode}
type polynomial = Polynomials.Polynomial.t 
\end{ocamldoccode}
\index{polynomial@\verb`polynomial`}




\begin{ocamldoccode}
{\tt{module }}{\tt{VarMap}}{\tt{ : }}\end{ocamldoccode}
\label{module:TransitionLabel.VarMap}\index{VarMap@\verb`VarMap`}

{\tt{module type of }}{\tt{Map.Make(Var)}}





\label{type:TransitionLabel.kind}\begin{ocamldoccode}
type kind = [ {\textasciigrave}Lower | {\textasciigrave}Upper ] 
\end{ocamldoccode}
\index{kind@\verb`kind`}




\label{val:TransitionLabel.equal-underscorekind}\begin{ocamldoccode}
val equal_kind : kind -> kind -> Ppx_deriving_runtime.bool
\end{ocamldoccode}
\index{equal-underscorekind@\verb`equal_kind`}




\label{val:TransitionLabel.compare-underscorekind}\begin{ocamldoccode}
val compare_kind : kind -> kind -> Ppx_deriving_runtime.int
\end{ocamldoccode}
\index{compare-underscorekind@\verb`compare_kind`}




\label{type:TransitionLabel.t}\begin{ocamldoccode}
type t 
\end{ocamldoccode}
\index{t@\verb`t`}




\label{exception:TransitionLabel.RecursionNotSupported}\begin{ocamldoccode}
exception RecursionNotSupported
\end{ocamldoccode}
\index{RecursionNotSupported@\verb`RecursionNotSupported`}




\label{val:TransitionLabel.make}\begin{ocamldoccode}
val make :
  ?cost:polynomial ->
  string ->
  update:polynomial VarMap.t ->
  guard:Guard.t -> t
\end{ocamldoccode}
\index{make@\verb`make`}




\label{val:TransitionLabel.mk}\begin{ocamldoccode}
val mk :
  ?cost:polynomial ->
  com_kind:string ->
  targets:(string * polynomial list) list ->
  patterns:Var.t list -> guard:Guard.t -> vars:Var.t list -> t
\end{ocamldoccode}
\index{mk@\verb`mk`}




\label{val:TransitionLabel.append}\begin{ocamldoccode}
val append : t -> t -> t
\end{ocamldoccode}
\index{append@\verb`append`}
\begin{ocamldocdescription}
Appends the second label to the first label.
    An evaluation of the resulting label is equivalent to an evaluation of the first label and then the second label.


\end{ocamldocdescription}




\label{val:TransitionLabel.same}\begin{ocamldoccode}
val same : t -> t -> bool
\end{ocamldoccode}
\index{same@\verb`same`}
\begin{ocamldocdescription}
Returns if the two labels are the same entity.


\end{ocamldocdescription}




\label{val:TransitionLabel.equivalent}\begin{ocamldoccode}
val equivalent : t -> t -> bool
\end{ocamldoccode}
\index{equivalent@\verb`equivalent`}
\begin{ocamldocdescription}
Returns if the two labels describe the same transition


\end{ocamldocdescription}




\label{val:TransitionLabel.compare-underscoresame}\begin{ocamldoccode}
val compare_same : t -> t -> int
\end{ocamldoccode}
\index{compare-underscoresame@\verb`compare_same`}




\label{val:TransitionLabel.compare-underscoreequivalent}\begin{ocamldoccode}
val compare_equivalent : t -> t -> int
\end{ocamldoccode}
\index{compare-underscoreequivalent@\verb`compare_equivalent`}




\label{val:TransitionLabel.id}\begin{ocamldoccode}
val id : t -> int
\end{ocamldoccode}
\index{id@\verb`id`}




\label{val:TransitionLabel.update}\begin{ocamldoccode}
val update : t -> Var.t -> polynomial Batteries.Option.t
\end{ocamldoccode}
\index{update@\verb`update`}




\label{val:TransitionLabel.guard}\begin{ocamldoccode}
val guard : t -> Guard.t
\end{ocamldoccode}
\index{guard@\verb`guard`}




\label{val:TransitionLabel.map-underscoreguard}\begin{ocamldoccode}
val map_guard : (Guard.t -> Guard.t) -> t -> t
\end{ocamldoccode}
\index{map-underscoreguard@\verb`map_guard`}
\begin{ocamldocdescription}
Returns a new transition label with the guard changed.


\end{ocamldocdescription}




\label{val:TransitionLabel.default}\begin{ocamldoccode}
val default : t
\end{ocamldoccode}
\index{default@\verb`default`}




\label{val:TransitionLabel.vars}\begin{ocamldoccode}
val vars : t -> VarSet.t
\end{ocamldoccode}
\index{vars@\verb`vars`}




\label{val:TransitionLabel.input-underscorevars}\begin{ocamldoccode}
val input_vars : t -> VarSet.t
\end{ocamldoccode}
\index{input-underscorevars@\verb`input_vars`}
\begin{ocamldocdescription}
Returns the set of input variables of the transition, i.e. the non temporary variables


\end{ocamldocdescription}




\label{val:TransitionLabel.input-underscoresize}\begin{ocamldoccode}
val input_size : t -> int
\end{ocamldoccode}
\index{input-underscoresize@\verb`input_size`}




\label{val:TransitionLabel.cost}\begin{ocamldoccode}
val cost : t -> polynomial
\end{ocamldoccode}
\index{cost@\verb`cost`}




\label{val:TransitionLabel.to-underscorestring}\begin{ocamldoccode}
val to_string : t -> string
\end{ocamldoccode}
\index{to-underscorestring@\verb`to_string`}




\label{val:TransitionLabel.update-underscoreto-underscorestring-underscorelhs}\begin{ocamldoccode}
val update_to_string_lhs : ?to_file:bool -> t -> string
\end{ocamldoccode}
\index{update-underscoreto-underscorestring-underscorelhs@\verb`update_to_string_lhs`}




\label{val:TransitionLabel.update-underscoreto-underscorestring-underscorerhs}\begin{ocamldoccode}
val update_to_string_rhs : ?to_file:bool -> t -> string
\end{ocamldoccode}
\index{update-underscoreto-underscorestring-underscorerhs@\verb`update_to_string_rhs`}




\label{val:TransitionLabel.guard-underscoreto-underscorestring}\begin{ocamldoccode}
val guard_to_string : ?to_file:bool -> t -> string
\end{ocamldoccode}
\index{guard-underscoreto-underscorestring@\verb`guard_to_string`}




\label{val:TransitionLabel.to-underscoreid-underscorestring}\begin{ocamldoccode}
val to_id_string : t -> string
\end{ocamldoccode}
\index{to-underscoreid-underscorestring@\verb`to_id_string`}




\label{val:TransitionLabel.rename}\begin{ocamldoccode}
val rename : Var.t list -> t -> t
\end{ocamldoccode}
\index{rename@\verb`rename`}


\section{Module {\tt{GraphPrint}}}
\label{module:GraphPrint}\index{GraphPrint@\verb`GraphPrint`}


\ocamldocvspace{0.5cm}



\label{val:GraphPrint.print-underscoregraph}\begin{ocamldoccode}
val print_graph :
  Fpath.t -> string -> {\textquotesingle}a -> (Pervasives.out_channel -> {\textquotesingle}a -> {\textquotesingle}b) -> unit
\end{ocamldoccode}
\index{print-underscoregraph@\verb`print_graph`}




\label{val:GraphPrint.print-underscoresystem}\begin{ocamldoccode}
val print_system :
  label:(TransitionLabel.t -> string) ->
  outdir:Fpath.t -> file:string -> Program.t -> unit
\end{ocamldoccode}
\index{print-underscoresystem@\verb`print_system`}
\begin{ocamldocdescription}
Prints a png file in the given directory with the given filename (the extension .png will be generated) for the transition graph of the program. 
        For this operation graphviz need to be installed and the 'dot' command must be accessible in the PATH.


\end{ocamldocdescription}




\label{val:GraphPrint.print-underscorervg}\begin{ocamldoccode}
val print_rvg :
  [ {\textasciigrave}Lower | {\textasciigrave}Upper ] ->
  label:(ProgramTypes.Transition.t * Var.t -> string) ->
  outdir:Fpath.t -> file:string -> Program.t -> unit
\end{ocamldoccode}
\index{print-underscorervg@\verb`print_rvg`}
\begin{ocamldocdescription}
Prints a png file in the given directory with the given filename (the extension .png will be generated) for the result variable graph of the program. 
        For this operation graphviz need to be installed and the 'dot' command must be accessible in the PATH.


\end{ocamldocdescription}


\section{Module {\tt{Parser}}}
\label{module:Parser}\index{Parser@\verb`Parser`}


\ocamldocvspace{0.5cm}



\label{type:Parser.token}\begin{ocamldoccode}
type token =
  | WITH
  | VAR
  | UNEQUAL
  | UINT of int
  | TIMES
  | STARTTERM
  | RULES
  | RPAR
  | RBRACK
  | RBRACE
  | POW
  | PLUS
  | OR
  | MINUS
  | MIN
  | MAX
  | LPAR
  | LESSTHAN
  | LESSEQUAL
  | LBRACK
  | LBRACE
  | INFINITY
  | ID of string
  | GREATERTHAN
  | GREATEREQUAL
  | GOAL
  | FUNCTIONSYMBOLS
  | EQUAL
  | EOF
  | COMMA
  | ARROW
  | AND
  | ABS
\end{ocamldoccode}
\index{token@\verb`token`}




\label{exception:Parser.Error}\begin{ocamldoccode}
exception Error
\end{ocamldoccode}
\index{Error@\verb`Error`}




\label{val:Parser.onlyProgram-underscoresimple}\begin{ocamldoccode}
val onlyProgram_simple :
  (Lexing.lexbuf -> token) -> Lexing.lexbuf -> Program.t
\end{ocamldoccode}
\index{onlyProgram-underscoresimple@\verb`onlyProgram_simple`}




\label{val:Parser.onlyProgram}\begin{ocamldoccode}
val onlyProgram : (Lexing.lexbuf -> token) -> Lexing.lexbuf -> Program.t
\end{ocamldoccode}
\index{onlyProgram@\verb`onlyProgram`}




\label{val:Parser.onlyPolynomial}\begin{ocamldoccode}
val onlyPolynomial :
  (Lexing.lexbuf -> token) -> Lexing.lexbuf -> Polynomials.Polynomial.t
\end{ocamldoccode}
\index{onlyPolynomial@\verb`onlyPolynomial`}




\label{val:Parser.onlyFormula}\begin{ocamldoccode}
val onlyFormula :
  (Lexing.lexbuf -> token) -> Lexing.lexbuf -> Formulas.Formula.t
\end{ocamldoccode}
\index{onlyFormula@\verb`onlyFormula`}




\label{val:Parser.onlyConstraints}\begin{ocamldoccode}
val onlyConstraints :
  (Lexing.lexbuf -> token) -> Lexing.lexbuf -> Constraints.Constraint.t
\end{ocamldoccode}
\index{onlyConstraints@\verb`onlyConstraints`}




\label{val:Parser.onlyBound}\begin{ocamldoccode}
val onlyBound : (Lexing.lexbuf -> token) -> Lexing.lexbuf -> Bound.t
\end{ocamldoccode}
\index{onlyBound@\verb`onlyBound`}




\label{val:Parser.onlyAtom}\begin{ocamldoccode}
val onlyAtom : (Lexing.lexbuf -> token) -> Lexing.lexbuf -> Atoms.Atom.t
\end{ocamldoccode}
\index{onlyAtom@\verb`onlyAtom`}


\section{Module {\tt{Readers}}}
\label{module:Readers}\index{Readers@\verb`Readers`}


\ocamldocvspace{0.5cm}



Provides a unified interface of the parser and lexer for transition graphs.
    With this module it is possible to abstract from the details of parsing and lexing



Constructs a reader for the given transition graph



\label{exception:Readers.Error}\begin{ocamldoccode}
exception Error of string
\end{ocamldoccode}
\index{Error@\verb`Error`}




\label{val:Readers.read-underscorefile}\begin{ocamldoccode}
val read_file : string -> Program.t
\end{ocamldoccode}
\index{read-underscorefile@\verb`read_file`}




\label{val:Readers.read-underscoreprogram}\begin{ocamldoccode}
val read_program : string -> Program.t
\end{ocamldoccode}
\index{read-underscoreprogram@\verb`read_program`}




\label{val:Readers.read-underscoreprogram-underscoresimple}\begin{ocamldoccode}
val read_program_simple : string -> Program.t
\end{ocamldoccode}
\index{read-underscoreprogram-underscoresimple@\verb`read_program_simple`}




\label{val:Readers.read-underscoreformula}\begin{ocamldoccode}
val read_formula : string -> Formulas.Formula.t
\end{ocamldoccode}
\index{read-underscoreformula@\verb`read_formula`}




\label{val:Readers.read-underscoreconstraint}\begin{ocamldoccode}
val read_constraint : string -> Constraints.Constraint.t
\end{ocamldoccode}
\index{read-underscoreconstraint@\verb`read_constraint`}




\label{val:Readers.read-underscoreatom}\begin{ocamldoccode}
val read_atom : string -> Atoms.Atom.t
\end{ocamldoccode}
\index{read-underscoreatom@\verb`read_atom`}




\label{val:Readers.read-underscorepolynomial}\begin{ocamldoccode}
val read_polynomial : string -> Polynomials.Polynomial.t
\end{ocamldoccode}
\index{read-underscorepolynomial@\verb`read_polynomial`}




\label{val:Readers.read-underscorebound}\begin{ocamldoccode}
val read_bound : string -> Bound.t
\end{ocamldoccode}
\index{read-underscorebound@\verb`read_bound`}




\label{val:Readers.read-underscoreinput}\begin{ocamldoccode}
val read_input : ?rename:bool -> bool -> string -> Program.t option
\end{ocamldoccode}
\index{read-underscoreinput@\verb`read_input`}


\section{Module {\tt{ParserUtil}}}
\label{module:ParserUtil}\index{ParserUtil@\verb`ParserUtil`}


\ocamldocvspace{0.5cm}



\label{val:ParserUtil.mk-underscoretransition}\begin{ocamldoccode}
val mk_transition :
  string * string list ->
  Polynomials.Polynomial.t ->
  string * (string * TransitionLabel.polynomial list) list ->
  Formulas.Formula.t -> Var.t list -> ProgramTypes.Transition.t list
\end{ocamldoccode}
\index{mk-underscoretransition@\verb`mk_transition`}




\label{val:ParserUtil.default-underscorevars}\begin{ocamldoccode}
val default_vars : Var.t list
\end{ocamldoccode}
\index{default-underscorevars@\verb`default_vars`}




\label{val:ParserUtil.mk-underscoretransition-underscoresimple}\begin{ocamldoccode}
val mk_transition_simple :
  string ->
  Polynomials.Polynomial.t ->
  string * (string * Polynomials.Polynomial.t list) list ->
  Formulas.Formula.t -> ProgramTypes.Transition.t list
\end{ocamldoccode}
\index{mk-underscoretransition-underscoresimple@\verb`mk_transition_simple`}




\label{val:ParserUtil.mk-underscoreprogram-underscoresimple}\begin{ocamldoccode}
val mk_program_simple : ProgramTypes.Transition.t list -> Program.t
\end{ocamldoccode}
\index{mk-underscoreprogram-underscoresimple@\verb`mk_program_simple`}




\label{val:ParserUtil.mk-underscoreprogram}\begin{ocamldoccode}
val mk_program :
  {\textquotesingle}a ->
  ProgramTypes.Location.t -> {\textquotesingle}b -> ProgramTypes.Transition.t list -> Program.t
\end{ocamldoccode}
\index{mk-underscoreprogram@\verb`mk_program`}


\section{Module {\tt{Lexer}} : Provides an lexer generated with ocamllex to lex transition graphs, its constraints and polynomials}
\label{module:Lexer}\index{Lexer@\verb`Lexer`}




\ocamldocvspace{0.5cm}



Constructs a lexer for transition graphs as well as its used constraints and polynomials



\begin{ocamldoccode}
{\tt{module }}{\tt{P}}{\tt{ : }}\end{ocamldoccode}
\label{module:Lexer.P}\index{P@\verb`P`}

{\tt{Parser}}





\label{exception:Lexer.SyntaxError}\begin{ocamldoccode}
exception SyntaxError of string
\end{ocamldoccode}
\index{SyntaxError@\verb`SyntaxError`}




\label{val:Lexer.next-underscoreline}\begin{ocamldoccode}
val next_line : Lexing.lexbuf -> unit
\end{ocamldoccode}
\index{next-underscoreline@\verb`next_line`}




\label{val:Lexer.-underscore-underscoreocaml-underscorelex-underscoretables}\begin{ocamldoccode}
val __ocaml_lex_tables : Lexing.lex_tables
\end{ocamldoccode}
\index{-underscore-underscoreocaml-underscorelex-underscoretables@\verb`__ocaml_lex_tables`}




\label{val:Lexer.read}\begin{ocamldoccode}
val read : Lexing.lexbuf -> P.token
\end{ocamldoccode}
\index{read@\verb`read`}




\label{val:Lexer.-underscore-underscoreocaml-underscorelex-underscoreread-underscorerec}\begin{ocamldoccode}
val __ocaml_lex_read_rec : Lexing.lexbuf -> int -> P.token
\end{ocamldoccode}
\index{-underscore-underscoreocaml-underscorelex-underscoreread-underscorerec@\verb`__ocaml_lex_read_rec`}


\section{Module {\tt{SizeApproximation}}}
\label{module:SizeApproximation}\index{SizeApproximation@\verb`SizeApproximation`}


\ocamldocvspace{0.5cm}



\label{type:SizeApproximation.kind}\begin{ocamldoccode}
type kind = [ {\textasciigrave}Lower | {\textasciigrave}Upper ] 
\end{ocamldoccode}
\index{kind@\verb`kind`}




\label{val:SizeApproximation.equal-underscorekind}\begin{ocamldoccode}
val equal_kind : kind -> kind -> Ppx_deriving_runtime.bool
\end{ocamldoccode}
\index{equal-underscorekind@\verb`equal_kind`}




\label{val:SizeApproximation.compare-underscorekind}\begin{ocamldoccode}
val compare_kind : kind -> kind -> Ppx_deriving_runtime.int
\end{ocamldoccode}
\index{compare-underscorekind@\verb`compare_kind`}




\label{val:SizeApproximation.pp-underscorekind}\begin{ocamldoccode}
val pp_kind :
  Ppx_deriving_runtime.Format.formatter ->
  kind -> Ppx_deriving_runtime.unit
\end{ocamldoccode}
\index{pp-underscorekind@\verb`pp_kind`}




\label{val:SizeApproximation.show-underscorekind}\begin{ocamldoccode}
val show_kind : kind -> Ppx_deriving_runtime.string
\end{ocamldoccode}
\index{show-underscorekind@\verb`show_kind`}




\label{type:SizeApproximation.t}\begin{ocamldoccode}
type t 
\end{ocamldoccode}
\index{t@\verb`t`}




\label{val:SizeApproximation.empty}\begin{ocamldoccode}
val empty : int -> t
\end{ocamldoccode}
\index{empty@\verb`empty`}




\label{val:SizeApproximation.get}\begin{ocamldoccode}
val get : kind ->
  t -> ProgramTypes.Transition.t -> Var.t -> Bound.t
\end{ocamldoccode}
\index{get@\verb`get`}




\label{val:SizeApproximation.add}\begin{ocamldoccode}
val add :
  kind ->
  Bound.t ->
  ProgramTypes.Transition.t ->
  Var.t -> t -> t
\end{ocamldoccode}
\index{add@\verb`add`}




\label{val:SizeApproximation.add-underscoreall}\begin{ocamldoccode}
val add_all : kind ->
  Bound.t -> RVGTypes.RV.t list -> t -> t
\end{ocamldoccode}
\index{add-underscoreall@\verb`add_all`}




\label{val:SizeApproximation.to-underscorestring}\begin{ocamldoccode}
val to_string : t -> string
\end{ocamldoccode}
\index{to-underscorestring@\verb`to_string`}




\label{val:SizeApproximation.equivalent}\begin{ocamldoccode}
val equivalent : t -> t -> bool
\end{ocamldoccode}
\index{equivalent@\verb`equivalent`}


\section{Module {\tt{Approximation}}}
\label{module:Approximation}\index{Approximation@\verb`Approximation`}


\ocamldocvspace{0.5cm}



Provides default implementations of an approximation



\label{type:Approximation.t}\begin{ocamldoccode}
type t 
\end{ocamldoccode}
\index{t@\verb`t`}




\label{type:Approximation.kind}\begin{ocamldoccode}
type kind = [ {\textasciigrave}Lower | {\textasciigrave}Upper ] 
\end{ocamldoccode}
\index{kind@\verb`kind`}
\begin{ocamldocdescription}
Distinguish between lower and upper bounds


\end{ocamldocdescription}




\label{val:Approximation.empty}\begin{ocamldoccode}
val empty : int -> int -> t
\end{ocamldoccode}
\index{empty@\verb`empty`}
\begin{ocamldocdescription}
Returns an empty approximation that does not contain any non-trivial information.
    That means, that every upper bound is infinite and every lower bound is minus infinite.
    The first parameter should be the count of transitions in the program.
    The second parameter should be the count of program variables.


\end{ocamldocdescription}




\label{val:Approximation.create}\begin{ocamldoccode}
val create : Program.t -> t
\end{ocamldoccode}
\index{create@\verb`create`}




\label{val:Approximation.time}\begin{ocamldoccode}
val time : t -> TransitionApproximation.t
\end{ocamldoccode}
\index{time@\verb`time`}




\label{val:Approximation.size}\begin{ocamldoccode}
val size : t -> SizeApproximation.t
\end{ocamldoccode}
\index{size@\verb`size`}




\label{val:Approximation.cost}\begin{ocamldoccode}
val cost : t -> TransitionApproximation.t
\end{ocamldoccode}
\index{cost@\verb`cost`}




\label{val:Approximation.to-underscorestring}\begin{ocamldoccode}
val to_string : Program.t -> t -> string
\end{ocamldoccode}
\index{to-underscorestring@\verb`to_string`}




\label{val:Approximation.equivalent}\begin{ocamldoccode}
val equivalent : t -> t -> bool
\end{ocamldoccode}
\index{equivalent@\verb`equivalent`}




Timebound related methods



\label{val:Approximation.timebound}\begin{ocamldoccode}
val timebound : t -> ProgramTypes.Transition.t -> Bound.t
\end{ocamldoccode}
\index{timebound@\verb`timebound`}
\begin{ocamldocdescription}
Returns a timebound for the transition.


\end{ocamldocdescription}




\label{val:Approximation.timebound-underscoreid}\begin{ocamldoccode}
val timebound_id : t -> int -> Bound.t
\end{ocamldoccode}
\index{timebound-underscoreid@\verb`timebound_id`}
\begin{ocamldocdescription}
Returns a timebound for the transition id.


\end{ocamldocdescription}




\label{val:Approximation.program-underscoretimebound}\begin{ocamldoccode}
val program_timebound : t -> Program.t -> Bound.t
\end{ocamldoccode}
\index{program-underscoretimebound@\verb`program_timebound`}
\begin{ocamldocdescription}
Returns a timebound for the program.


\end{ocamldocdescription}




\label{val:Approximation.add-underscoretimebound}\begin{ocamldoccode}
val add_timebound : Bound.t -> ProgramTypes.Transition.t -> t -> t
\end{ocamldoccode}
\index{add-underscoretimebound@\verb`add_timebound`}
\begin{ocamldocdescription}
Adds the information that the specified bound is a valid timebound for the given transition. 
    The resulting approximation is guaranteed to be at least as good as the old approximation.


\end{ocamldocdescription}




\label{val:Approximation.all-underscoretimes-underscorebounded}\begin{ocamldoccode}
val all_times_bounded : t -> ProgramTypes.Transition.t list -> bool
\end{ocamldoccode}
\index{all-underscoretimes-underscorebounded@\verb`all_times_bounded`}




\label{val:Approximation.is-underscoretime-underscorebounded}\begin{ocamldoccode}
val is_time_bounded : t -> ProgramTypes.Transition.t -> bool
\end{ocamldoccode}
\index{is-underscoretime-underscorebounded@\verb`is_time_bounded`}




Costbound related methods



\label{val:Approximation.costbound}\begin{ocamldoccode}
val costbound : t -> ProgramTypes.Transition.t -> Bound.t
\end{ocamldoccode}
\index{costbound@\verb`costbound`}
\begin{ocamldocdescription}
Returns a costbound for the transition.


\end{ocamldocdescription}




\label{val:Approximation.program-underscorecostbound}\begin{ocamldoccode}
val program_costbound : t -> Program.t -> Bound.t
\end{ocamldoccode}
\index{program-underscorecostbound@\verb`program_costbound`}
\begin{ocamldocdescription}
Returns a costbound for the program.


\end{ocamldocdescription}




\label{val:Approximation.add-underscorecostbound}\begin{ocamldoccode}
val add_costbound : Bound.t -> ProgramTypes.Transition.t -> t -> t
\end{ocamldoccode}
\index{add-underscorecostbound@\verb`add_costbound`}




Sizebound related methods



\label{val:Approximation.sizebound}\begin{ocamldoccode}
val sizebound : kind ->
  t -> ProgramTypes.Transition.t -> Var.t -> Bound.t
\end{ocamldoccode}
\index{sizebound@\verb`sizebound`}
\begin{ocamldocdescription}
Returns a sizebound of the specified kind for the var of the transition. 
        A sizebound is expressed in relation to the input variable values of the program.


\end{ocamldocdescription}




\label{val:Approximation.add-underscoresizebound}\begin{ocamldoccode}
val add_sizebound :
  kind ->
  Bound.t ->
  ProgramTypes.Transition.t -> Var.t -> t -> t
\end{ocamldoccode}
\index{add-underscoresizebound@\verb`add_sizebound`}
\begin{ocamldocdescription}
Adds the information that the specified bound is a valid sizebound for the given variable of the transition. 
        The resulting approximation is guaranteed to be at least as good as the old approximation.


\end{ocamldocdescription}




\label{val:Approximation.add-underscoresizebounds}\begin{ocamldoccode}
val add_sizebounds : kind ->
  Bound.t -> RVGTypes.RV.t list -> t -> t
\end{ocamldoccode}
\index{add-underscoresizebounds@\verb`add_sizebounds`}


\section{Module {\tt{RankingBounds}} : Updates all time-bounds and triggers control flow refinement if needed.}
\label{module:RankingBounds}\index{RankingBounds@\verb`RankingBounds`}




\ocamldocvspace{0.5cm}



\label{val:RankingBounds.improve}\begin{ocamldoccode}
val improve :
  ?mrf:bool ->
  ?cfr:bool ->
  [ {\textasciigrave}Cost | {\textasciigrave}Time ] ->
  Program.t -> Approximation.t -> Approximation.t MaybeChanged.t
\end{ocamldoccode}
\index{improve@\verb`improve`}
\begin{ocamldocdescription}
Performs a single improvement step to find better timebounds for the approximation and updates the approximation.


\end{ocamldocdescription}




\label{val:RankingBounds.entry-underscoretransitions}\begin{ocamldoccode}
val entry_transitions :
  Program.t ->
  ProgramTypes.Transition.t list -> ProgramTypes.Transition.t Batteries.List.t
\end{ocamldoccode}
\index{entry-underscoretransitions@\verb`entry_transitions`}
\begin{ocamldocdescription}
Computes all entry transitions of the given transitions.
    These are such transitions, that can occur immediately before one of the transitions, but are not themselves part of the given transitions. TODO Move to Program module?


\end{ocamldocdescription}


\section{Module {\tt{TransitionApproximation}}}
\label{module:TransitionApproximation}\index{TransitionApproximation@\verb`TransitionApproximation`}


\ocamldocvspace{0.5cm}



\label{type:TransitionApproximation.t}\begin{ocamldoccode}
type t 
\end{ocamldoccode}
\index{t@\verb`t`}




\label{val:TransitionApproximation.empty}\begin{ocamldoccode}
val empty : string -> int -> t
\end{ocamldoccode}
\index{empty@\verb`empty`}




\label{val:TransitionApproximation.get}\begin{ocamldoccode}
val get : t -> ProgramTypes.Transition.t -> Bound.t
\end{ocamldoccode}
\index{get@\verb`get`}




\label{val:TransitionApproximation.get-underscoreid}\begin{ocamldoccode}
val get_id : t -> int -> Bound.t
\end{ocamldoccode}
\index{get-underscoreid@\verb`get_id`}




\label{val:TransitionApproximation.sum}\begin{ocamldoccode}
val sum : t -> Program.t -> Bound.t
\end{ocamldoccode}
\index{sum@\verb`sum`}
\begin{ocamldocdescription}
Returns a timebound of the specified kind for the execution of the whole graph.


\end{ocamldocdescription}




\label{val:TransitionApproximation.add}\begin{ocamldoccode}
val add : Bound.t ->
  ProgramTypes.Transition.t ->
  t -> t
\end{ocamldoccode}
\index{add@\verb`add`}




\label{val:TransitionApproximation.all-underscorebounded}\begin{ocamldoccode}
val all_bounded : t -> ProgramTypes.Transition.t list -> bool
\end{ocamldoccode}
\index{all-underscorebounded@\verb`all_bounded`}




\label{val:TransitionApproximation.to-underscorestring}\begin{ocamldoccode}
val to_string : ProgramTypes.TransitionSet.t -> t -> string
\end{ocamldoccode}
\index{to-underscorestring@\verb`to_string`}




\label{val:TransitionApproximation.equivalent}\begin{ocamldoccode}
val equivalent : t -> t -> bool
\end{ocamldoccode}
\index{equivalent@\verb`equivalent`}


\section{Module {\tt{CFR}} : Provides control flow refinement on minimal SCCs containing non-linear transitions.}
\label{module:CFR}\index{CFR@\verb`CFR`}




\ocamldocvspace{0.5cm}



\label{val:CFR.apply-underscorecfr}\begin{ocamldoccode}
val apply_cfr : Program.t -> unit
\end{ocamldoccode}
\index{apply-underscorecfr@\verb`apply_cfr`}
\begin{ocamldocdescription}
Unrolls all transitions listed in nonLinearTransitions.starrt


\end{ocamldocdescription}




\label{val:CFR.nonLinearTransitions}\begin{ocamldoccode}
val nonLinearTransitions : ProgramTypes.TransitionSet.t Batteries.ref
\end{ocamldoccode}
\index{nonLinearTransitions@\verb`nonLinearTransitions`}
\begin{ocamldocdescription}
Reference is used to store non-linear transitions.


\end{ocamldocdescription}


\section{Module {\tt{SizeBounds}}}
\label{module:SizeBounds}\index{SizeBounds@\verb`SizeBounds`}


\ocamldocvspace{0.5cm}



\label{val:SizeBounds.improve}\begin{ocamldoccode}
val improve : Program.t -> Approximation.t -> Approximation.t
\end{ocamldoccode}
\index{improve@\verb`improve`}
\begin{ocamldocdescription}
Performs a single improvement step for a whole program to find better sizebounds for the approximation and updates the approximation.


\end{ocamldocdescription}




\label{val:SizeBounds.improve-underscorescc}\begin{ocamldoccode}
val improve_scc :
  [ {\textasciigrave}Lower | {\textasciigrave}Upper ] ->
  Program.t ->
  RVGTypes.RVG.t -> Approximation.t -> RVGTypes.RV.t list -> Approximation.t
\end{ocamldoccode}
\index{improve-underscorescc@\verb`improve_scc`}
\begin{ocamldocdescription}
Performs a single improvement step for a single scc to find better sizebounds for the approximation and updates the approximation.


\end{ocamldocdescription}


\section{Module {\tt{MultiphaseRankingFunction}} : Implementation of Multiphase Ranking Functions.}
\label{module:MultiphaseRankingFunction}\index{MultiphaseRankingFunction@\verb`MultiphaseRankingFunction`}




\ocamldocvspace{0.5cm}



Implementation of multiphase ranking function based on Linear Ranking Functions, flag --mrf has to be set to use multiphase ranking function.



\label{type:MultiphaseRankingFunction.t}\begin{ocamldoccode}
type t 
\end{ocamldoccode}
\index{t@\verb`t`}




\label{type:MultiphaseRankingFunction.measure}\begin{ocamldoccode}
type measure = [ {\textasciigrave}Cost | {\textasciigrave}Time ] 
\end{ocamldoccode}
\index{measure@\verb`measure`}




\label{val:MultiphaseRankingFunction.pp-underscoremeasure}\begin{ocamldoccode}
val pp_measure :
  Ppx_deriving_runtime.Format.formatter ->
  measure -> Ppx_deriving_runtime.unit
\end{ocamldoccode}
\index{pp-underscoremeasure@\verb`pp_measure`}




\label{val:MultiphaseRankingFunction.show-underscoremeasure}\begin{ocamldoccode}
val show_measure : measure -> Ppx_deriving_runtime.string
\end{ocamldoccode}
\index{show-underscoremeasure@\verb`show_measure`}




\label{val:MultiphaseRankingFunction.rank}\begin{ocamldoccode}
val rank : t ->
  (ProgramTypes.Location.t -> Polynomials.Polynomial.t) list
\end{ocamldoccode}
\index{rank@\verb`rank`}
\begin{ocamldocdescription}
Returns a list of polynomials representing a multiphase ranking function.


\end{ocamldocdescription}




\label{val:MultiphaseRankingFunction.decreasing}\begin{ocamldoccode}
val decreasing : t -> ProgramTypes.Transition.t
\end{ocamldoccode}
\index{decreasing@\verb`decreasing`}
\begin{ocamldocdescription}
Returns a non-empty list of all transitions which are strictly decreasing and at the same time bounded with one.
    Corresponds to T\_$>$ .


\end{ocamldocdescription}




\label{val:MultiphaseRankingFunction.non-underscoreincreasing}\begin{ocamldoccode}
val non_increasing : t -> ProgramTypes.Transition.t list
\end{ocamldoccode}
\index{non-underscoreincreasing@\verb`non_increasing`}
\begin{ocamldocdescription}
Returns a list of all transitions for which the multiphase ranking function is defined.
    Corresponds to T'.


\end{ocamldocdescription}




\label{val:MultiphaseRankingFunction.depth}\begin{ocamldoccode}
val depth : t -> int
\end{ocamldoccode}
\index{depth@\verb`depth`}
\begin{ocamldocdescription}
Returns the depth of a multiphase ranking function (i.e. returns d if MRF has form f1,f2,$\ldots$,fd).


\end{ocamldocdescription}




\label{val:MultiphaseRankingFunction.maxDepth}\begin{ocamldoccode}
val maxDepth : int Batteries.ref
\end{ocamldoccode}
\index{maxDepth@\verb`maxDepth`}
\begin{ocamldocdescription}
A reference to store the maximum depth to bound the search space of multiphase ranking function. The default value is 5 and can be adjusted by the user with flag -d.


\end{ocamldocdescription}




\label{val:MultiphaseRankingFunction.list-underscoreinit}\begin{ocamldoccode}
val list_init : int -> unit
\end{ocamldoccode}
\index{list-underscoreinit@\verb`list_init`}
\begin{ocamldocdescription}
Initializes list after maxDepth is set.


\end{ocamldocdescription}




\label{val:MultiphaseRankingFunction.find}\begin{ocamldoccode}
val find : measure ->
  Program.t -> ProgramTypes.Transition.t -> t list
\end{ocamldoccode}
\index{find@\verb`find`}
\begin{ocamldocdescription}
Finds a suitable multiphase ranking function for the given transitions T'.


\end{ocamldocdescription}




\label{val:MultiphaseRankingFunction.to-underscorestring}\begin{ocamldoccode}
val to_string : t -> string
\end{ocamldoccode}
\index{to-underscorestring@\verb`to_string`}
\begin{ocamldocdescription}
Converts a multiphase ranking function into a string


\end{ocamldocdescription}




\label{val:MultiphaseRankingFunction.only-underscorerank-underscoreto-underscorestring}\begin{ocamldoccode}
val only_rank_to_string : t -> string
\end{ocamldoccode}
\index{only-underscorerank-underscoreto-underscorestring@\verb`only_rank_to_string`}
\begin{ocamldocdescription}
Converts a multiphase ranking function into a string without any further information.


\end{ocamldocdescription}




\label{val:MultiphaseRankingFunction.reset}\begin{ocamldoccode}
val reset : unit -> unit
\end{ocamldoccode}
\index{reset@\verb`reset`}
\begin{ocamldocdescription}
Resets all cached data.
    Useful for testing in the same OCaml instance.


\end{ocamldocdescription}


\section{Module {\tt{MRF\_Coefficient}} : Computes coefficients for Multiphase Ranking Functions necessary for upper time-bounds.}
\label{module:MRF-underscoreCoefficient}\index{MRF-underscoreCoefficient@\verb`MRF_Coefficient`}




\ocamldocvspace{0.5cm}



Handles multiphase ranking functions {\tt{cf. Genaim,Amram 2017}} and computes coefficients for upper time-bounds.



\label{val:MRF-underscoreCoefficient.maxBound-underscoreof-underscorelist}\begin{ocamldoccode}
val maxBound_of_list : Bound.t list -> Bound.t
\end{ocamldoccode}
\index{maxBound-underscoreof-underscorelist@\verb`maxBound_of_list`}
\begin{ocamldocdescription}
Returns for a list of Bounds b1,$\ldots$,bn the maximum-bound max(b1,$\ldots$,bn).


\end{ocamldocdescription}




\label{val:MRF-underscoreCoefficient.coefficient}\begin{ocamldoccode}
val coefficient : MultiphaseRankingFunction.t -> int
\end{ocamldoccode}
\index{coefficient@\verb`coefficient`}
\begin{ocamldocdescription}
Returns maximal coefficient for a Multiphase Ranking Function {\tt{cf. Genaim,Amram 2017}}.


\end{ocamldocdescription}


\section{Module {\tt{RankingFunction}} : Implementation of (linear) Ranking Functions.}
\label{module:RankingFunction}\index{RankingFunction@\verb`RankingFunction`}




\ocamldocvspace{0.5cm}



Provides default implementations of RankingFunctions. KoAT uses this as a default function if the user does not specify any requirements by setting parameters (e.g. --mrf).



\label{type:RankingFunction.t}\begin{ocamldoccode}
type t 
\end{ocamldoccode}
\index{t@\verb`t`}




\label{type:RankingFunction.measure}\begin{ocamldoccode}
type measure = [ {\textasciigrave}Cost | {\textasciigrave}Time ] 
\end{ocamldoccode}
\index{measure@\verb`measure`}




\label{val:RankingFunction.pp-underscoremeasure}\begin{ocamldoccode}
val pp_measure :
  Ppx_deriving_runtime.Format.formatter ->
  measure -> Ppx_deriving_runtime.unit
\end{ocamldoccode}
\index{pp-underscoremeasure@\verb`pp_measure`}




\label{val:RankingFunction.show-underscoremeasure}\begin{ocamldoccode}
val show_measure : measure -> Ppx_deriving_runtime.string
\end{ocamldoccode}
\index{show-underscoremeasure@\verb`show_measure`}




\label{val:RankingFunction.rank}\begin{ocamldoccode}
val rank : t -> ProgramTypes.Location.t -> Polynomials.Polynomial.t
\end{ocamldoccode}
\index{rank@\verb`rank`}
\begin{ocamldocdescription}
Returns the ranking polynomial for the specific location.


\end{ocamldocdescription}




\label{val:RankingFunction.decreasing}\begin{ocamldoccode}
val decreasing : t -> ProgramTypes.Transition.t
\end{ocamldoccode}
\index{decreasing@\verb`decreasing`}
\begin{ocamldocdescription}
Returns a non-empty list of all transitions which are strictly decreasing and at the same time bounded with one.
    Corresponds to T\_$>$ .


\end{ocamldocdescription}




\label{val:RankingFunction.non-underscoreincreasing}\begin{ocamldoccode}
val non_increasing : t -> ProgramTypes.Transition.t list
\end{ocamldoccode}
\index{non-underscoreincreasing@\verb`non_increasing`}
\begin{ocamldocdescription}
Returns a list of all transitions for which the prf is defined.
    Corresponds to T'.


\end{ocamldocdescription}




\label{val:RankingFunction.find}\begin{ocamldoccode}
val find : measure ->
  Program.t -> ProgramTypes.Transition.t -> t list
\end{ocamldoccode}
\index{find@\verb`find`}
\begin{ocamldocdescription}
Finds a suitable ranking function for the given transitions T'.


\end{ocamldocdescription}




\label{val:RankingFunction.to-underscorestring}\begin{ocamldoccode}
val to_string : t -> string
\end{ocamldoccode}
\index{to-underscorestring@\verb`to_string`}
\begin{ocamldocdescription}
Converts a ranking function into a string


\end{ocamldocdescription}




\label{val:RankingFunction.only-underscorerank-underscoreto-underscorestring}\begin{ocamldoccode}
val only_rank_to_string : t -> string
\end{ocamldoccode}
\index{only-underscorerank-underscoreto-underscorestring@\verb`only_rank_to_string`}
\begin{ocamldocdescription}
Converts a ranking function into a string without any further information.


\end{ocamldocdescription}




\label{val:RankingFunction.reset}\begin{ocamldoccode}
val reset : unit -> unit
\end{ocamldoccode}
\index{reset@\verb`reset`}
\begin{ocamldocdescription}
Resets all cached data.
    Useful for testing in the same OCaml instance.


\end{ocamldocdescription}


\section{Module {\tt{TrivialTimeBounds}}}
\label{module:TrivialTimeBounds}\index{TrivialTimeBounds@\verb`TrivialTimeBounds`}


\ocamldocvspace{0.5cm}



\begin{ocamldoccode}
{\tt{module }}{\tt{SCC}}{\tt{ : }}\end{ocamldoccode}
\label{module:TrivialTimeBounds.SCC}\index{SCC@\verb`SCC`}

{\tt{Graph.Components.Make}}{\tt{(}}{\tt{ProgramTypes.TransitionGraph}}{\tt{)}}





\label{val:TrivialTimeBounds.compute}\begin{ocamldoccode}
val compute : Program.t -> Approximation.t -> Approximation.t
\end{ocamldoccode}
\index{compute@\verb`compute`}
\begin{ocamldocdescription}
This preprocessor infers for all transitions which are not part of an scc a time bound of one.
    Those transitions can only be executed once and preprocessing might increase performance and also might lead to better bounds.


\end{ocamldocdescription}


\section{Module {\tt{TrivialSizeBounds}}}
\label{module:TrivialSizeBounds}\index{TrivialSizeBounds@\verb`TrivialSizeBounds`}


\ocamldocvspace{0.5cm}



\label{val:TrivialSizeBounds.logger}\begin{ocamldoccode}
val logger : Batteries.Logger.log
\end{ocamldoccode}
\index{logger@\verb`logger`}




\label{type:TrivialSizeBounds.kind}\begin{ocamldoccode}
type kind = [ {\textasciigrave}Lower | {\textasciigrave}Upper ] 
\end{ocamldoccode}
\index{kind@\verb`kind`}




\label{val:TrivialSizeBounds.pp-underscorekind}\begin{ocamldoccode}
val pp_kind :
  Ppx_deriving_runtime.Format.formatter ->
  kind -> Ppx_deriving_runtime.unit
\end{ocamldoccode}
\index{pp-underscorekind@\verb`pp_kind`}




\label{val:TrivialSizeBounds.show-underscorekind}\begin{ocamldoccode}
val show_kind : kind -> Ppx_deriving_runtime.string
\end{ocamldoccode}
\index{show-underscorekind@\verb`show_kind`}




\label{val:TrivialSizeBounds.incoming-underscorebound}\begin{ocamldoccode}
val incoming_bound :
  [< {\textasciigrave}Lower | {\textasciigrave}Upper ] ->
  Program.t ->
  ([ {\textasciigrave}Lower | {\textasciigrave}Upper ] -> ProgramTypes.Transition.t -> Var.t -> Bound.t) ->
  LocalSizeBound.t -> ProgramTypes.Transition.t -> Bound.t
\end{ocamldoccode}
\index{incoming-underscorebound@\verb`incoming_bound`}
\begin{ocamldocdescription}
Returns the maximum of all incoming sizebounds applied to the local sizebound.
    Corresponds to 'SizeBounds for trivial SCCs':
    S'(alpha) $=$ max(S\_l(alpha)(S(t',v\_1),$\ldots$,S(t',v\_n)) for all t' in pre(t))


\end{ocamldocdescription}




\label{val:TrivialSizeBounds.compute}\begin{ocamldoccode}
val compute :
  kind ->
  Program.t ->
  ([ {\textasciigrave}Lower | {\textasciigrave}Upper ] -> ProgramTypes.Transition.t -> Var.t -> Bound.t) ->
  ProgramTypes.Transition.t * Var.t -> Bound.t
\end{ocamldoccode}
\index{compute@\verb`compute`}
\begin{ocamldocdescription}
Computes a bound for a trivial scc. That is an scc which consists only of one result variable without a loop to itself.
    Corresponds to 'SizeBounds for trivial SCCs'.


\end{ocamldocdescription}


\section{Module {\tt{Bounds}} : Updates size and time-bounds until a fixed point is reached.}
\label{module:Bounds}\index{Bounds@\verb`Bounds`}




\ocamldocvspace{0.5cm}



\label{val:Bounds.find-underscorebounds-underscore}\begin{ocamldoccode}
val find_bounds_ :
  ?mrf:bool -> ?cfr:bool -> Program.t -> Approximation.t -> Approximation.t
\end{ocamldoccode}
\index{find-underscorebounds-underscore@\verb`find_bounds_`}




\label{val:Bounds.find-underscorebounds}\begin{ocamldoccode}
val find_bounds :
  ?depth:int ->
  ?mrf:bool -> ?cfr:bool -> Program.t -> Approximation.t -> Approximation.t
\end{ocamldoccode}
\index{find-underscorebounds@\verb`find_bounds`}


\section{Module {\tt{CostBounds}}}
\label{module:CostBounds}\index{CostBounds@\verb`CostBounds`}


\ocamldocvspace{0.5cm}



\label{val:CostBounds.unbounded}\begin{ocamldoccode}
val unbounded : Approximation.t -> ProgramTypes.Transition.t -> bool
\end{ocamldoccode}
\index{unbounded@\verb`unbounded`}




\label{val:CostBounds.infer-underscorefrom-underscoretimebounds}\begin{ocamldoccode}
val infer_from_timebounds : Program.t -> Approximation.t -> Approximation.t
\end{ocamldoccode}
\index{infer-underscorefrom-underscoretimebounds@\verb`infer_from_timebounds`}


\section{Module {\tt{NontrivialSizeBounds}}}
\label{module:NontrivialSizeBounds}\index{NontrivialSizeBounds@\verb`NontrivialSizeBounds`}


\ocamldocvspace{0.5cm}



\label{val:NontrivialSizeBounds.logger}\begin{ocamldoccode}
val logger : Batteries.Logger.log
\end{ocamldoccode}
\index{logger@\verb`logger`}




\label{type:NontrivialSizeBounds.kind}\begin{ocamldoccode}
type kind = [ {\textasciigrave}Lower | {\textasciigrave}Upper ] 
\end{ocamldoccode}
\index{kind@\verb`kind`}




\label{val:NontrivialSizeBounds.pp-underscorekind}\begin{ocamldoccode}
val pp_kind :
  Ppx_deriving_runtime.Format.formatter ->
  kind -> Ppx_deriving_runtime.unit
\end{ocamldoccode}
\index{pp-underscorekind@\verb`pp_kind`}




\label{val:NontrivialSizeBounds.show-underscorekind}\begin{ocamldoccode}
val show_kind : kind -> Ppx_deriving_runtime.string
\end{ocamldoccode}
\index{show-underscorekind@\verb`show_kind`}




\label{type:NontrivialSizeBounds.sign}\begin{ocamldoccode}
type sign = [ {\textasciigrave}Neg | {\textasciigrave}Pos ] 
\end{ocamldoccode}
\index{sign@\verb`sign`}




\label{val:NontrivialSizeBounds.pp-underscoresign}\begin{ocamldoccode}
val pp_sign :
  Ppx_deriving_runtime.Format.formatter ->
  sign -> Ppx_deriving_runtime.unit
\end{ocamldoccode}
\index{pp-underscoresign@\verb`pp_sign`}




\label{val:NontrivialSizeBounds.show-underscoresign}\begin{ocamldoccode}
val show_sign : sign -> Ppx_deriving_runtime.string
\end{ocamldoccode}
\index{show-underscoresign@\verb`show_sign`}




\label{val:NontrivialSizeBounds.sign}\begin{ocamldoccode}
val sign : [< {\textasciigrave}Lower | {\textasciigrave}Upper ] -> Bound.t -> Bound.t
\end{ocamldoccode}
\index{sign@\verb`sign`}




\label{val:NontrivialSizeBounds.compute-underscore}\begin{ocamldoccode}
val compute_ :
  kind ->
  Program.t ->
  RVGTypes.RVG.t ->
  (RVGTypes.RV.t -> LocalSizeBound.t) ->
  (ProgramTypes.Transition.t -> Bound.t) ->
  (kind -> ProgramTypes.Transition.t -> Var.t -> Bound.t) ->
  RVGTypes.RV.t list -> Bound.t
\end{ocamldoccode}
\index{compute-underscore@\verb`compute_`}




\label{val:NontrivialSizeBounds.compute}\begin{ocamldoccode}
val compute :
  kind ->
  Program.t ->
  RVGTypes.RVG.t ->
  (ProgramTypes.Transition.t -> Bound.t) ->
  (kind -> ProgramTypes.Transition.t -> Var.t -> Bound.t) ->
  RVGTypes.RV.t list -> Bound.t
\end{ocamldoccode}
\index{compute@\verb`compute`}
\begin{ocamldocdescription}
Computes a bound for a nontrivial scc. That is an scc which consists of a loop.
    Corresponds to 'SizeBounds for nontrivial SCCs'.


\end{ocamldocdescription}


\section{Module {\tt{Preprocessor}}}
\label{module:Preprocessor}\index{Preprocessor@\verb`Preprocessor`}


\ocamldocvspace{0.5cm}



Provides all module types related to preprocessors



\label{type:Preprocessor.subject}\begin{ocamldoccode}
type subject = Program.t * Approximation.t 
\end{ocamldoccode}
\index{subject@\verb`subject`}




\label{type:Preprocessor.t}\begin{ocamldoccode}
type t =
  | CutUnreachableLocations
  | CutUnsatisfiableTransitions
  | Chaining
  | InvariantGeneration
\end{ocamldoccode}
\index{t@\verb`t`}




\label{val:Preprocessor.compare}\begin{ocamldoccode}
val compare : t -> t -> Ppx_deriving_runtime.int
\end{ocamldoccode}
\index{compare@\verb`compare`}




\label{val:Preprocessor.equal}\begin{ocamldoccode}
val equal : t -> t -> Ppx_deriving_runtime.bool
\end{ocamldoccode}
\index{equal@\verb`equal`}




\label{val:Preprocessor.show}\begin{ocamldoccode}
val show : t -> string
\end{ocamldoccode}
\index{show@\verb`show`}




\label{val:Preprocessor.all}\begin{ocamldoccode}
val all : t list
\end{ocamldoccode}
\index{all@\verb`all`}




\label{val:Preprocessor.affects}\begin{ocamldoccode}
val affects : t -> t list
\end{ocamldoccode}
\index{affects@\verb`affects`}
\begin{ocamldocdescription}
Returns all the preprocessors that might successfully run after a run of the specific preprocessor.


\end{ocamldocdescription}




\label{val:Preprocessor.transform}\begin{ocamldoccode}
val transform : subject -> t -> subject MaybeChanged.t
\end{ocamldoccode}
\index{transform@\verb`transform`}
\begin{ocamldocdescription}
Transforms a preprocessing step with the specific preprocessor on the subject.
    Results in a subject that might be changed.


\end{ocamldocdescription}




\label{type:Preprocessor.strategy}\begin{ocamldoccode}
type strategy = t list -> subject -> subject 
\end{ocamldoccode}
\index{strategy@\verb`strategy`}




\label{val:Preprocessor.all-underscorestrategies}\begin{ocamldoccode}
val all_strategies : strategy list
\end{ocamldoccode}
\index{all-underscorestrategies@\verb`all_strategies`}




\label{val:Preprocessor.process}\begin{ocamldoccode}
val process : strategy ->
  t list -> subject -> subject
\end{ocamldoccode}
\index{process@\verb`process`}
\begin{ocamldocdescription}
Uses the strategy to preprocess the given subject with the specified preprocessors.


\end{ocamldocdescription}




\label{val:Preprocessor.process-underscoreonly-underscoreonce}\begin{ocamldoccode}
val process_only_once : strategy
\end{ocamldoccode}
\index{process-underscoreonly-underscoreonce@\verb`process_only_once`}
\begin{ocamldocdescription}
Applies each preprocessor exactly one time on the subject.


\end{ocamldocdescription}




\label{val:Preprocessor.process-underscoretil-underscorefixpoint}\begin{ocamldoccode}
val process_til_fixpoint : strategy
\end{ocamldoccode}
\index{process-underscoretil-underscorefixpoint@\verb`process_til_fixpoint`}
\begin{ocamldocdescription}
Applies the preprocessors continously until a fixpoint is reached, such that no preprocessor is able to do another successful preprocessing step.


\end{ocamldocdescription}




\label{val:Preprocessor.lift-underscoreto-underscoreprogram}\begin{ocamldoccode}
val lift_to_program :
  (ProgramTypes.TransitionGraph.t ->
   ProgramTypes.TransitionGraph.t MaybeChanged.t) ->
  Program.t -> Program.t MaybeChanged.t
\end{ocamldoccode}
\index{lift-underscoreto-underscoreprogram@\verb`lift_to_program`}




\label{val:Preprocessor.lift-underscoreto-underscoretuple}\begin{ocamldoccode}
val lift_to_tuple :
  ({\textquotesingle}b -> {\textquotesingle}c MaybeChanged.t) -> {\textquotesingle}b * {\textquotesingle}a -> ({\textquotesingle}c * {\textquotesingle}a) MaybeChanged.t
\end{ocamldoccode}
\index{lift-underscoreto-underscoretuple@\verb`lift_to_tuple`}


\section{Module {\tt{Chaining}}}
\label{module:Chaining}\index{Chaining@\verb`Chaining`}


\ocamldocvspace{0.5cm}



\label{val:Chaining.logger}\begin{ocamldoccode}
val logger : Batteries.Logger.log
\end{ocamldoccode}
\index{logger@\verb`logger`}




\label{val:Chaining.skip-underscorelocation}\begin{ocamldoccode}
val skip_location :
  ProgramTypes.TransitionGraph.vertex ->
  ProgramTypes.TransitionGraph.t -> ProgramTypes.TransitionGraph.t
\end{ocamldoccode}
\index{skip-underscorelocation@\verb`skip_location`}
\begin{ocamldocdescription}
Adds transitions to the graph such that every predecessor of the location is correctly connected with every successor of the location,
    making the location obsolete.


\end{ocamldocdescription}




\label{val:Chaining.chainable}\begin{ocamldoccode}
val chainable :
  ProgramTypes.TransitionGraph.t -> ProgramTypes.TransitionGraph.vertex -> bool
\end{ocamldoccode}
\index{chainable@\verb`chainable`}
\begin{ocamldocdescription}
Returns if the specific location is chainable in the graph.


\end{ocamldocdescription}




\label{val:Chaining.chain}\begin{ocamldoccode}
val chain :
  ProgramTypes.TransitionGraph.vertex ->
  ProgramTypes.TransitionGraph.t -> ProgramTypes.TransitionGraph.t
\end{ocamldoccode}
\index{chain@\verb`chain`}
\begin{ocamldocdescription}
Performs a chaining step removing the location from the graph.


\end{ocamldocdescription}




\label{val:Chaining.transform-underscoregraph}\begin{ocamldoccode}
val transform_graph :
  ProgramTypes.TransitionGraph.t ->
  ProgramTypes.TransitionGraph.t MaybeChanged.t
\end{ocamldoccode}
\index{transform-underscoregraph@\verb`transform_graph`}


\section{Module {\tt{InvariantGeneration}}}
\label{module:InvariantGeneration}\index{InvariantGeneration@\verb`InvariantGeneration`}


\ocamldocvspace{0.5cm}



This preprocessor generates invariants for a given program and adds them to the transitions of the program.
    This way more restrictive information is available locally in the transitions.



\label{val:InvariantGeneration.logger}\begin{ocamldoccode}
val logger : Batteries.Logger.log
\end{ocamldoccode}
\index{logger@\verb`logger`}




\begin{ocamldoccode}
{\tt{module }}{\tt{LocationMap}}{\tt{ : }}\end{ocamldoccode}
\label{module:InvariantGeneration.LocationMap}\index{LocationMap@\verb`LocationMap`}

{\tt{Batteries.Hashtbl.Make}}{\tt{(}}{\tt{ProgramTypes.Location}}{\tt{)}}

\begin{ocamldocdescription}
A map from program locations to anything.


\end{ocamldocdescription}




\label{type:InvariantGeneration.program-underscoreabstract}\begin{ocamldoccode}
type {\textquotesingle}a program_abstract = {\textquotesingle}a Apron.Abstract1.t LocationMap.t 
\end{ocamldoccode}
\index{program-underscoreabstract@\verb`program_abstract`}
\begin{ocamldocdescription}
An abstract value for all values of variable at every program location.


\end{ocamldocdescription}




\begin{ocamldoccode}
{\tt{module }}{\tt{Koat2Apron}}{\tt{ : }}\end{ocamldoccode}
\label{module:InvariantGeneration.Koat2Apron}\index{Koat2Apron@\verb`Koat2Apron`}

\begin{ocamldocsigend}


\label{val:InvariantGeneration.Koat2Apron.var-underscoreto-underscoreapron}\begin{ocamldoccode}
val var_to_apron : Var.t -> Apron.Var.t
\end{ocamldoccode}
\index{var-underscoreto-underscoreapron@\verb`var_to_apron`}
\begin{ocamldocdescription}
Converts a koat variable to its apron equivalent.


\end{ocamldocdescription}


\label{val:InvariantGeneration.Koat2Apron.vars-underscoreto-underscoreapron}\begin{ocamldoccode}
val vars_to_apron : VarSet.t -> Apron.Var.t array
\end{ocamldoccode}
\index{vars-underscoreto-underscoreapron@\verb`vars_to_apron`}
\begin{ocamldocdescription}
Converts a koat variable set to its apron equivalent.


\end{ocamldocdescription}


Converts a koat integer to its apron equivalent.

\label{val:InvariantGeneration.Koat2Apron.const-underscoreto-underscoreapron}\begin{ocamldoccode}
val const_to_apron : OurInt.t -> Apron.Coeff.t
\end{ocamldoccode}
\index{const-underscoreto-underscoreapron@\verb`const_to_apron`}
\begin{ocamldocdescription}
TODO Usage of OurInt.to\_int breaks usage of big\_int


\end{ocamldocdescription}


\label{val:InvariantGeneration.Koat2Apron.poly-underscoreto-underscoreapron}\begin{ocamldoccode}
val poly_to_apron :
  Apron.Environment.t -> Polynomials.Polynomial.t -> Apron.Texpr1.t
\end{ocamldoccode}
\index{poly-underscoreto-underscoreapron@\verb`poly_to_apron`}
\begin{ocamldocdescription}
Converts a koat polynomial to its apron equivalent.


\end{ocamldocdescription}


\label{val:InvariantGeneration.Koat2Apron.atom-underscoreto-underscoreapron}\begin{ocamldoccode}
val atom_to_apron : Apron.Environment.t -> Atoms.Atom.t -> Apron.Tcons1.t
\end{ocamldoccode}
\index{atom-underscoreto-underscoreapron@\verb`atom_to_apron`}
\begin{ocamldocdescription}
Converts a koat atom to its apron equivalent


\end{ocamldocdescription}


\label{val:InvariantGeneration.Koat2Apron.constraint-underscoreto-underscoreapron}\begin{ocamldoccode}
val constraint_to_apron :
  Apron.Environment.t -> Constraints.Constraint.t -> Apron.Tcons1.earray
\end{ocamldoccode}
\index{constraint-underscoreto-underscoreapron@\verb`constraint_to_apron`}
\begin{ocamldocdescription}
Converts a koat constraint to its apron equivalent


\end{ocamldocdescription}
\end{ocamldocsigend}


\begin{ocamldocdescription}
This module provides functions which convert koat datastructures to equivalent apron datastructures.


\end{ocamldocdescription}




\begin{ocamldoccode}
{\tt{module }}{\tt{Apron2Koat}}{\tt{ : }}\end{ocamldoccode}
\label{module:InvariantGeneration.Apron2Koat}\index{Apron2Koat@\verb`Apron2Koat`}

\begin{ocamldocsigend}


\label{val:InvariantGeneration.Apron2Koat.var-underscorefrom-underscoreapron}\begin{ocamldoccode}
val var_from_apron : Apron.Var.t -> Var.t
\end{ocamldoccode}
\index{var-underscorefrom-underscoreapron@\verb`var_from_apron`}
\begin{ocamldocdescription}
Converts an apron variable to its koat equivalent.


\end{ocamldocdescription}


\label{val:InvariantGeneration.Apron2Koat.vars-underscorefrom-underscoreapron}\begin{ocamldoccode}
val vars_from_apron : Apron.Var.t array -> VarSet.t
\end{ocamldoccode}
\index{vars-underscorefrom-underscoreapron@\verb`vars_from_apron`}
\begin{ocamldocdescription}
Converts an apron variable set to its koat equivalent.


\end{ocamldocdescription}


Converts an apron integer to its koat equivalent.

\label{val:InvariantGeneration.Apron2Koat.const-underscorefrom-underscoreapron}\begin{ocamldoccode}
val const_from_apron : Apron.Coeff.t -> OurInt.t
\end{ocamldoccode}
\index{const-underscorefrom-underscoreapron@\verb`const_from_apron`}
\begin{ocamldocdescription}
TODO Usage of OurInt.to\_int breaks usage of big\_int


\end{ocamldocdescription}


\label{val:InvariantGeneration.Apron2Koat.poly-underscorefrom-underscoreapron}\begin{ocamldoccode}
val poly_from_apron : Apron.Texpr1.t -> Polynomials.Polynomial.t
\end{ocamldoccode}
\index{poly-underscorefrom-underscoreapron@\verb`poly_from_apron`}
\begin{ocamldocdescription}
Converts an apron polynomial to its koat equivalent.


\end{ocamldocdescription}


\label{val:InvariantGeneration.Apron2Koat.atom-underscorefrom-underscoreapron}\begin{ocamldoccode}
val atom_from_apron : Apron.Tcons1.t -> Constraints.Constraint.t
\end{ocamldoccode}
\index{atom-underscorefrom-underscoreapron@\verb`atom_from_apron`}
\begin{ocamldocdescription}
Converts an apron atom to its koat equivalent


\end{ocamldocdescription}


\label{val:InvariantGeneration.Apron2Koat.constraint-underscorefrom-underscoreapron}\begin{ocamldoccode}
val constraint_from_apron : Apron.Tcons1.earray -> Constraints.Constraint.t
\end{ocamldoccode}
\index{constraint-underscorefrom-underscoreapron@\verb`constraint_from_apron`}
\begin{ocamldocdescription}
Converts a koat constraint to its apron equivalent


\end{ocamldocdescription}
\end{ocamldocsigend}


\begin{ocamldocdescription}
This module provides functions which convert apron datastructures to equivalent koat datastructures.


\end{ocamldocdescription}




\label{val:InvariantGeneration.transform-underscoreprogram}\begin{ocamldoccode}
val transform_program : Program.t -> MaybeChanged.status * Program.t
\end{ocamldoccode}
\index{transform-underscoreprogram@\verb`transform_program`}


\section{Module {\tt{CutUnsatisfiableTransitions}}}
\label{module:CutUnsatisfiableTransitions}\index{CutUnsatisfiableTransitions@\verb`CutUnsatisfiableTransitions`}


\ocamldocvspace{0.5cm}



This preprocessor removes all unsatisfiable transitions from the graph. 
    Those transitions can never be part of an evaluation.
    Note that it only removes the specific transitions. 
    After the transformation the graph might contain unreachable locations, and even locations that are not connected to any transition.



\label{val:CutUnsatisfiableTransitions.logger}\begin{ocamldoccode}
val logger : Batteries.Logger.log
\end{ocamldoccode}
\index{logger@\verb`logger`}




\label{val:CutUnsatisfiableTransitions.unsatisfiable-underscoretransitions}\begin{ocamldoccode}
val unsatisfiable_transitions :
  ProgramTypes.TransitionGraph.t -> ProgramTypes.TransitionSet.t
\end{ocamldoccode}
\index{unsatisfiable-underscoretransitions@\verb`unsatisfiable_transitions`}




\label{val:CutUnsatisfiableTransitions.transform-underscoreprogram}\begin{ocamldoccode}
val transform_program : Program.t -> MaybeChanged.status * Program.t
\end{ocamldoccode}
\index{transform-underscoreprogram@\verb`transform_program`}


\section{Module {\tt{CutUnreachableLocations}}}
\label{module:CutUnreachableLocations}\index{CutUnreachableLocations@\verb`CutUnreachableLocations`}


\ocamldocvspace{0.5cm}



This preprocessor cuts all unreachable locations (and all transitions connected to them) from the program.



\label{val:CutUnreachableLocations.logger}\begin{ocamldoccode}
val logger : Batteries.Logger.log
\end{ocamldoccode}
\index{logger@\verb`logger`}




\begin{ocamldoccode}
{\tt{module }}{\tt{LocationSet}}{\tt{ : }}\end{ocamldoccode}
\label{module:CutUnreachableLocations.LocationSet}\index{LocationSet@\verb`LocationSet`}

{\tt{Batteries.Set.Make}}{\tt{(}}{\tt{ProgramTypes.Location}}{\tt{)}}





\label{val:CutUnreachableLocations.reachable-underscorelocations}\begin{ocamldoccode}
val reachable_locations :
  ProgramTypes.TransitionGraph.t ->
  ProgramTypes.TransitionGraph.V.t -> LocationSet.t
\end{ocamldoccode}
\index{reachable-underscorelocations@\verb`reachable_locations`}
\begin{ocamldocdescription}
Returns a set of all locations which are reachable from the given start location.


\end{ocamldocdescription}




\label{val:CutUnreachableLocations.unreachable-underscorelocations}\begin{ocamldoccode}
val unreachable_locations :
  ProgramTypes.TransitionGraph.t ->
  ProgramTypes.TransitionGraph.V.t -> LocationSet.t
\end{ocamldoccode}
\index{unreachable-underscorelocations@\verb`unreachable_locations`}




\label{val:CutUnreachableLocations.transform-underscoreprogram}\begin{ocamldoccode}
val transform_program : Program.t -> MaybeChanged.status * Program.t
\end{ocamldoccode}
\index{transform-underscoreprogram@\verb`transform_program`}


\section{Module {\tt{Main}} : Main Module}
\label{module:Main}\index{Main@\verb`Main`}




\ocamldocvspace{0.5cm}



\label{type:Main.main-underscoreparams}\begin{ocamldoccode}
type main_params = 
{\char123}  koat2 : string ;
{\char125}
\end{ocamldoccode}
\index{main-underscoreparams@\verb`main_params`}




\label{val:Main.main-underscoreparams-underscorecmdliner-underscoreterm}\begin{ocamldoccode}
val main_params_cmdliner_term : unit -> main_params Cmdliner.Term.t
\end{ocamldoccode}
\index{main-underscoreparams-underscorecmdliner-underscoreterm@\verb`main_params_cmdliner_term`}




\label{val:Main.subcommand}\begin{ocamldoccode}
val subcommand :
  ({\textquotesingle}a -> {\textquotesingle}b) ->
  (unit -> {\textquotesingle}a Cmdliner.Term.t) ->
  string -> string -> {\textquotesingle}b Cmdliner.Term.t * Cmdliner.Term.info
\end{ocamldoccode}
\index{subcommand@\verb`subcommand`}




\label{val:Main.subcommands}\begin{ocamldoccode}
val subcommands : (unit Cmdliner.Term.t * Cmdliner.Term.info) list
\end{ocamldoccode}
\index{subcommands@\verb`subcommands`}




\label{val:Main.default-underscorecmd}\begin{ocamldoccode}
val default_cmd : {\textquotesingle}a -> [> {\textasciigrave}Help of [> {\textasciigrave}Pager ] * {\textquotesingle}b option ]
\end{ocamldoccode}
\index{default-underscorecmd@\verb`default_cmd`}


\section{Module {\tt{NormalizeCommand}}}
\label{module:NormalizeCommand}\index{NormalizeCommand@\verb`NormalizeCommand`}


\ocamldocvspace{0.5cm}



\label{val:NormalizeCommand.description}\begin{ocamldoccode}
val description : string
\end{ocamldoccode}
\index{description@\verb`description`}




\label{val:NormalizeCommand.command}\begin{ocamldoccode}
val command : string
\end{ocamldoccode}
\index{command@\verb`command`}




\label{type:NormalizeCommand.params}\begin{ocamldoccode}
type params = 
{\char123}  kind : [ {\textasciigrave}Atom | {\textasciigrave}Bound | {\textasciigrave}Polynomial ] ;
\end{ocamldoccode}
\begin{ocamldoccomment}
How the input should be interpreted.


\end{ocamldoccomment}
\begin{ocamldoccode}
  input : string ;
\end{ocamldoccode}
\begin{ocamldoccomment}
The input which should be normalized


\end{ocamldoccomment}
\begin{ocamldoccode}
  logs : Logging.logger list ;
\end{ocamldoccode}
\begin{ocamldoccomment}
The loggers which should be activated.


\end{ocamldoccomment}
\begin{ocamldoccode}
{\char125}
\end{ocamldoccode}
\index{params@\verb`params`}




\label{val:NormalizeCommand.params-underscorecmdliner-underscoreterm}\begin{ocamldoccode}
val params_cmdliner_term : unit -> params Cmdliner.Term.t
\end{ocamldoccode}
\index{params-underscorecmdliner-underscoreterm@\verb`params_cmdliner_term`}




\label{val:NormalizeCommand.run}\begin{ocamldoccode}
val run : params -> unit
\end{ocamldoccode}
\index{run@\verb`run`}


\section{Module {\tt{SMTCommand}} : Handles shell arguments and computes a solution for an SMT instance.}
\label{module:SMTCommand}\index{SMTCommand@\verb`SMTCommand`}




\ocamldocvspace{0.5cm}



\begin{ocamldoccode}
{\tt{module }}{\tt{Valuation}}{\tt{ : }}\end{ocamldoccode}
\label{module:SMTCommand.Valuation}\index{Valuation@\verb`Valuation`}

{\tt{Valuation.Make}}{\tt{(}}{\tt{OurInt}}{\tt{)}}





\label{val:SMTCommand.description}\begin{ocamldoccode}
val description : string
\end{ocamldoccode}
\index{description@\verb`description`}




\label{val:SMTCommand.command}\begin{ocamldoccode}
val command : string
\end{ocamldoccode}
\index{command@\verb`command`}




\label{type:SMTCommand.params}\begin{ocamldoccode}
type params = 
{\char123}  constr : string ;
\end{ocamldoccode}
\begin{ocamldoccomment}
The constraint for which a solution should be found.


\end{ocamldoccomment}
\begin{ocamldoccode}
  solver : [ {\textasciigrave}Z3 ] ;
\end{ocamldoccode}
\begin{ocamldoccomment}
The solver which should be used.


\end{ocamldoccomment}
\begin{ocamldoccode}
{\char125}
\end{ocamldoccode}
\index{params@\verb`params`}




\label{val:SMTCommand.params-underscorecmdliner-underscoreterm}\begin{ocamldoccode}
val params_cmdliner_term : unit -> params Cmdliner.Term.t
\end{ocamldoccode}
\index{params-underscorecmdliner-underscoreterm@\verb`params_cmdliner_term`}




\label{val:SMTCommand.pp-underscoreparams}\begin{ocamldoccode}
val pp_params :
  Ppx_deriving_runtime.Format.formatter ->
  params -> Ppx_deriving_runtime.unit
\end{ocamldoccode}
\index{pp-underscoreparams@\verb`pp_params`}




\label{val:SMTCommand.show-underscoreparams}\begin{ocamldoccode}
val show_params : params -> Ppx_deriving_runtime.string
\end{ocamldoccode}
\index{show-underscoreparams@\verb`show_params`}




\label{val:SMTCommand.run}\begin{ocamldoccode}
val run : params -> unit
\end{ocamldoccode}
\index{run@\verb`run`}


\section{Module {\tt{PrfCommand}} : Handles shell arguments and computes ranking functions for a program.}
\label{module:PrfCommand}\index{PrfCommand@\verb`PrfCommand`}




\ocamldocvspace{0.5cm}



\label{val:PrfCommand.description}\begin{ocamldoccode}
val description : string
\end{ocamldoccode}
\index{description@\verb`description`}




\label{val:PrfCommand.command}\begin{ocamldoccode}
val command : string
\end{ocamldoccode}
\index{command@\verb`command`}




\label{type:PrfCommand.params}\begin{ocamldoccode}
type params = 
{\char123}  input : string ;
\end{ocamldoccode}
\begin{ocamldoccomment}
Either an absolute or relative path to the koat input file which defines the integer transition system.
        Or the program defined in simple mode.
        How this string is interpreted is defined by the simple-input flag


\end{ocamldoccomment}
\begin{ocamldoccode}
  simple_input : bool ;
\end{ocamldoccode}
\begin{ocamldoccomment}
If the simple-input flag is set, the input is not interpreted as a filepath, but as a program in simple mode.


\end{ocamldoccomment}
\begin{ocamldoccode}
{\char125}
\end{ocamldoccode}
\index{params@\verb`params`}




\label{val:PrfCommand.params-underscorecmdliner-underscoreterm}\begin{ocamldoccode}
val params_cmdliner_term : unit -> params Cmdliner.Term.t
\end{ocamldoccode}
\index{params-underscorecmdliner-underscoreterm@\verb`params_cmdliner_term`}




\label{val:PrfCommand.pp-underscoreparams}\begin{ocamldoccode}
val pp_params :
  Ppx_deriving_runtime.Format.formatter ->
  params -> Ppx_deriving_runtime.unit
\end{ocamldoccode}
\index{pp-underscoreparams@\verb`pp_params`}




\label{val:PrfCommand.show-underscoreparams}\begin{ocamldoccode}
val show_params : params -> Ppx_deriving_runtime.string
\end{ocamldoccode}
\index{show-underscoreparams@\verb`show_params`}




\label{val:PrfCommand.run}\begin{ocamldoccode}
val run : params -> unit
\end{ocamldoccode}
\index{run@\verb`run`}


\section{Module {\tt{SizeCommand}} : Handles shell arguments and computes a size-bounds for a program.}
\label{module:SizeCommand}\index{SizeCommand@\verb`SizeCommand`}




\ocamldocvspace{0.5cm}



\label{val:SizeCommand.description}\begin{ocamldoccode}
val description : string
\end{ocamldoccode}
\index{description@\verb`description`}




\label{val:SizeCommand.command}\begin{ocamldoccode}
val command : string
\end{ocamldoccode}
\index{command@\verb`command`}




\label{type:SizeCommand.params}\begin{ocamldoccode}
type params = 
{\char123}  program : string ;
\end{ocamldoccode}
\begin{ocamldoccomment}
The file of the program which should be analyzed.


\end{ocamldoccomment}
\begin{ocamldoccode}
{\char125}
\end{ocamldoccode}
\index{params@\verb`params`}




\label{val:SizeCommand.params-underscorecmdliner-underscoreterm}\begin{ocamldoccode}
val params_cmdliner_term : unit -> params Cmdliner.Term.t
\end{ocamldoccode}
\index{params-underscorecmdliner-underscoreterm@\verb`params_cmdliner_term`}




\label{val:SizeCommand.pp-underscoreparams}\begin{ocamldoccode}
val pp_params :
  Ppx_deriving_runtime.Format.formatter ->
  params -> Ppx_deriving_runtime.unit
\end{ocamldoccode}
\index{pp-underscoreparams@\verb`pp_params`}




\label{val:SizeCommand.show-underscoreparams}\begin{ocamldoccode}
val show_params : params -> Ppx_deriving_runtime.string
\end{ocamldoccode}
\index{show-underscoreparams@\verb`show_params`}




\label{val:SizeCommand.run}\begin{ocamldoccode}
val run : params -> unit
\end{ocamldoccode}
\index{run@\verb`run`}


\section{Module {\tt{LocalSizeBoundCommand}} : Handles shell arguments and computes for a guard and a specified variable a lower/upper local size-bound.}
\label{module:LocalSizeBoundCommand}\index{LocalSizeBoundCommand@\verb`LocalSizeBoundCommand`}




\ocamldocvspace{0.5cm}



\label{val:LocalSizeBoundCommand.description}\begin{ocamldoccode}
val description : string
\end{ocamldoccode}
\index{description@\verb`description`}




\label{val:LocalSizeBoundCommand.command}\begin{ocamldoccode}
val command : string
\end{ocamldoccode}
\index{command@\verb`command`}




\label{type:LocalSizeBoundCommand.params}\begin{ocamldoccode}
type params = 
{\char123}  kind : [ {\textasciigrave}Lower | {\textasciigrave}Upper ] ;
\end{ocamldoccode}
\begin{ocamldoccomment}
Which type of bound is requested. Available options: upper and lower.


\end{ocamldoccomment}
\begin{ocamldoccode}
  guard : string ;
\end{ocamldoccode}
\begin{ocamldoccomment}
The guard of the transition in the form of a constraint.
        That is a formula with and-separators (\&\&) and or-separators ({\textbar}{\textbar}).
        Atoms are two polynomials in a relation with $<$, $>$, $\leq$, $\geq$ or $=$.


\end{ocamldoccomment}
\begin{ocamldoccode}
  var : string ;
\end{ocamldoccode}
\begin{ocamldoccomment}
The variable for which a local size bound should be found.


\end{ocamldoccomment}
\begin{ocamldoccode}
{\char125}
\end{ocamldoccode}
\index{params@\verb`params`}




\label{val:LocalSizeBoundCommand.params-underscorecmdliner-underscoreterm}\begin{ocamldoccode}
val params_cmdliner_term : unit -> params Cmdliner.Term.t
\end{ocamldoccode}
\index{params-underscorecmdliner-underscoreterm@\verb`params_cmdliner_term`}




\label{val:LocalSizeBoundCommand.pp-underscoreparams}\begin{ocamldoccode}
val pp_params :
  Ppx_deriving_runtime.Format.formatter ->
  params -> Ppx_deriving_runtime.unit
\end{ocamldoccode}
\index{pp-underscoreparams@\verb`pp_params`}




\label{val:LocalSizeBoundCommand.show-underscoreparams}\begin{ocamldoccode}
val show_params : params -> Ppx_deriving_runtime.string
\end{ocamldoccode}
\index{show-underscoreparams@\verb`show_params`}




\label{val:LocalSizeBoundCommand.run}\begin{ocamldoccode}
val run : params -> unit
\end{ocamldoccode}
\index{run@\verb`run`}


\section{Module {\tt{AnalyseCommand}} : Handles shell arguments and computes an upper time-bound.}
\label{module:AnalyseCommand}\index{AnalyseCommand@\verb`AnalyseCommand`}




\ocamldocvspace{0.5cm}



\label{val:AnalyseCommand.command}\begin{ocamldoccode}
val command : string
\end{ocamldoccode}
\index{command@\verb`command`}




\label{val:AnalyseCommand.description}\begin{ocamldoccode}
val description : string
\end{ocamldoccode}
\index{description@\verb`description`}




\label{val:AnalyseCommand.print-underscoreall-underscorebounds}\begin{ocamldoccode}
val print_all_bounds : Program.t -> Approximation.t -> unit
\end{ocamldoccode}
\index{print-underscoreall-underscorebounds@\verb`print_all_bounds`}
\begin{ocamldocdescription}
Prints the whole resulting approximation to the shell.


\end{ocamldocdescription}




\label{val:AnalyseCommand.print-underscoreoverall-underscoretimebound}\begin{ocamldoccode}
val print_overall_timebound : Program.t -> Approximation.t -> unit
\end{ocamldoccode}
\index{print-underscoreoverall-underscoretimebound@\verb`print_overall_timebound`}
\begin{ocamldocdescription}
Prints the overall timebound of the program to the shell.


\end{ocamldocdescription}




\label{val:AnalyseCommand.print-underscoretermcomp}\begin{ocamldoccode}
val print_termcomp : Program.t -> Approximation.t -> unit
\end{ocamldoccode}
\index{print-underscoretermcomp@\verb`print_termcomp`}
\begin{ocamldocdescription}
Prints the overall timebound of the program to the shell in the TermComp fashion.


\end{ocamldocdescription}




\label{type:AnalyseCommand.params}\begin{ocamldoccode}
type params = 
{\char123}  print_system : bool ;
\end{ocamldoccode}
\begin{ocamldoccomment}
Prints the integer transition system at the start as png


\end{ocamldoccomment}
\begin{ocamldoccode}
  print_rvg : bool ;
\end{ocamldoccode}
\begin{ocamldoccomment}
Prints the input result variable graph at the start as png


\end{ocamldoccomment}
\begin{ocamldoccode}
  print_input : bool ;
\end{ocamldoccode}
\begin{ocamldoccomment}
Prints the raw unmodified input before the start


\end{ocamldoccomment}
\begin{ocamldoccode}
  no_boundsearch : bool ;
\end{ocamldoccode}
\begin{ocamldoccomment}
Disables the search for bounds. Useful if you just want information about the integer transition system via the other options or for debugging purposes.


\end{ocamldoccomment}
\begin{ocamldoccode}
  input : string option ;
\end{ocamldoccode}
\begin{ocamldoccomment}
Either an absolute or relative path to the koat input file which defines the integer transition system.
        Or the program defined in simple mode.
        How this string is interpreted is defined by the simple-input flag


\end{ocamldoccomment}
\begin{ocamldoccode}
  simple_input : bool ;
\end{ocamldoccode}
\begin{ocamldoccomment}
If the simple-input flag is set, the input is not interpreted as a filepath, but as a program in simple mode.


\end{ocamldoccomment}
\begin{ocamldoccode}
  output_dir : string option ;
\end{ocamldoccode}
\begin{ocamldoccomment}
An absolute or relative path to the output directory, where all generated files should end up.


\end{ocamldoccomment}
\begin{ocamldoccode}
  logs : Logging.logger list ;
\end{ocamldoccode}
\begin{ocamldoccomment}
The loggers which should be activated.


\end{ocamldoccomment}
\begin{ocamldoccode}
  log_level : Batteries.Logger.level ;
\end{ocamldoccode}
\begin{ocamldoccomment}
The general log level of the loggers.


\end{ocamldoccomment}
\begin{ocamldoccode}
  result : Program.t -> Approximation.t -> unit ;
\end{ocamldoccode}
\begin{ocamldoccomment}
The kind of output which is deserved. The option "all" prints all time- and sizebounds found in the whole program, the option "overall" prints only the sum of all timebounds. The option "termcomp" prints the approximated complexity class.


\end{ocamldoccomment}
\begin{ocamldoccode}
  preprocessors : Preprocessor.t list ;
\end{ocamldoccode}
\begin{ocamldoccomment}
The preprocessors which should be applied before running the actual algorithm.


\end{ocamldoccomment}
\begin{ocamldoccode}
  preprocessing_strategy : Preprocessor.strategy ;
\end{ocamldoccode}
\begin{ocamldoccomment}
The strategy which should be used to apply the preprocessors.


\end{ocamldoccomment}
\begin{ocamldoccode}
  rename : bool ;
\end{ocamldoccode}
\begin{ocamldoccomment}
If the location names should be normalized to simplified names.


\end{ocamldoccomment}
\begin{ocamldoccode}
  multiphaserankingfunctions : bool ;
\end{ocamldoccode}
\begin{ocamldoccomment}
Has to be set to true if multiphaserankingfunctions should be used.


\end{ocamldoccomment}
\begin{ocamldoccode}
  depth : int ;
\end{ocamldoccode}
\begin{ocamldoccomment}
The maximum depth of a Multiphase Ranking Function to bound search space.


\end{ocamldoccomment}
\begin{ocamldoccode}
  cfr : bool ;
\end{ocamldoccode}
\begin{ocamldoccomment}
True iff control flow refinement should be applied


\end{ocamldoccomment}
\begin{ocamldoccode}
{\char125}
\end{ocamldoccode}
\index{params@\verb`params`}
\begin{ocamldocdescription}
The shell arguments which can be defined in the console.


\end{ocamldocdescription}




\label{val:AnalyseCommand.params-underscorecmdliner-underscoreterm}\begin{ocamldoccode}
val params_cmdliner_term : unit -> params Cmdliner.Term.t
\end{ocamldoccode}
\index{params-underscorecmdliner-underscoreterm@\verb`params_cmdliner_term`}




\label{val:AnalyseCommand.bounded-underscorelabel-underscoreto-underscorestring}\begin{ocamldoccode}
val bounded_label_to_string : Approximation.t -> TransitionLabel.t -> string
\end{ocamldoccode}
\index{bounded-underscorelabel-underscoreto-underscorestring@\verb`bounded_label_to_string`}
\begin{ocamldocdescription}
Returns a string containing a time-bound and the label of a transition for a specified approximation.


\end{ocamldocdescription}




\label{val:AnalyseCommand.bounded-underscorerv-underscoreto-underscorestring}\begin{ocamldoccode}
val bounded_rv_to_string :
  Program.t ->
  Approximation.kind ->
  Approximation.t -> ProgramTypes.Transition.t * Var.t -> string
\end{ocamldoccode}
\index{bounded-underscorerv-underscoreto-underscorestring@\verb`bounded_rv_to_string`}
\begin{ocamldocdescription}
Returns a string containing a size-bound transition and a result variable for a specified approximation.


\end{ocamldocdescription}




\label{val:AnalyseCommand.get-underscorelsb}\begin{ocamldoccode}
val get_lsb :
  Program.t ->
  [ {\textasciigrave}Lower | {\textasciigrave}Upper ] -> ProgramTypes.Transition.t * Var.t -> Bound.t
\end{ocamldoccode}
\index{get-underscorelsb@\verb`get_lsb`}
\begin{ocamldocdescription}
Returns a local size-bound for a specified transition and a specified variable.


\end{ocamldocdescription}




\label{val:AnalyseCommand.standard-underscorevars}\begin{ocamldoccode}
val standard_vars : Program.t -> Var.t list
\end{ocamldoccode}
\index{standard-underscorevars@\verb`standard_vars`}
\begin{ocamldocdescription}
Returns a list of special variables which are arguments of the transition system.


\end{ocamldocdescription}




\label{val:AnalyseCommand.rename-underscoregraph}\begin{ocamldoccode}
val rename_graph :
  Var.t list ->
  ProgramTypes.TransitionGraph.t -> ProgramTypes.TransitionGraph.t
\end{ocamldoccode}
\index{rename-underscoregraph@\verb`rename_graph`}
\begin{ocamldocdescription}
For each transition rename standard\_vars transition.


\end{ocamldocdescription}




\label{val:AnalyseCommand.rename-underscoreprogram}\begin{ocamldoccode}
val rename_program : Program.t -> Program.t
\end{ocamldoccode}
\index{rename-underscoreprogram@\verb`rename_program`}
\begin{ocamldocdescription}
Provides renamed program


\end{ocamldocdescription}




\label{val:AnalyseCommand.rename-underscoreprogram-underscoreoption}\begin{ocamldoccode}
val rename_program_option : Program.t option -> Program.t option
\end{ocamldoccode}
\index{rename-underscoreprogram-underscoreoption@\verb`rename_program_option`}
\begin{ocamldocdescription}
Provides renamed program if program is set, else None is returned.


\end{ocamldocdescription}




\label{val:AnalyseCommand.run}\begin{ocamldoccode}
val run : params -> unit
\end{ocamldoccode}
\index{run@\verb`run`}
\begin{ocamldocdescription}
Runs KoAT2 on provided parameters.


\end{ocamldocdescription}


\end{document}
