theory Algebraic
  imports
    Algebraic_Numbers.Algebraic_Numbers_External_Code
    Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly    
    Cubic_Quartic_Equations.Complex_Roots
    Jordan_Normal_Form.Jordan_Normal_Form_Existence
    Jordan_Normal_Form.Jordan_Normal_Form_Uniqueness
    Jordan_Normal_Form.Schur_Decomposition
begin

definition complex_roots_of_complex_poly :: "complex list \<Rightarrow> complex list" where
  "complex_roots_of_complex_poly = roots_of_complex_poly o poly_of_list" 

definition complex_roots_of_real_poly :: "real_alg list \<Rightarrow> complex list" where
  "complex_roots_of_real_poly = complex_roots_of_complex_poly o map (\<lambda> r. of_real_imag_ca (r,0))" 

definition complex_roots_of_rational_poly :: "(integer \<times> integer)list \<Rightarrow> complex list" where
  "complex_roots_of_rational_poly = complex_roots_of_rat_poly o poly_of_list o map 
     (\<lambda> (n,d). rat_of_int (int_of_integer n) / rat_of_int (int_of_integer d))" 

definition complex_roots_of_integer_poly :: "integer list \<Rightarrow> complex list" where
  "complex_roots_of_integer_poly = complex_roots_of_int_poly o poly_of_list o map int_of_integer" 

definition croot_ca :: "integer \<Rightarrow> complex \<Rightarrow> complex" where
  "croot_ca = croot o nat_of_integer" 

export_code 

  (* preliminary operations *)
  order.Eq order.Lt order.Gt \<comment> \<open>for comparison\<close>
  Inl Inr \<comment> \<open>make disjoint sums available for decomposition information\<close>

  (* real algebraic operations *)
  zero_ra
  one_ra
  of_integer_ra
  of_rational_ra
  plus_ra
  minus_ra
  uminus_ra
  times_ra
  divide_ra
  inverse_ra
  abs_ra
  floor_ra
  ceiling_ra
  minimum_ra
  maximum_ra
  equals_ra
  less_ra
  less_equal_ra
  compare_ra  
  root_ra
  show_ra
  is_rational_ra
  to_rational_ra
  sign_ra
  decompose_ra

  (* complex algebraic operations *)
  zero_ca
  one_ca
  imag_unit_ca
  of_integer_ca
  of_rational_ca
  of_real_imag_ca
  plus_ca
  minus_ca
  uminus_ca
  times_ca
  divide_ca
  inverse_ca
  equals_ca
  csqrt_ca
  croot_ca
  show_ca
  real_of_ca
  imag_of_ca

  (* roots of algebraic polynomials *)

  complex_roots_of_integer_poly  
  complex_roots_of_rational_poly
  complex_roots_of_real_poly
  complex_roots_of_complex_poly

in OCaml module_name Algebraic 

(* Eigenvalues char poly  *)

definition schur_upper_triangular_new :: "'a::conjugatable_field mat \<Rightarrow> 'a list \<Rightarrow> 'a mat \<times> 'a mat \<times> 'a mat" where 
  "schur_upper_triangular_new A es = (case schur_decomposition A es of (B,P,Q) \<Rightarrow> (B,P,Q))"

value[code] "schur_upper_triangular_new (mat_of_rows_list 3 [[1,-5,8],[1,-2,1],[2,-1,-5 :: rat]]) [-7,1,0]"

value[code] "jordan_nf_via_factored_charpoly (mat_of_rows_list 3 [
  [2,0,0], 
  [0,2,1], 
  [0,0,2 :: rat]]) [2]"

value[code] "compute_set_of_jordan_blocks (mat_of_rows_list 3 [
  [2,0,0], 
  [0,2,1], 
  [0,0,2 :: rat]]) 2" 

end