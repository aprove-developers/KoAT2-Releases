\subsection{Complexity}

In this section we define the terms of runtime, cost and size complexity.
Runtime complexity describes how many steps an evaluation of a program will take in a worst-case szenario.
The costs of a transition are not considered in this complexity type.
On the other hand cost complexity does consider the costs of transitions and describes the cost of the sequence of transitions taken in a worst-case run.
The third complexity type we need is size complexity.
Size complexity yields for each transition an assignment \todo{Correct?}{from each variable to its maximum value} after the execution of the transition in an arbitrary run.

\subsubsection{Bounds}

In our setup we need a definition of the kind of bounds we want to compute.

\begin{definition}[Bound set]
  The set $\BoundSet$ of possible bounds is the smallest set with
  \[ \inf \in \BoundSet \]
  \[ \mathbb{N} \subset \BoundSet \] 
  \[ \VSet \subset \BoundSet \] 
  \[ -b \in \BoundSet \text{ for all } b \in \BoundSet \] 
  \[ b_1 + b_2 \in \BoundSet \text{ for all } b_1, b_2 \in \BoundSet \] 
  \[ b_1 \cdot b_2 \in \BoundSet \text{ for all } b_1, b_2 \in \BoundSet \] 
  \[ \max(b_1, b_2) \in \BoundSet \text{ for all } b_1, b_2 \in \BoundSet \]
  \[ k^b \in \BoundSet \text{ for all } k \in \mathbb{N}, b \in \BoundSet \]
\end{definition}

We use $\inf$ to represent infinity.
Together with the defined negation we can also represent minus infinity by $-\inf$.
This is not necessary for time bounds, since time bounds are only allowed to be positive.
But we use this for lower size bounds, where $-\inf$ is a valid lower size bound for every possible evaluation.

We include numbers from $\mathbb{N}$.
All numbers from $\mathbb{Z}$ are also in in the bound set $\BoundSet$, since for each number $n \in \mathbb{N}$ its negation $-n$ is element of the bound set $\BoundSet$.
As the third base component we add the program variables $\VSet$ to the bound set $\BoundSet$.

We define the usual addition $+$ and multiplication $\cdot$ between two bounds.
The maximum operator $\max$ is also included with the common meaning.
Note that the bound $-\max(-b_1,-b_2)$ is also included in the bound set $\BoundSet$ and that we therefore also have a representation of $\min(b_1,b_2)$.
Also note that for a set of bounds $S \subseteq \BoundSet$ we denote with $\max S$ the maximum value of the whole set.
For an empty set of bounds $S = \emptyset$ we define $\max S$ to be $-\inf$.

For the representation of exponential bounds we include $k^b$ for all positive integers $k \in \mathbb{N}$ and all bounds $b \in \BoundSet$.
Therefore we do not allow arbitrary exponentation.

\todo{Examples}{}

We will now formally introduce an evaluation operation on all elements of the bound set.

\begin{definition}[Bound evaluation]
  For a bound $b \in \BoundSet$ and a state $\valuation \in \VSet \rightarrow \mathbb{Z}_\bot$ we define $\eval{b}{\valuation}$ to denote the evaluation of the bound $b$ to a value in $\mathbb{Z}_\bot$.
  \[ \eval{\inf}{\valuation} = \bot \text{ for } \inf \in \BoundSet \] \todo{Really bot?}
  \[ \eval{k}{\valuation} = k \text{ for all } k \in \mathbb{N} \subset \BoundSet \] 
  \[ \eval{v}{\valuation} = \valuation(v) \text{ for all } v \in \VSet \subset \BoundSet \] 
  \[ \eval{-b}{\valuation} = -\eval{b}{\valuation} \text{ for all } b \in \BoundSet \] 
  \[ \eval{b_1 + b_2}{\valuation} = \eval{b_1}{\valuation} + \eval{b_2}{\valuation} \text{ for all } b_1, b_2 \in \BoundSet \] 
  \[ \eval{b_1 \cdot b_2}{\valuation} = \eval{b_1}{\valuation} \cdot \eval{b_2}{\valuation} \text{ for all } b_1, b_2 \in \BoundSet \] 
  \[ \eval{\max(b_1, b_2)}{\valuation} = \max(\eval{b_1}{\valuation}, \eval{b_2}{\valuation}) \text{ for all } b_1, b_2 \in \BoundSet \]
  \[ \eval{k^b}{\valuation} = k^{\eval{b}{\valuation}} \text{ for all } k \in \mathbb{N} \subset \BoundSet, b \in \BoundSet \]  
  For a bound $b \in \BoundSet$ and a bound assignment $\valuation \in \VSet \rightarrow \BoundSet$ we write $\eval{b}{\valuation}$ to denote the substitution of every variable $v$ of the bound $b$ with the appropriate value $\valuation(v) \in \BoundSet$.
\end{definition}

\subsubsection{Runtime Complexity}

\begin{definition}[Worst-Case Runtime Complexity]
  We call $\text{rc} \in \BoundSet$ the time complexity of a program if and only if for all $m \in \Valuation$ it holds that
  \[ \text{rc}(m) = \sup \braced{ k \in \mathbb{N} \mid \exists \valuation_0, \location, \valuation: \abs{\valuation_0} \leq m \wedge (\location_0, \valuation_0) \rightarrow^k (\location, \valuation) } \]
\end{definition}

\begin{definition}[Upper Runtime Bound]
  We call $\UTime: \TSet \rightarrow \BoundSet$ a time bound if and only if for all $t \in \TSet$ and all $m \in \Valuation$ it holds that
  \[ \UTime(t)(m) \geq \sup \braced{ k \mid \exists k \in \mathbb{N}, \valuation_0, \location, \valuation: \abs{\valuation_0} \leq m \wedge (\location_0, \valuation_0) (\rightarrow^* \circ \rightarrow_t)^k (\location, \valuation) } \]
\end{definition}

\begin{theorem}[Approximating Runtime Complexity]
	Let $\UTime$ be a runtime approximation for $\TSet$.
	Then it holds that 
	\[ \mathit{rc} \leq \sum_{t \in \TSet}\UTime(t) \]
\end{theorem}

\subsubsection{Cost Complexity}

\begin{definition}[Worst-Case Cost Complexity]
\[ \text{cc}(m) = \sup \braced{ \sum_{0 \leq i \leq k} c(t_i)(\valuation_i) \mid \exists k \geq 1, \valuation_0, \location, \valuation: \abs{\valuation_0} \leq m \wedge
  (\location_0, \valuation_0) \rightarrow_{t_0} (\location_1, \valuation_1) \rightarrow_{t_1} \dots \rightarrow_{t_k} (\location_k, \valuation_k) } \]
\end{definition}

\begin{definition}[Upper Cost Bound]
  \[ \UCost(t)(m) =
  \begin{cases}
    \UTime(t) \cdot \maxO{c(t)} & \text{if } t \text{ is an initial transition} \\
    \UTime(t) \cdot \maxO{\maximum{(c(t)_+)(\USize(\tilde{t})) - (c(t)_-)(\LSize(\tilde{t})) \mid \tilde{t} \in \pre(t)}} & \text{otherwise}
  \end{cases}
  \]
\end{definition}

\begin{theorem}[Approximating Cost Complexity]
	Let $\UCost$ be a cost approximation for $\TSet$.
	Then it holds that 
	\[ \mathit{cc} \leq \sum_{t \in \TSet} \UCost(t) \]
\end{theorem}

\subsubsection{Size complexity}

A size bound of a program approximates the extreme value of each variable at a particular transition in a worst-case evaluation.
We distinguish between upper size bounds and lower size bounds.
While upper size bounds are always higher than the highest possible values at a transition, lower size bounds are always smaller than the lowest possible values.

\begin{definition}[Worst-Case Size Bound]
  We call $\USize: \RV \rightarrow \BoundSet$ an \textbf{upper} size bound if and only if for all $(t, v) \in \RV$ and all \todo{Correct, not to use m here?}{$\valuation \in \Valuation$} it holds that
  \[ \eval{\USize(t, v)}{\valuation_0} \geq \sup \braced{\valuation(v) \mid \exists \location, \valuation: (\location_0, \valuation_0) (\rightarrow^* \circ \rightarrow_t) (\location, \valuation)}. \]
  Furthermore, we call $\LLSB: \RV \rightarrow \BoundSet$ a \textbf{lower} size bound if and only if for all $(t, v) \in \RV$ and all $\valuation$ it holds that
  \[ \eval{\LSize(t, v)}{\valuation_0} \geq \inf \braced{\valuation(v) \mid \exists \location, \valuation: (\location_0, \valuation_0) (\rightarrow^* \circ \rightarrow_t) (\location, \valuation)}. \]
  We call $\Size$ a size bound.
\end{definition}

Note that for a transition $t = (\location,\tau,\location') \in \TSet$ with a condition $\tau = (x' = x)$, the upper size bound $\USize(t,x) = x$ is identical to the lower size bound $\LSize(t,x) = x$.
We have different upper and lower size bounds if we have further restrictions on the incoming variables.
For $\tau = (x' = x \wedge x \geq 0)$ we can determine $\USize(t,x) = x$ as an upper bound and $\USize(t,x) = 0$ as a lower bound.

The presented definition of size bounds expresses a bound depending on the values at the start of the program.
For the definition of the methods for the computation of trivial and nontrivial size bounds we also need a definition of bounds depending on the values immediately before the execution of a transition.
We then use those local size bounds to lift them in higher contexts like the whole program.

\begin{definition}[Local Sizebound]
  We call $\ULSB: \RV \rightarrow \BoundSet$ an \textbf{upper} local size bound if and only if for all $(t, v) \in \RV$ and all \todo{Correct, not to use m here?}{$\valuation$} it holds that
  \[ \eval{\ULSB(t, v)}{\valuation} \geq \sup \braced{\valuation'(v) \mid \exists \valuation': \valuation \rightarrow_t \valuation'}. \]
  Furthermore, we call $\LLSB: \RV \rightarrow \BoundSet$ a \textbf{lower} local size bound if and only if for all $(t, v') \in \RV$ and all $\valuation$ it holds that
  \[ \eval{\LLSB(t, v)}{\valuation} \geq \inf \braced{\valuation'(v) \mid \exists \valuation': \valuation \rightarrow_t \valuation'}. \]
  We call $\LSB$ a local size bound.
\end{definition}

\todo{Example for the difference between local and global}
