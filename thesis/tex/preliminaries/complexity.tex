\subsection{Complexity}

In this section we define the terms of runtime, cost and size complexity.
Runtime complexity describes how many steps an evaluation of a program will take in a worst-case szenario.
The costs of a transition are not considered in this complexity type.
On the other hand cost complexity does consider the costs of transitions and describes the cost of the sequence of transitions taken in a worst-case run.
The third complexity type we need is size complexity.
Size complexity yields for each transition an assignment \todo{Correct?}{from each variable to its maximum value} after the execution of the transition in an arbitrary run.

\subsubsection{Runtime Complexity}

\begin{definition}[Worst-Case Runtime Complexity]
  We call $\text{rc} \in \BoundSet$ the time complexity of a program if and only if for all $m \in \Valuation$ it holds that
  \[ \text{rc}(m) = \sup \braced{ k \in \mathbb{N} \mid \exists \valuation_0, \location, \valuation: \abs{\valuation_0} \leq m \wedge (\location_0, \valuation_0) \rightarrow^k (\location, \valuation) } \]
\end{definition}

\begin{definition}[Upper Runtime Bound]
  We call $\UTime: \TSet \rightarrow \BoundSet$ a time bound if and only if for all $t \in \TSet$ and all $m \in \Valuation$ it holds that
  \[ \UTime(t)(m) \geq \sup \braced{ k \mid \exists k \in \mathbb{N}, \valuation_0, \location, \valuation: \abs{\valuation_0} \leq m \wedge (\location_0, \valuation_0) (\rightarrow^* \circ \rightarrow_t)^k (\location, \valuation) } \]
\end{definition}

\begin{theorem}[Approximating Runtime Complexity]
	Let $\UTime$ be a runtime approximation for $\TSet$.
	Then it holds that 
	\[ \mathit{rc} \leq \sum_{t \in \TSet}\UTime(t) \]
\end{theorem}

\subsubsection{Cost Complexity}

\begin{definition}[Worst-Case Cost Complexity]
\[ \text{cc}(m) = \sup \braced{ \sum_{0 \leq i \leq k} \eval{\cost(t_i)}{\valuation_i} \mid \exists k \geq 1, \valuation_0, \location, \valuation: \abs{\valuation_0} \leq m \wedge
  (\location_0, \valuation_0) \rightarrow_{t_0} (\location_1, \valuation_1) \rightarrow_{t_1} \dots \rightarrow_{t_k} (\location_k, \valuation_k) } \]
\end{definition}

\begin{definition}[Upper Cost Bound]
  \[ \UCost(t)(m) =
  \begin{cases}
    \UTime(t) \cdot \maxO{\cost(t)} & \text{if } t \text{ is an initial transition} \\
    \UTime(t) \cdot \maxO{\maximum{\eval{\cost(t)_+}{\USize(\tilde{t})} - \eval{\cost(t)_-}{\LSize(\tilde{t})} \mid \tilde{t} \in \pre(t)}} & \text{otherwise}
  \end{cases}
  \]
\end{definition}

\begin{theorem}[Approximating Cost Complexity]
	Let $\UCost$ be a cost approximation for $\TSet$.
	Then it holds that 
	\[ \mathit{cc} \leq \sum_{t \in \TSet} \UCost(t) \]
\end{theorem}

\subsubsection{Size complexity}

A size bound of a program approximates the extreme value of each variable at a particular transition in a worst-case evaluation.
We distinguish between upper size bounds and lower size bounds.
While upper size bounds are always higher than the highest possible values at a transition, lower size bounds are always smaller than the lowest possible values.

\begin{definition}[Worst-Case Size Bound]
  We call $\USize: \RV \rightarrow \BoundSet$ an \textbf{upper} size bound if and only if for all $(t, v) \in \RV$ and all \todo{Correct, not to use m here?}{$\valuation \in \Valuation$} it holds that
  \[ \eval{\USize(t, v)}{\valuation_0} \geq \sup \braced{\valuation(v) \mid \exists \location, \valuation: (\location_0, \valuation_0) (\rightarrow^* \circ \rightarrow_t) (\location, \valuation)}. \]
  Furthermore, we call $\LLSB: \RV \rightarrow \BoundSet$ a \textbf{lower} size bound if and only if for all $(t, v) \in \RV$ and all $\valuation$ it holds that
  \[ \eval{\LSize(t, v)}{\valuation_0} \geq \inf \braced{\valuation(v) \mid \exists \location, \valuation: (\location_0, \valuation_0) (\rightarrow^* \circ \rightarrow_t) (\location, \valuation)}. \]
  We call $\Size$ a size bound.
\end{definition}

Note that for a transition $t = (\location,\text{id},\guard,\location') \in \TSet$, the upper size bound $\USize(t,x) = x$ is identical to the lower size bound $\LSize(t,x) = x$.
We have different upper and lower size bounds if we have further restrictions on the incoming variables.
With $\guard = \braced{x \geq 0}$ we can determine $\USize(t,x) = x$ as an upper bound and $\USize(t,x) = 0$ as a lower bound.

The presented definition of size bounds expresses a bound depending on the values at the start of the program.
For the definition of the methods for the computation of trivial and nontrivial size bounds we also need a definition of bounds depending on the values immediately before the execution of a transition.
We then use those local size bounds to lift them in higher contexts like the whole program.

\begin{definition}[Local Sizebound]
  We call $\ULSB: \RV \rightarrow \BoundSet$ an \textbf{upper} local size bound if and only if for all $(t, v) \in \RV$ and all \todo{Correct, not to use m here?}{$\valuation$} it holds that
  \[ \eval{\ULSB(t, v)}{\valuation} \geq \sup \braced{\valuation'(v) \mid \exists \valuation': \valuation \rightarrow_t \valuation'}. \]
  Furthermore, we call $\LLSB: \RV \rightarrow \BoundSet$ a \textbf{lower} local size bound if and only if for all $(t, v') \in \RV$ and all $\valuation$ it holds that
  \[ \eval{\LLSB(t, v)}{\valuation} \geq \inf \braced{\valuation'(v) \mid \exists \valuation': \valuation \rightarrow_t \valuation'}. \]
  We call $\LSB$ a local size bound.
\end{definition}

\todo{Example for the difference between local and global}
