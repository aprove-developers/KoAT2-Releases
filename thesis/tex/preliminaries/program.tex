\subsection{Programs}

This section defines the term of a program.
In this master's thesis, we consider programs with the following properties.

\begin{itemize}
\item Sequential: All operations get executed one after the other
\item Imperative: Program state is changed by statements
\item Non-recursive: Recursive function calls are not allowed
\item Mathematical integers: The variables have values from the mathematical integer domain $\mathbb{Z}$
\item Non-determinism: From a state we can enter non-deterministically multiple other states and variables can be assigned non-deterministic variables
\item No heap usage: All values are directly accessed and not referenced
\end{itemize}

All these properties are common in related work.
Note that using imperative programs is not a restriction, since \todo{Source?}{every functional and logic program can be transformed into an imperative program.}
There also exist related work which extends the analysis to bit-vector arithmetic instead of mathematical integers from $\mathbb{Z}$. \cite{bitvectorarithmetic}

In related work as well as in this thesis, it is common to consider non-exact programs.
This is necessary, since the analyzed programs are often abstractions of other programs, which are using a heap.
\todo{Maybe an example}{}

\todo{Example: Cartesian product with filter of (x,x)?}{}

We now formally define the programs used in this thesis.

\begin{definition}[Program] 
  Let $\VSet$ be the set of all occurring program variables.
  Let $\TVSet$ be a finite set of temporary variables with $\TVSet \cap \VSet = \emptyset$.
  A configuration is a pair $(\location, \valuation) \in \LSet \times \Valuation$ that defines the values of the program variables at a specific location.
  A state is a function $\valuation: (\VSet \cup \TVSet) \rightarrow \mathbb{Z}$ which assigns each program variable $v \in \VSet$ a value $\valuation(v) \in \mathbb{Z}$.
  We write $\Valuation = \braced{ \valuation \mid \valuation: (\VSet \cup \TVSet) \rightarrow \mathbb{Z}}$ to denote the set of all states.
  Let $\LSet$ be the set of all locations of a program.
  Let $\TSet = \LSet \times (\VSet \rightarrow \BoundSet_p(\VSet \cup \TVSet)) \times \ConstraintSet(\VSet \cup \TVSet) \times \LSet$ be the set of all transitions of the program.
  A transition $t = (\location, \update, \guard, \location')$ consists of the start location $\location$, the target location $\location'$, the update function $\update$ and the guard $\guard$. 
  A program graph is a tuple $(\LSet, \TSet)$ where $\LSet$ is the set of program locations and $\TSet$ is a subset of all possible transitions between them.
  Let $\cost: \TSet \rightarrow \BoundSet(\PVSet)$ be a function which maps each transition to its costs with a specific state.
  A program is a tuple $\Program = ((\LSet, \TSet), \location_0, \VSet, c)$.
  We denote with $\location_0$ the unique program location with $\location_0 \in \LSet$ which has no entry transitions in the program.
  We write $t_0$ for an initial transition. That is a transition $(\location_0, \tau, \location) \in \TSet$ where the start location is the initial location $\location_0$.
  We write $\TSet_0 \subseteq \TSet$ to denote the set of all initial transitions.
\end{definition}
The definition is based on the definition of programs of the previous KoAT \cite{koat} and a definition which distinguishes between guards and updates \cite{lowerruntime}.

Furthermore, we use a common definition of strongly connected components of a program $\Program$ \cite{sccs}.

\begin{definition}[Strongly connected component]
  Let $\Program = ((\LSet, \TSet), \location_0, \VSet, c)$ be a program.
  We define $\SCC \subseteq \LSet$ as strongly connected component if and only if it is maximal and from every location $\location \in \SCC$ every other location $\location' \in \SCC$ is reachable.
\end{definition}

Informally, we can describe a strongly connected component as a maximal loop in a program.
From this point on, we also use the abbreviation SCC for a strongly connected component.

In a program, every variable is considered to be an integer value.
A transition defines a possible move from one location to another location, if certain conditions are met.
In a transition $(\location,\update,\guard,\location') \in \TSet$, the guard $\guard$ represents the condition, which has to be fulfilled to move to the location $\location'$.
The update function $\update$ assigns each variable a value after the transition step.

We consider non-deterministic programs in this master's thesis.
\todo{Explain other non-determinism}{}
Therefore, there is no restriction, that from a location $\location \in \LSet$ there must be only one possible transition, for which the condition is fulfilled.
For example, the program $\Program = (\braced{\location_0,\location_1,\location_2},\braced{(\location_0,\text{id},\text{true},\location_1),(\location_0,\text{id},\text{true},\location_2)})$ is a valid program, although it is possible to both move to $\location_1$ and $\location_2$ from location $\location_0$.
Such a program is not representable in common software languages.

For two states $\valuation_1, \valuation_2 \in \Valuation$ we define $\valuation_1 \leq \valuation_2$ iff for all variables $v \in \VSet$ it holds that $\valuation_1(v) \leq \valuation_2(v)$.
We also define for a state $\valuation \in \Valuation$ the absolute value $\abs{\valuation} \in \Valuation$ iff for all variables $v \in \VSet$ it holds that $\abs{\valuation}(v) = \abs{\valuation(v)}$.

In a last step, we have to define how a program can be executed.
Therefore we define the term of an evaluation.

\begin{definition}[Evaluation] 
  For a transition $t \in \TSet$ an evaluation step $\rightarrow_t \in (\LSet \times \Sigma) \times (\LSet \times \Sigma)$ is a relation between a previous state at a location and a resulting state at a following location.
  We write $(\location, \valuation) \rightarrow_t (\location', \valuation')$ iff with the transition $t = (\location_t, \update, \guard, \location_t') \in \TSet$ three conditions are met.
  First, it holds that the state satisfies the guard $\valuation \models \guard$.
  Second, for each variable $v \in \PVSet$ the resulting state $\valuation'$ satisfies the equation $\exacteval{\update(v)}{\valuation} = \exacteval{v}{\valuation'}$.
  Third, for each temporary variable $v \in \TVSet$ the value $\valuation'(v)$ of the resulting state $\valuation'$ is arbitrary.
  And fourth, we have $\location = \location_t$ and $\location' = \location_t'$.
  We omit the transition and write $(\location, \valuation) \rightarrow (\location', \valuation')$ iff there exists a transition $t \in \TSet$ such that $(\location, \valuation) \rightarrow_t (\location', \valuation')$ holds.
  We write $(\location, \valuation) \rightarrow^k (\location', \valuation')$ iff there exists a sequence of transitions $t_1, \dots, t_k \in \TSet$ such that $(\location, \valuation) \rightarrow_{t_1} \dots \rightarrow_{t_k} (\location', \valuation')$ holds.
  We write $(\location, \valuation) \rightarrow^* (\location', \valuation')$ iff there exists a $k \in \mathbb{N}$ such that $(\location, \valuation) \rightarrow^k (\location', \valuation')$ holds.
  We write $(\location, \valuation) \rightarrow_{\TSet'} (\location', \valuation')$ iff there exists a transition $t \in \TSet' \subseteq \TSet$ such that $(\location, \valuation) \rightarrow_t (\location', \valuation')$ holds.
\end{definition}
