\subsection{Programs}

This section defines the term of a program.
In this master's thesis, we consider programs with the following properties.

\begin{itemize}
\item Sequential: All operations are executed one after the other
\item Imperative: Program state is changed by statements
\item Non-recursive: Recursive function calls are not allowed
\item Mathematical integers: The variables have values from the mathematical integer domain $\mathbb{Z}$
\item Non-determinism: From a state we can enter non-deterministically multiple other states and variables can be assigned non-deterministic variables
\item No heap usage: All values are directly accessed and not referenced
\end{itemize}

These properties are common in related work.
Note that using imperative programs is not a restriction, since \todo{Source?}{every functional and logic program can be transformed into an imperative program.}
There also exists related work which extends the analysis to bit-vector arithmetic instead of mathematical integers. \cite{bitvectorarithmetic}

In related work as well as in this thesis, it is common to consider non-deterministic programs.
This is necessary, since the analyzed programs are often abstractions of other programs.
These programs may depend on user input or may use a dynamic memory.

\todo{Example: Cartesian product with filter of (x,x)?}{}

We now formally define the programs used in this thesis.
First, we define a program graph.

\begin{definition}[Program graph] 
  Let $\PVSet$ be the set of all occurring program variables.
  Let $\TVSet$ be a finite set of temporary variables with $\TVSet \cap \PVSet = \emptyset$.
  Let $\LSet$ be the set of all locations of a program.
  Let $\TSet \subseteq \LSet \times (\PVSet \rightarrow \BoundSet_p(\PVSet \cup \TVSet)) \times \ConstraintSet(\PVSet \cup \TVSet) \times \LSet$ be the set of transitions of the program.
  A transition $t = (\location, \update, \guard, \location')$ consists of the start location $\location$, the target location $\location'$, the update function $\update$ and the guard $\guard$. 
  Then, a program graph is a tuple $(\LSet, \TSet)$.
\end{definition}

Then, we define a program as a program graph with an initial location and a function to assign transitions the costs of their execution.

\begin{definition}[Program] 
  Let $\location_0 \in \LSet$ be the unique program location which has no entry transitions in the program.
  Let $\cost: \TSet \rightarrow \BoundSet(\PVSet)$ be a function which maps each transition to its costs depending on the values of the variables.
  Let $(\LSet, \TSet)$ be a program graph.
  Then, a program is a tuple $\Program = ((\LSet, \TSet), \location_0, \PVSet, \TVSet, c)$.
  Furthermore, we write $t_0$ to denote an initial transition.
  That is a transition $(\location_0, \tau, \location) \in \TSet$ where the start location is the initial location $\location_0$.
  We write $\TSet_0 \subseteq \TSet$ to denote the set of all initial transitions.
\end{definition}

These definition are based on the definition of programs of the previous KoAT \cite{koat} and a definition which distinguishes between guards and updates \cite{lowerruntime}.

Furthermore, we use a common definition of strongly connected components of a program $\Program$ \cite{sccs}.

\begin{definition}[Strongly connected component]
  Let $\Program = ((\LSet, \TSet), \location_0, \PVSet, \TVSet, c)$ be a program.
  We define $\SCC \subseteq \LSet$ as strongly connected component if and only if it is maximal and from every location $\location \in \SCC$ every other location $\location' \in \SCC$ is reachable.
\end{definition}

From this point on, we also use the abbreviation SCC for a strongly connected component.

In a program, every variable is assumed to carry an integer value.
A transition defines a possible move from one location to another location, if certain conditions are met.
In a transition $(\location,\update,\guard,\location') \in \TSet$, the guard $\guard$ represents the condition, which has to be fulfilled to move to the location $\location'$.
The update function $\update$ assigns each program variable a value after the transition step.

We consider non-deterministic programs in this master's thesis.
Non-determinism can occur in a program due to two reasons.
First, non-determinism occurs, when a program state fulfills the guard of multiple succeeding transitions. 
There is no restriction, that only one guard of transitions with the same starting location can be fulfilled.
For example, the program graph $(\braced{\location_0,\location_1,\location_2},\braced{(\location_0,\text{id},\text{true},\location_1),(\location_0,\text{id},\text{true},\location_2)})$ is valid, although it is possible to both move both to location $\location_1$ and location $\location_2$ from the location $\location_0$.
Such a program is not representable in common software languages.

The second reason for non-determinism is an update $\update$ which assigns a program variable $v \in \PVSet$ an expression depending on one or multiple temporary variables $\tvar_1, \dots, \tvar_n \in \TVSet$.
The value of these temporary variables are non-deterministic and only restricted by the guard $\guard$.
Therefore, an update of the value of the variable $v \in \PVSet$ might result in different values.
Consider the update $\update$ with $\update(x) = \tvar$, where $x \in \PVSet$ is a program variable and $\tvar \in \TVSet$ is a temporary variable.
Also, consider the guard $\guard = \braced{\tvar > 0, \tvar \leq y}$ with $y \in \PVSet$.
Then, the update of $x$ might result in a range of values $0 < x \leq y$. 
Note that while the set of temporary variables $\TVSet$ is the same for every transition, their value is not carried over to other transitions.
This is reflected in the update $\update: \PVSet \rightarrow \BoundSet_p(\AllVarsSet)$, which only assigns new values to program variables.

We will now formally define the evaluation relation of a program.

\begin{definition}[Evaluation] 
  A state is a function $\valuation: \AllVarsSet \rightarrow \mathbb{Z}$ which assigns each variable $v \in \AllVarsSet$ a value $\valuation(v) \in \mathbb{Z}$.
  We write $\Valuation = \braced{ \valuation \mid \valuation: \AllVarsSet \rightarrow \mathbb{Z}}$ to denote the set of all states.
  A configuration is a pair $(\location, \valuation) \in \LSet \times \Valuation$ that defines the values of all variables at a specific location.
  For a transition $t \in \TSet$ an evaluation step $\rightarrow_t \in (\LSet \times \Sigma) \times (\LSet \times \Sigma)$ is a relation between two configurations.
  We write $(\location, \valuation) \rightarrow_t (\location', \valuation')$ if and only if the transition $t = (\location_t, \update, \guard, \location_t') \in \TSet$ satisfies four conditions.
  First, it holds that the state satisfies the guard $\exacteval{\guard}{\valuation} = \text{true}$.
  Second, for each program variable $v \in \PVSet$ the resulting state $\valuation'$ satisfies the equation $\exacteval{\update(v)}{\valuation} = \exacteval{v}{\valuation'}$.
  Third, for each temporary variable $v \in \TVSet$ the value $\valuation'(v)$ of the resulting state $\valuation'$ is arbitrary.
  And fourth, we have $\location = \location_t$ and $\location' = \location_t'$.
  We omit the transition and write $(\location, \valuation) \rightarrow (\location', \valuation')$ if and only if there exists a transition $t \in \TSet$ such that $(\location, \valuation) \rightarrow_t (\location', \valuation')$ holds.
  We write $(\location, \valuation) \rightarrow^k (\location', \valuation')$ if and only if there exists a sequence of transitions $t_1, \dots, t_k \in \TSet$ such that $(\location, \valuation) \rightarrow_{t_1} \dots \rightarrow_{t_k} (\location', \valuation')$ holds.
  We write $(\location, \valuation) \rightarrow^* (\location', \valuation')$ if and only if there exists a $k \in \mathbb{N}$ such that $(\location, \valuation) \rightarrow^k (\location', \valuation')$ holds.
  We write $(\location, \valuation) \rightarrow_{\TSet'} (\location', \valuation')$ if and only if there exists a transition $t \in \TSet' \subseteq \TSet$ such that $(\location, \valuation) \rightarrow_t (\location', \valuation')$ holds.
\end{definition}

\todo{Mention here?}{For two states $\valuation_1, \valuation_2 \in \Valuation$ we define $\valuation_1 \leq \valuation_2$ if and only if for all variables $v \in \AllVarsSet$ it holds that $\valuation_1(v) \leq \valuation_2(v)$.
We also define for a state $\valuation \in \Valuation$ the absolute value $\abs{\valuation} \in \Valuation$ if and only if for all variables $v \in \AllVarsSet$ it holds that $\abs{\valuation}(v) = \abs{\valuation(v)}$.}

