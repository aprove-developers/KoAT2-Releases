\subsection{Programs}

This section defines the term of a program.
This master's thesis considers programs with the following properties.

\begin{itemize}
\item Sequential: All operations are executed one after the other
\item Imperative: Program state is changed by statements
\item Non-recursive: Recursive function calls are not allowed
\item Mathematical integers: The variables take values in the mathematical integer domain $\mathbb{Z}$
\item Non-determinism: From a state, we can enter non-deterministically multiple other states and non-deterministic values can be assigned to variables
\item No heap usage: All values are directly accessed and not referenced
\end{itemize}

These properties are common in related work.
Note that using imperative programs is not a restriction since every functional or logic program can be transformed into an imperative program. \cite{equivalence_of_languages}
There also exists related work which extends the analysis to bit-vector arithmetic instead of mathematical integers. \cite{bitvectorarithmetic}

In related work as well as in this thesis, it is common to consider non-deterministic programs.
This is necessary since the analyzed programs are often abstractions of other programs.
These programs may depend on user input or may use a dynamic memory.

We now formally define the programs used in this thesis.
First, we define a program graph.

\begin{definition}[Program graph] 
  Let $\PVSet$ be the set of all occurring program variables.
  Let $\TVSet$ be a finite set of temporary variables with $\TVSet \cap \PVSet = \emptyset$.
  Let $\LSet$ be the set of all locations of a program.
  A label $w = (\update, \guard)$ consists of the update function $\update: \PVSet \rightarrow \BoundSet_p(\PVSet \cup \TVSet)$ and the guard $\guard \in \ConstraintSet(\PVSet \cup \TVSet)$.
  Let $\mathcal{W}$ be the set of all labels $(\update, \guard)$.
  Let $\TSet \subseteq \LSet \times \mathcal{W} \times \LSet$ be the set of transitions of the program.
  A transition $t = (\location, w, \location')$ consists of the start location $\location$, the target location $\location'$ and the label $w$.
  Then, a program graph is a tuple $(\LSet, \TSet)$.
\end{definition}

We also write $t = (\location, \update, \guard, \location')$ to denote a transition $(\location, (\update, \guard), \location') \in \TSet$.
We define a program as a program graph with an initial location and a function mapping transitions to the cost of their execution.

\begin{definition}[Program] 
  Let $\location_0 \in \LSet$ be the unique program location which has no entry transitions in the program.
  Let $(\LSet, \TSet)$ be a program graph.
  Let $\cost: \TSet \rightarrow \BoundSet(\PVSet)$ be a function which maps each transition to its cost depending on the values of the variables.
  For each transition $t \in \TSet$ and for each assignment $\valuation: \AllVarsSet \rightarrow \mathbb{Z}$ we require that the cost of the transition is positive, i.e. $\exacteval{\cost(t)}{\valuation} > 0$.
  Then, a program is a tuple $\Program = ((\LSet, \TSet), \location_0, \PVSet, \TVSet, c)$.
  Furthermore, we write $t_0$ to denote an initial transition.
  That is a transition $(\location_0, \tau, \location) \in \TSet$ where the start location is the initial location $\location_0$.
  We write $\TSet_0 \subseteq \TSet$ to denote the set of all initial transitions.
\end{definition}

These definitions are based on the definition of programs of the KoAT paper \cite{koat} and a definition which distinguishes between guards and updates \cite{lowerruntime}.

In a program, every variable is assumed to take an integer value.
A transition defines a possible move from one location to another location, if certain conditions are met.
In a transition $(\location,\update,\guard,\location') \in \TSet$, the guard $\guard$ represents the condition, which has to be fulfilled to move to the location $\location'$.
The update function $\update$ assigns each program variable a value after the transition step.

\begin{example}[Program]
  \input{graphs/example_program}
  Consider the program in Figure \ref{fig:example_program}.
  The set of program variables of this program is $\PVSet = \braced{x,y,z}$.
  Additionally, a temporary variable $\tvar \in \TVSet$ is used.
  The program defines the location set $\LSet = \braced{\location_0,\location_1,\location_2}$ and the transition set $\TSet = \braced{t_0,t_1,t_2}$.
  The location $\location_0$ is always considered to be the initial location of a program.
  The location set and the transition set form a program graph $(\LSet, \TSet)$.
  The transition $t_0$ is defined as $(\location_0,\update_0,\guard_0,\location_1)$ with an update $\update_0$ with $\update_0(x)=x$, $\update_0(y)=1$ and $\update_0(z)=\tvar$ and a guard $\guard = \braced{\tvar > 0}$.
  The $\update_0(z)=\tvar$ and the guard $\guard = \braced{\tvar > 0}$ imply, that the value of the program variable $z$ after an execution of $t_0$ is chosen non-deterministically as an arbitrary positive number.
  The transition $t_1$ is defined as $(\location_1,\update_1,\guard_1,\location_1)$ with an update $\update_1$ with $\update_1(x)=x-1$, $\update_1(y)=z \cdot y$ and $\update_1(z)=z$ and a guard $\guard = \braced{x > 0}$.
  Therefore, the transition $t_1$ forms a loop, which can be executed as long as $x > 0$ holds.
  Since $x$ is decremented, the transition can be executed at most $x$ or $0$ times.
  The transition $t_2$ is defined as $(\location_1,\update_2,\guard_2,\location_2)$ with an update $\update_2 = \text{id}$ and a guard $\guard = \emptyset$.
  The function $\text{id}$ symbolizes the identity function where each program variable $v \in \PVSet$ is mapped to itself.
  The guard $\guard = \emptyset$ is given implicitly and denotes the guard which is always satisfied.
  Therefore, the loop $t_1$ can always leave non-deterministically before the value of the variable $x$ reaches $0$.
  For the transitions $t_0$ and $t_2$ the costs are defined implicitly as $\cost(t_0) = \cost(t_2) = 1$.
  The transition $t_1$ has explicit costs $\cost(t_1) = z$.
  The whole program is defined as a tuple $((\LSet, \TSet), \location_0, \PVSet, \TVSet, \cost)$.
  This program computes for an integer $x$ non-deterministically all results of an expression $z^{x'}$ with $z > 0$ and $x \geq x' > 0$.  
\end{example}

For program graphs we use the well-known definition of strongly connected components of a graph (\cite{sccs}).
We define the strongly connected components of a program $\Program = ((\LSet, \TSet), \location_0, \PVSet, \TVSet, c)$ as the strongly connected components of its program graph $(\LSet, \TSet)$.
From this point on, we also use the abbreviation SCC for a strongly connected component.

We consider non-deterministic programs in this master's thesis.
Non-determinism can occur in a program due to two reasons.
First, non-determinism occurs, when a program state fulfills the guard of multiple succeeding transitions. 
There is no restriction, that only one guard of transitions with the same starting location can be fulfilled.
For example, in the program graph in Figure \ref{fig:example_program} it is possible to both move to the locations $\location_1$ and $\location_2$ from the location $\location_1$.
Such a program is not representable in common software languages.

The second reason for non-determinism is an update $\update$ which assigns a program variable $v \in \PVSet$ an expression depending on one or multiple temporary variables $\tvar_1, \dots, \tvar_n \in \TVSet$.
The values of these temporary variables are non-deterministic and only restricted by the guard $\guard$.
Therefore, an update of the value of the variable $v \in \PVSet$ might result in different values.
Consider the update $\update_0$ of the program in Figure \ref{fig:example_program} with $\update_0(z) = \tvar$.
Since the guard $\guard$ equals $\braced{\tvar > 0}$, the update of $z$ might result in a range of values $z > 0$. 
Note that while the set of temporary variables $\TVSet$ is the same for every transition, their value is not carried over to other transitions.
This is reflected in the update $\update: \PVSet \rightarrow \BoundSet_p(\AllVarsSet)$, which only assigns new values to program variables.

We will now formally define the evaluation relation of a program.

\begin{definition}[Evaluation] 
  A state is a function $\valuation: \AllVarsSet \rightarrow \mathbb{Z}$ which assigns each variable $v \in \AllVarsSet$ a value $\valuation(v) \in \mathbb{Z}$.
  We write $\Valuation = \braced{ \valuation \mid \valuation: \AllVarsSet \rightarrow \mathbb{Z}}$ to denote the set of all states.
  A configuration is a pair $(\location, \valuation) \in \LSet \times \Valuation$ that defines the values of all variables at a specific location.
  For a transition $t \in \TSet$ an evaluation step $\rightarrow_t \in (\LSet \times \Sigma) \times (\LSet \times \Sigma)$ is a relation between two configurations.
  We write $(\location, \valuation) \rightarrow_t (\location', \valuation')$ if and only if the transition $t = (\location_t, \update, \guard, \location_t') \in \TSet$ satisfies three conditions.
  First, it holds that the state satisfies the guard $\exacteval{\guard}{\valuation} = \textbf{true}$.
  Second, for each program variable $v \in \PVSet$ the resulting state $\valuation'$ satisfies the equation $\exacteval{\update(v)}{\valuation} = \exacteval{v}{\valuation'}$.
  And third, we have $\location = \location_t$ and $\location' = \location_t'$.
  We omit the transition and write $(\location, \valuation) \rightarrow (\location', \valuation')$ if and only if there exists a transition $t \in \TSet$ such that $(\location, \valuation) \rightarrow_t (\location', \valuation')$ holds.
  We write $(\location, \valuation) \rightarrow^k (\location', \valuation')$ if and only if there exists a sequence of transitions $t_1, \dots, t_k \in \TSet$ such that $(\location, \valuation) \rightarrow_{t_1} \dots \rightarrow_{t_k} (\location', \valuation')$ holds.
  We write $(\location, \valuation) \rightarrow^* (\location', \valuation')$ if and only if there exists a $k \in \mathbb{N}$ such that $(\location, \valuation) \rightarrow^k (\location', \valuation')$ holds.
  We write $(\location, \valuation) \rightarrow_{\TSet'} (\location', \valuation')$ if and only if there exists a transition $t \in \TSet' \subseteq \TSet$ such that $(\location, \valuation) \rightarrow_t (\location', \valuation')$ holds.
\end{definition}

Note that by definition, in an evaluation step $(\location, \valuation) \rightarrow_t (\location', \valuation')$ the value $\valuation'(v)$ of each temporary variable $v \in \TVSet$ is arbitrary.

For two states $\valuation_1, \valuation_2 \in \Valuation$ we define $\valuation_1 \leq \valuation_2$ if and only if for all variables $v \in \AllVarsSet$ it holds that $\valuation_1(v) \leq \valuation_2(v)$.
We also define for a state $\valuation \in \Valuation$ the absolute value $\abs{\valuation} \in \Valuation$ as a state with $\abs{\valuation}(v) = \abs{\valuation(v)}$ for each variable $v \in \AllVarsSet$.

