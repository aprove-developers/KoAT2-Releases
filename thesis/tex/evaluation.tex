\section{Evaluation}

The last chapter presented an implementation of the method to infer time, size and cost bounds.
This chapter evaluates this implementation against other methods.

For this purpose, two different approaches are used.
First, some selected examples are presented, where the benefit of the presented method in contrast to method of the original KoAT \cite{koat} is shown.
Second, the implementation is evaluated on an example set of programs, defined and used by comparable tools with the same objective of inferring time bounds for integer programs.

\subsection{Evaluating selected examples}

This section uses two selected examples to compare the results of the new method with the results of the original KoAT \cite{koat}.
This selection is chosen to show the benefits of the new method and is by no means representative.
Nevertheless it is able to show the potentials of the new method.

The first evaluated example is the motivational program from the introduction in Figure \ref{fig:motivational_example}.

\input{graphs/motivational_example}

For this program the new method yields a time complexity $\maxO{x-y}$, while the original KoAT \cite{koat} yields a time complexity $\abs{x}+\abs{y}$.
In the new method, we assume that we have two input states $\lstate$ and $\ustate$.
The original KoAT is defined with a single input state $m$ such that $m(v) = \maximum{-\lstate(v),\ustate(v)}$ for each variable $v \in \PVSet$.

Consider the two three-dimensional graphs in Figure \ref{fig:motivational_evaluation}.
We consider input states $\lstate$ and $\ustate$ with $\lstate(v) = \lstate(v')$ and $\ustate(v) = \ustate(v')$ for all variables $v, v' \in \PVSet$.
The left graph plots the time complexity $\maxO{x-y}$ of the new method and the right graph plots the time complexity $\abs{x}+\abs{y}$ of the original KoAT.
These graphs show, that the time complexities are the same, if $-\lstate = \ustate$.
This is the expected result, as $-\lstate = \ustate$ implies that $m = -\lstate = \ustate$.
The new method yields a lower time complexity, if the value of $-\lstate$ and $\ustate$ diverges.
The biggest gain is achieved, when $\lstate = \ustate$.
That is, when an exact state $\lstate = \valuation = \ustate$ is given.

\todo{Activate picture}{}
\iffalse
\input{evaluations/motivational_example}
\fi

\subsection{Evaluating an example set}

This section evaluates the presented implementation on an example set, which is a collection of examples introduced by other tools.
The main focus is a comparison with the method of the original KoAT paper \cite{koat}.
Besides that we compare the implementation to the tool CoFloCo \cite{cofloco3}.
For both KoAT and CoFloCo the latest development version available at the time of this thesis is used.

For the comparison of the results, it is necessary to project the resulting bounds in $\BoundSet(\PVSet)$ to their asymptotic complexity class.
The following definition introduces a projection, such that for every bound $b \in \BoundSet(\PVSet)$ the resulting asymptotic complexity $\complexity(b)$ is a valid overapproximation of the actual complexity.

\begin{definition}[Approximation of the asymptotic complexity]
  Let $\BoundSet(\VSet)$ be a set of bounds over the variables $\VSet$.
  Let $\landau$ be the landau symbol for asymptotic complexity.
  Then, $\complexity$ is a function which assigns each bound an overapproximation of its asymptotic complexity.
  \[ \complexity(\infty) = \landau(\infty) \text{ for } \infty \in \BoundSet(\VSet) \]
  \[ \complexity(k) = \landau(1) \text{ for all } k \in \mathbb{N} \subset \BoundSet(\VSet) \] 
  \[ \complexity(v) = \landau(n) \text{ for all } v \in \VSet \subset \BoundSet(\VSet) \] 
  \[ \complexity(-b) = \complexity(b) \text{ for all } b \in \BoundSet(\VSet) \] 
  \[ \complexity(b_1 + b_2) = \landau(\complexity(b_1) + \complexity(b_2)) \text{ for all } b_1, b_2 \in \BoundSet(\VSet) \] 
  \[ \complexity(b_1 \cdot b_2) = \landau(\complexity(b_1) \cdot \complexity(b_2)) \text{ for all } b_1, b_2 \in \BoundSet(\VSet) \] 
  \[ \complexity(\max(b_1, b_2)) = \landau(\max(\complexity(b_1), \complexity(b_2))) \text{ for all } b_1, b_2 \in \BoundSet(\VSet) \]
  \[ \complexity(k^b) = k^{\complexity(b)} \text{ for all } k \in \mathbb{N} \subset \BoundSet(\VSet), b \in \BoundSet(\VSet) \]  
\end{definition}

Note that this definition projects a bound $x-x$ to a complexity $\complexity(x-x) = \landau(n)$.
As already mentioned, the implementation is able to simplify such bounds to an equivalent bound $0$.
Therefore the better, but still valid complexity $\complexity(0) = \landau(1)$ is determined.
Nevertheless the implementation is not able to simplify every bound $b$ to an equivalent bound $b'$ with a complexity $\complexity(b')$ better than $complexity(b)$, although such a bound $b'$ exists.
Such a simplification algorithm has high performance costs for the implementation.
Therefore, the implemented simplification algorithm does in general not support the simplification of bounds, where it is necessary to analyze multiple levels of operators like $3 \cdot x^2-(x \cdot x+2 \cdot x^2)$.
Thus, an optimized simplification algorithm might yield better evaluation results without a change to the presented method.

For the parallel execution of the examples, we use the GNU tool 'parallel' \cite{gnuparallel}.
This way, the evaluation of all examples takes \todo{Insert time}{x} seconds with an average of \todo{Insert time}{x} seconds on an Intel i7 processor with four cores.
Therefore, the performance of the new implementation is comparable to other tools of the same domain.

\begin{table}
  \begin{center}
    \label{tab:evaluation}
    \begin{tabular}{l|c|c|c|c|c|c|c|c|c|c|c}
      Method & $\landau(1)$ & $\landau(n \log n)$ & $\landau(n)$ & $\landau(n^2)$ & $\landau(n^3)$ & $\landau(n^4)$ & $\landau(n^4)$ & $\landau(2^n)$ & $\landau(\infty)$\\
      \hline
      New      & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\
      KoAT     & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\
      CoFloCo  & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\
    \end{tabular}
  \end{center}
  \caption{Evaluation results}
\end{table}

