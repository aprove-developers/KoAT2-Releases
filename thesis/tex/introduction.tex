\section{Introduction}

This master's thesis presents a method for the computation of time bounds of integer programs.
A variety of complexity analysis tools, which address the same task, already exist.
These tools use different approaches for the search of time bounds.

The tool PUBS works with a non-modular approach, where a preprocessed program is analyzed at once.
This tool is discussed in the papers of Albert (\cite{pubs1}, \cite{pubs2}).

The tool CoFloCo uses an approach with cost relations, discussed in papers of Flores-Montoya (\cite{cofloco1}, \cite{cofloco2} and \cite{cofloco4}) and finally presented in his thesis \cite{cofloco3}.
This approach classifies program executions into different execution patterns called chains and performs a cost analysis yielding polynomial bounds with maximum and minimum operators. 
While this approach performs well for complex programs, it is not able to infer non-polynomial bounds.

The tool Loopus implements an amortized complexity analysis based on lexicographic ranking functions, discussed in the papers of Sinn and Zuleger (\cite{loopus1}, \cite{loopus2}).

The tool KoAT uses the computation of size bounds to infer time bounds, discussed in the paper of Brockschmidt (\cite{koat}).
The paper presents a modular approach with ranking functions.
With this approach parts of the program are analyzed independently.
These modular analyses can then be lifted into global time bounds.

The method of this master's thesis is based on the KoAT paper \cite{koat}.
It changes the methods of the KoAT paper \cite{koat} in such a way, that it can infer non-monotonic bounds instead of only monotonic bounds.

To demonstrate the potentials of the presented method, the next section provides a motivating example.
Then, the second chapter introduces the preliminaries.
These include a definition of the non-monotonic bound set to represent the set of possible results of the analysis.
Furthermore, a definition of an integer program and a utility structure called a result variable graph are introduced.
Additionally, the term of a ranking function is defined.

The third chapter introduces an operator on the non-monotonic bound set called an approximated replacement.
Non-monotonic bounds entail the difficulty that a common substitution can yield an unsound overapproximation.
The approximated replacement is defined to solve this problem.

The fourth chapter defines the terms time, size and cost complexity as well as time, size and cost bounds.
These definitions are more precise than definitions of the KoAT paper \cite{koat}.
The results of the new method are not representable with the definitions of the KoAT paper \cite{koat}.

The fifth and the six chapter present the new approach for the computation of time bounds and size bounds.
The fifth chapter introduces a new theorem for the computation of time bounds such that a preexisting size bound can be used.
Then, the sixth chapter introduces a new theorem for the computation of size bounds, which uses preexisting time bounds.

The seventh chapter defines two methods for the computation of cost bounds.
The trivial method is solely based on the inferred time bounds.
The non-trivial method is based on specialized ranking functions for cost bounds.

The eighth chapter presents details about the implementation of the presented method.
Then, in the ninth chapter, this implementation is evaluated and compared with other tools of the same domain.

The tenth chapter concludes this thesis.
In the appendix all necessary proofs are given.

As a motivation for the new method consider the following program.

\begin{algorithmic}
  \While{$x > y$}
    \State $x := x - 1$
  \EndWhile
\end{algorithmic}

It takes two variables $x$ and $y$ as input and runs a loop which decrements $x$ in each step with $t_1$ until $x$ is not greater than 0 anymore.
Intentionally, we can see, that the transition $t_1$ will be used at most $\max \braced{0, x-y}$ times.
But the method of the KoAT paper \cite{koat} is only able to infer the monotonic bound $\abs{x}+\abs{y}$ for $t_1$, while the new method infers the expected time bound $\maximum{0, x-y}$.
Both methods determine the rank $x-y$, to represent the maximal possible steps from the location $\location_1$.
This rank needs to be lifted to a global time bound depending on the size of the input variables.
For this purpose, the KoAT method \cite{koat} and the new method substitute the variables in the rank $x-y$ with a corresponding size bound up to the location $\location_1$.
In this step, one must ensure that the result is a valid overapproximation.
The method of KoAT \cite{koat} achieves this by transforming $x-y$ into a monotonic bound $\abs{x}+\abs{y}$.
The presented method instead substitutes the variable $x$ with its upper size bound and the variable $y$ with its lower size bound.
Since the method is able to determine an upper size bound for $x$ as $x$ and a lower size bound for $y$ as $y$, the substitution then yields $x-y$.
Then, it is only left to ensure the positivity of the time bound.
