In this section we present a template for local size bounds.
If we require the local size bounds to be a of that form, we are able to use those characteristics in the definition of the methods for global size bounds.
Therefore we define two subsets $\BoundSet^\sqcap_l, \BoundSet^\sqcup_l \subseteq \BoundSet(\PVSet)$.

\begin{definition}[Local bound sets]
  We define $\BoundSet^\sqcap_l \in \BoundSet(\PVSet)$ as 
  \[ \BoundSet^\sqcap_l = \braced{
    s \cdot \left(
        e
      + \sum_{v \in P_1} v
      - \sum_{v \in N_1} v
      + \sum_{v \in P_2} \maxO{v}
      + \sum_{v \in N_2} \maxO{-v}
      \right) \mid \exists s \in \mathbb{N} \text{ with } s \geq 1, e \in \mathbb{Z}, P_1, P_2, N_1, N_2 \subseteq \VSet }\]
  Also we define $\BoundSet^\sqcup_l \in \BoundSet(\PVSet)$ as 
  \[ \BoundSet^\sqcup_l = \braced{
    s \cdot \left(
        e
      + \sum_{v \in P_1} v
      - \sum_{v \in N_1} v
      - \sum_{v \in P_2} \maxO{-v}
      - \sum_{v \in N_2} \maxO{v}
      \right) \mid \exists s \in \mathbb{N} \text{ with } s \geq 1, e \in \mathbb{Z}, P_1, P_2, N_1, N_2 \subseteq \VSet }\]
\end{definition}

We now use these local bound sets for the definition of the scaled sum.

\todo{With approximated valuation?}{}
\begin{definition}[Scaled sum]
  We say that $\alpha \in \RV$ is bounded by an \textbf{upper} scaled sum if and only if there is a bound $b \in \BoundSet^\sqcap_l$ such that it holds for all states $\lstate \leq \ustate$ that
  \[ \appreval{\ULSB(\alpha)}{\lstate}{\ustate} = \appreval{b}{\lstate}{\ustate} \]
  We then denote with $s^\sqcap_\alpha$ the scaling factor $s$, with $e^\sqcap_\alpha$ the constant $e$ and with the sets $P_{\alpha,1}^\sqcap, P_{\alpha,2}^\sqcap, N_{\alpha,1}^\sqcap, N_{\alpha,2}^\sqcap$ the four variable sets $P_1$, $P_2$, $N_1$ and $N_2$.
  We say that $\alpha \in \RV$ is bounded by a \textbf{lower} scaled sum if and only if there is a bound $b \in \BoundSet^\sqcup_l$ such that it holds for all states $\lstate \leq \ustate$ that
  \[ \appreval{\LLSB(\alpha)}{\lstate}{\ustate} = \appreval{b}{\lstate}{\ustate} \]
  We then denote with $s^\sqcup_\alpha$ the scaling factor $s$, with $e^\sqcup_\alpha$ the constant $e$ and with the sets $P_{\alpha,1}^\sqcup, P_{\alpha,2}^\sqcup, N_{\alpha,1}^\sqcup, N_{\alpha,2}^\sqcup$ the four variable sets $P_1$, $P_2$, $N_1$ and $N_2$.
\end{definition}

\todo{Non-exact explanation}{}
\todo{Lower and upper update examples}{}

We show the possible bounds with this definition by some examples.
Let $t = (\location,\update,\text{true},\location') \in \TSet$ be a transition for which we want to find a local size bound $b$.
If $\update(x) = x$, we can represent the bound with $b = 1 \cdot (0 + x)$.
If $\update(x) = -x$, we can represent the bound with $b = 1 \cdot (0 - x)$.
This would not be possible, if $N_1$ would not be a part of the template.
If $\update(x) = 2 \cdot x + 2 \cdot y + 4$, we have a possible bound $b = 2 \cdot (2 + x + y)$.

For the previous examples, it was sufficient to have $P_2 = \emptyset$ and $N_2 = \emptyset$.
If $\update(x) = 2 \cdot x + 3 \cdot y$, one could suggest the bound $b = 3 \cdot (x + y)$.
But for a state $\valuation$ with $\exacteval{x}{\valuation} < 0$ and $\exacteval{y}{\valuation} = k$ this bound is not sound, since with $\exacteval{b}{\valuation}$ we would underapproximate the actual value $\exacteval{2 \cdot x + 3 \cdot y}{\valuation}$.
Therefore the elements of the local bound set provide the sets $P_2$ and $N_2$.
For $\update(x) = 2 \cdot x + 3 \cdot y$ we can then infer the bound $b = 3 \cdot (\maxO{x} + y)$.
With the defined state $\valuation$ we then have $\exacteval{b}{\valuation} = k$, which is a sound overapproximation of the actual value. 

For the previous case we used the set $P_2$.
We provide the set $N_2$ for the negative counterpart.
If $\update(x) = -(2 \cdot x) + -(3 \cdot y)$, we can infer the bound $b = 3 \cdot (\maxO{-x} - y)$.
With this construction we only consider negative values for $x$ and therefore ensure a sound overapproximation.

We will now present the algorithm for the computation of sound, but minimal local size bounds $b^\sqcap \in \BoundSet^\sqcap_l$ and $b^\sqcup \in \BoundSet^\sqcup_l$.
We first consider the upper case.
A local size bound $b = \ULSB(t,v)$ is a sound overapproximation of the effect of a transition $t = (\location,\update,\guard,\location')$, iff the formula $\guard \Rightarrow \update(v) \leq b$ is valid.
\[ \exists s \in \mathbb{N} \text{ with } s \geq 1:
\exists e \in \mathbb{Z}:
\exists P_1, P_2, N_1, N_2 \subseteq \VSet:
\forall \valuation \in \Valuation:
\lstate \leq \valuation \leq \ustate \Rightarrow
\exacteval{\guard}{\valuation} \Rightarrow \exacteval{\update(v)}{\valuation} \leq \exacteval{b}{\valuation} \]
An SMT-Solver is only able to find models for existential formulas $\exists v_0: \exists v_1: \dots \exists v_k: \phi(v_0, \dots, v_k)$. \cite{smt} \\
Therefore we use an approach, where we fix the parameters $s$, $e$ and $P_1, N_1, P_2, N_2$ and use the SMT-Solver to prove unsatisfiability of the negation of the formula.
That is, for fixed $s \in \mathbb{N}$ with $s \geq 1$, $e \in \mathbb{Z}$ and $P_1, N_1, P_2, N_2 \subseteq \VSet$ we search for a model of the following formula.
\[ \exists \valuation \in \Valuation: \lstate \leq \valuation \leq \ustate \wedge \exacteval{\guard}{\valuation} \wedge \exacteval{\update(v)}{\valuation} > \exacteval{b}{\valuation} \]
If the SMT-Solver does not find a model, the formula is unsatisfiable and therefore the fixed parameters form a sound overapproximation.

It is still open, how we choose the parameters.
Therefore we first need to define a measure for the quality of local bounds.
We say that $b_1 \in \BoundSet^\sqcap_l$ is a better bound than $b_2 \in \BoundSet^\sqcap_l$ iff for all states $\valuation$ it holds that $\exacteval{b_1}{\valuation} \leq \exacteval{b_2}{\valuation}$.
We then write $b_1 \leq b_2$
We want to find a bound $b \in \BoundSet^\sqcap_l$ such that for all bounds $b' \in \BoundSet^\sqcap_l$ it holds that $b \leq b'$.
\todo{Can there be multiple with only conjunctive?}{Note that there might be multiple such bounds in the local bound set $\BoundSet^\sqcap_l$.
For a transition guard $\guard = x \leq y \vee x \leq z)$ we have two minimal bounds $y \in \BoundSet^\sqcap_l$ and $z \in \BoundSet^\sqcap_l$.}

\subsection{Computing upper local size bounds}

At this point, we present an algorithm, that finds the optimal bound $b$.
The idea of this algorithm is to start with a trivial bound, that is always valid.
Then, we take multiple steps for a component-wise improvement of this bound, always staying with a valid bound.
In a first step, we define the trivial valid bound.

\begin{definition}[Trivial upper local size bound]
  Let $\alpha = ((\location,\update,\guard,\location'),v) \in \RV$ be a result variable, for which we want to find an upper local size bound.
  Let $\VSet$ be the set of all program variables.
  Let $s = e \in \mathbb{N}$ be the multiplication of the absolute values of all integers occurring in any upper update $\update(v)$ or any guard atom in $\guard$.
  Then, the local size bound $b \in \BoundSet^\sqcap_l$ defined by the scaling factor $s$, the constant $e$ and the variable sets $P_1 = N_1 = \emptyset$ and $P_2 = N_2 = \VSet$ is a valid upper local size bound for the value of $v$ after the application of the transition $t$.
\end{definition}

\input{theorems/trivial_lsb}

We show the construction of a trivial upper local size bound by an example.
Let $\alpha = ((\location,\update,\text{true},\location'),x) \in \RV$ be a result variable with the update $\update(x) = 4 + 2 \cdot y - 3 \cdot z$.
Then, by definition of the trivial upper local size bound we can obtain $b^\sqcap = 24 * (24 + \maxO{y} + \maxO{z} + \maxO{-y} + \maxO{-z}$.
Note that for all variables $v \in \VSet$ we have $\maxO{v} + \maxO{-v} = \abs{v}$, where $\abs{v}$ represents the absolute value of the variable $v$.

With a given trivial upper local size bound we can now search the local bound set $\BoundSet^\sqcap_l$ for better bounds.

\begin{algorithm}
\caption{Inferring upper local size bound}\label{ulsb_algorithm}
\begin{algorithmic}[1]
  \State Input: A result variable $t = ((\location,\update,\guard,\location'),v) \in \RV$
  \State Construct a trivial upper local size bound $b$ with the defining parameters $s$, $e$, $P_1$, $N_1$, $P_2$ and $N_2$
  \State Binary search $1 \dots s$ to find an $s$ such that $\bigwedge \guard \Rightarrow \update(v) \leq b$ is valid with this $s$, but not valid with $s-1$.
  \State Binary search $-e \dots e$ to find an $e$ such that $\bigwedge \guard \Rightarrow \update(v) \leq b$ is valid with this $e$, but not valid with $e-1$.
  \ForAll {variables $v \in \VSet$}
    \State Set $P_2 := P_2 \setminus \braced{v}$
    \If {$\bigwedge \guard \Rightarrow \update(v) \leq b$ is not valid}
      \State Set $P_1 := P_1 \cup \braced{v}$
      \If {$\bigwedge \guard \Rightarrow \update(v) \leq b$ is not valid}
        \State Revert to $P_2 := P_2 \cup \braced{v}$ and $P_1 := P_1 \setminus \braced{v}$
      \EndIf
    \EndIf
    \State Set $N_2 := N_2 \setminus \braced{v}$
    \If {$\bigwedge \guard \Rightarrow \update(v) \leq b$ is not valid}
      \State Set $N_1 := N_1 \cup \braced{v}$
      \If {$\bigwedge \guard \Rightarrow \update(v) \leq b$ is not valid}
        \State Revert to $N_2 := N_2 \cup \braced{v}$ and $N_1 := N_1 \setminus \braced{v}$
      \EndIf
    \EndIf
  \EndFor
\end{algorithmic}
\end{algorithm}

The presented algorithm consists of three steps.
In the first step the scaling factor $s$ gets minimized.
Since we chose the constant $e$ to be big enough, we can be sure at this point, that the reason for $\bigwedge \guard \Rightarrow \update(v) \leq b$ not being valid with $s-1$ is not the constant.
Instead there exists a variable, which does not allow further minimization of the scaling factor $s$.
With the minimized scaling factor the next step is then to also minimize the constant $e$.
Then, it might be possible to move variables from the sets $P_2$ and $N_2$ in the sets $P_1$ and $N_2$.
Note that this is possible, since for each variable $v \in \VSet$ and each valuation $\valuation \in \Valuation$ it holds that $\exacteval{v}{\valuation} \leq \exacteval{\maxO{v}}{\valuation}$ and also $\exacteval{-v}{\valuation} \leq \exacteval{\maxO{-v}}{\valuation}$.

The algorithm does not define an order for the iteration of the variables.
Note that the order affects the resulting bound, but not its optimality.
Consider the update $\update(x) = y + z$ and the guard $\guard = \braced{y = z}$.
Depending on the order it is both possible to receive the bounds $2 \cdot y$ and $2 \cdot z$.
But since $2 \cdot y \leq 2 \cdot z$ and $2 \cdot z \leq 2 \cdot y$ does not hold, they are both optimal.

\subsection{Computing lower local size bounds}

The algorithm for the search for a lower local size bound $\BoundSet^\sqcup_l$ is very similar to the search for an upper local size bound $\BoundSet^\sqcap_l$.
First, we need to define a trivial lower local size bound.

\begin{definition}[Trivial lower local size bound]
  Let $\alpha = ((\location,\update,\guard,\location'),v) \in \RV$ be a result variable, for which we want to find a lower local size bound.
  Let $\VSet$ be the set of all program variables.
  Let $s \in \mathbb{N}$ be the multiplication of the absolute values of all integers occurring in any upper update $\update(v)$ or any guard atom in $\guard$.
  Let $e = -s$ be its negation.
  Then, the local size bound $b \in \BoundSet^\sqcup_l$ defined by the scaling factor $s$, the constant $e$ and the variable sets $P_1 = N_1 = \emptyset$ and $P_2 = N_2 = \VSet$ is a valid lower local size bound for the value of $v$ after the application of the transition $t$.
\end{definition}

With the trivial lower local size bound we are now able to define the algorithm to infer lower local size bounds.

\begin{algorithm}
\caption{Inferring lower local size bound}\label{llsb_algorithm}
\begin{algorithmic}[1]
  \State Input: A result variable $t = ((\location,\update,\guard,\location'),v) \in \RV$
  \State Construct a trivial lower local size bound $b$ with the defining parameters $s$, $e$, $P_1$, $N_1$, $P_2$ and $N_2$
  \State Binary search $1 \dots s$ to find an $s$ such that $\bigwedge \guard \Rightarrow \update(v) \geq b$ is valid with this $s$, but not valid with $s-1$.
  \State Binary search $-e \dots e$ to find an $e$ such that $\bigwedge \guard \Rightarrow \update(v) \geq b$ is valid with this $e$, but not valid with $e+1$.
  \ForAll {variables $v \in \VSet$}
    \State Set $P_2 := P_2 \setminus \braced{v}$
    \If {$\bigwedge \guard \Rightarrow \update(v) \geq b$ is not valid}
      \State Set $P_1 := P_1 \cup \braced{v}$
      \If {$\bigwedge \guard \Rightarrow \update(v) \geq b$ is not valid}
        \State Revert to $P_2 := P_2 \cup \braced{v}$ and $P_1 := P_1 \setminus \braced{v}$
      \EndIf
    \EndIf
    \State Set $N_2 := N_2 \setminus \braced{v}$
    \If {$\bigwedge \guard \Rightarrow \update(v) \geq b$ is not valid}
      \State Set $N_1 := N_1 \cup \braced{v}$
      \If {$\bigwedge \guard \Rightarrow \update(v) \geq b$ is not valid}
        \State Revert to $N_2 := N_2 \cup \braced{v}$ and $N_1 := N_1 \setminus \braced{v}$
      \EndIf
    \EndIf
  \EndFor
\end{algorithmic}
\end{algorithm}

\todo{Proof that the algorithm always finds a valid local size bound}{}
