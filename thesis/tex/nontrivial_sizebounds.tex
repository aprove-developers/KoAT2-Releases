In the last section, we presented a method to infer upper and lower size bounds for result variables $\rv \in \RV$ which form a trivial SCC $\braced{\rv}$.
In this section, we extend the method to infer upper and lower size bounds for nontrivial SCCs.
We split these nontrivial SCCs in two groups.
The first group contains all nontrivial SCCs, for which there exists a variable, that is manipulated inside the SCC and that affects another variable or itself with its negated value inside the SCC.
For such SCCs, we use the SizeBounds methods from the original KoAT to infer upper and lower size bounds with $\USize(\rv) = -\LSize(\rv) = \mathcal{S}_{\text{original}}(\rv)$ for every result variable $\rv \in \RV$.

\input{graphs/negating_nontrivial}

Consider the program in figure \ref{fig:negating_nontrivial}.
It consists of two variables $y$ and $z$, that restrict the number of steps with $t_1$ and $t_2$.
The transition $t_2$ decrements the value of $x$ with every step and the transition $t_1$ negates the value of $x$ with every step.
The steps of the transitions $t_1$ and $t_2$ can happen in an arbitrary order due to non-determinism.
Consider an evaluation defined by the sequence of transitions $t_0, t_1, t_2, t_1, t_3$.
If the initial value of $x$ is positive, then its value changes in the sequence $x, -x, -x-1, -(-x-1), -(-x-1)$.
Then, the value of $x$ after the transition $t_3$ is $-(-x-1) = x+1$.
Although the upper local size bound of $(t_1,x)$ is $\ULSB(t_1,x) = x-1$, it is not possible to utilize the decrement to conclude, that the transition $t_1$ can not increment the value of $x$, since another transition of the SCC negated its value in a later step.

\input{graphs/negating_nontrivial_rvg}

Therefore, the new method uses the original method for such cases, where negation occurs inside the SCC.
This property is shown in the annotated result variable graph in figure \ref{fig:negating_nontrivial_rvg}.
This figure shows only the relevant part regarding the variable $x$.
Every result variable, that is negated by the local size bound of another result variable, is connected with a negative edge to this result variable.
Otherwise, it is connected with a positive edge.
From this point on we regard SCCs, that only consists of positive edges.
For these SCCs we present an optimized technique.

Prior to the definition of the method, we define four utility definitions, three of them also used by the original KoAT.

First, we define the pre-variables of a result variable $\rv \in \RV$ as an overapproximation $\pre(\rv) \subseteq \RV$ of all the result variables that directly affect the value of a result variable $\rv \in \RV$.
Since the result variable graph represents the connections of result variables, the predecessors of a result variable in a result variable graph are a valid implementation of the function $\pre$.
Consider again the program in figure \ref{fig:negating_nontrivial} and its result variable graph in figure \ref{fig:negating_nontrivial_rvg}.
The predecessors of $(t_1,x)$ in the result variable graph are $(t_0,x)$, $(t_1,x)$ and $(t_2,x)$.
Therefore, $\pre(t_1,x) = \braced{(t_0,x), (t_1,x), (t_2,x)}$ are the pre-variables of $(t_1,x)$.

Additionally, we define the SCC-variables $\VSet_\rv = \braced{ v \mid \exists (t, v) \in \pre(\rv) \cap \SCC }$ of a result variable $\rv \in \SCC$ as those variables, which affect the result variable $\rv$ from within the SCC $\SCC$.
For those variables we know, that their value is mutated throughout a loop.
The subset $\VSet^+_\rv \subseteq \VSet_\rv$ contains all variables $v$, that are both not in the set $N^\sqcap_\rv$ and not in the set $N^\sqcup_\rv$.
Such variables affect a result variable $\rv$ with a non-negated value.
Consider again the program in figure \ref{fig:negating_nontrivial} and its result variable graph in figure \ref{fig:negating_nontrivial_rvg}.
The set $\VSet^+_{(t_2,x)}$ contains the variable $x$, since the variable $x$ has both not a negative factor in the upper local size bound $\ULSB(t_2,x)$ and the lower local size bound $\LLSB(t_2,x)$
On the other hand, the set $\VSet^+_{(t_1,x)}$ is empty, since the variable $x$ has a negative factor in the upper local size bound $\ULSB(t_1,x)$ and also in the lower local size bound $\LLSB(t_1,x)$.
Therefore, the variable $x$ is in $\VSet_{(t_1,x)}$, but not in $\VSet^+_{(t_1,x)}$.
As mentioned earlier, we exclude those cases from the new analysis.

The third definition $\SCC_t$ selects from an SCC $\SCC$ of the result variable graph those result variables $\SCC_t = \braced{(t,v) \mid \exists v \in \VSet : (t,v) \in \SCC}$, that use a specific transition $t$.
Consider again the program in figure \ref{fig:negating_nontrivial} and its result variable graph in figure \ref{fig:negating_nontrivial_rvg}.
For the SCC $\SCC = \braced{(t_1,x), (t_2,x)}$ we have $\SCC_{t_1} = \braced{(t_1,x)}$ and $\SCC_{t_2} = \braced{(t_2,x)}$, while $\SCC_{t_0} = \SCC_{t_3} = \emptyset$.

Additionally, we introduce the SCC-transitions $\TSet_\SCC = \braced{ t \mid (t,v) \in \SCC}$ as the set of transitions, which occur in an SCC $\SCC$.
The example defines the SCC-transitions $\TSet_\SCC = \braced{t_1, t_2}$.

Now we are able to extend the method SizeBounds to nontrivial non-negating size bounds.

\input{theorems/nontrivial_sizebound}

The definition extends the method of the original KoAT to a differentiation of upper and lower bounds.
The overall idea is, to define a maximal \textbf{starting value} $\start$ and accumulate the maximal \textbf{effects} of all transitions within the SCC $\SCC$.
When we refer to an effect of a transition, we mean the change of a value by a single occurrence of a transition in an evaluation.
We distinguish between positive and negative effects.
A positive effect represents a number, by which the value of a variable increases, while a negative effect represents a number, by which the value of a variable decreases.
It is easy to see, that in an SCC without negation, it is necessary to capture all positive effects for the computation of an upper size bound, while it is necessary to capture all negative effects for the computation of lower size bounds.
The capturing of negative effects for the computation of upper size bounds and positive effects for the computation of lower size bounds would lead to better bounds, but in practice this is not achievable.
For the valid overapproximation of negative effects for upper size bounds, it would be necessary to approximate the accumulation of those negative effects with a multiplication with the lower time bound.
\todo{Source?}{But related work agrees, that it is not possible to effectively compute lower time bounds.}
Therefore, in any case which could yield a negative effect (or a positive effect for a lower size bound), we ignore it by setting it to $0$.

Now we analyze the new method in three steps to explain the reasoning behind the different components of the method.
We analyze the upper case in detail and explain the differences of the lower case after that.
In a first step, we consider a program, that multiplies a single variable in a loop with a factor without depending on other variables.
In a second step, we consider a program, that adds iteratively another variable to a variable, but does not use a multiplication with a factor.
As we will see, those are corner cases of the general size bound definition ${\mathcal{S}^\sqcap}'(\beta) = \scale^\sqcap_\SCC \cdot \left( \maxO{\start^\sqcap} + \effect^\sqcap_\SCC \right)$.
For the first program this definition will break down to ${\mathcal{S}^\sqcap}'(\beta) = \scale^\sqcap_\SCC \cdot \left( \maxO{\start^\sqcap} + 0 \right)$.
For the second program this definition will break down to ${\mathcal{S}^\sqcap}'(\beta) = 1 \cdot \left( \maxO{\start^\sqcap} + \effect^\sqcap_\SCC \right)$.
In a third step, we present a more complex program, where we analyze the behavior of the method in the lower case.

\subsubsection{Step One: Internal multiplication}

Consider the program from the introduction in figure \ref{fig:nontrivial_nodependency}.

\input{graphs/nontrivial_nodependency}

It takes a value for the variable $y$ and multiplies it in a loop $t_1$ with the factor $2$.
The number of steps of the transition $t_1$ is bounded by the value of $x$.
The value of $y$ increases in a sequence $y, 2 \cdot y, 4 \cdot y, 8 \cdot y, 16 \cdot y, \dots$.
Thus, the value of $y$ after the loop $t_1$ does only depend on the value of $y$ after the transition $t_0$ and the value of $y$ after previous steps of the loop $t_1$.
The idea is, that we start with an overapproximation of the initial value of $y$ before entering the loop and then multiply it with the maximal factors inside the loop.

The overapproximation of the initial value of $y$ is reflected by the \textbf{starting value}.
\[ \start^\sqcap = \maximum{\USize(\prerv) \mid \exists \rv \in \SCC: \prerv \in \pre(\rv) \setminus \SCC} \]
We consider all result variables, which might affect the value of $y$ and select the maximal value among them.

Additionally to the starting value, we have to consider the factors mutating the starting value during the loop $t_1$.
Intentionally, we can see, that with each occurrence of the transition $t_1$ the upper size bound increases by the factor $2$.
After $\UTime(t_1)$ occurrences of $t_1$, the value of $y$ is bounded by $2^{\UTime(t_1)} \cdot \maxO{\start^\sqcap}$.
This is covered by the \textbf{loop scaling factor} $\scale^\sqcap_\SCC = \prod_{t \in \TSet_\SCC} (\scale^\sqcap_t)^{\UTime(t)}$.
It consists of all \textbf{transition scaling factors} $\scale^\sqcap_t$ of the transitions $t \in \TSet_\SCC$ of the SCC $\SCC$.
In the example, there is only one transition in the SCC, therefore the loop scaling factor reduces to the exponentiation with a single transition scaling factor $\scale^\sqcap_\SCC = \prod_{t \in \TSet_\SCC} (\scale^\sqcap_t)^{\UTime(t)} = (\scale^\sqcap_{t_1})^{\UTime(t_1)}$.
Assume, we found an upper local size bound $\ULSB(t_1,y) = 2 \cdot y$.
Since the scaling factor of this upper local size bound is $2$ and $(t_1,y)$ is the only result variable of the SCC $\SCC$, $2$ is also a maximal scaling factor $\maximum{s^\sqcap_\rv \mid \rv \in \SCC_t}$ for the transition $t_1$.
This results in the expected upper size bound $2^{\UTime(t_1)} \cdot \maxO{\start^\sqcap}$ for the result variable $(t_1,y)$.

There are two parts, which still need to be covered, before we can be sure, that $2^{\UTime(t_1)} \cdot \maxO{\start^\sqcap}$ is actually the result of ${\mathcal{S}^\sqcap}'(t_1,y)$.
The first part is the \textbf{loop effect} $\effect^\sqcap_\SCC = \sum_{t \in \TSet_\SCC} \left( \UTime(t) \cdot \effect^\sqcap_t \right)$, which we assumed to be $0$ in the example.
This is non-obvious, since the loop effect of the analyzed SCC is a sum over the non-empty set $\TSet_\SCC = \braced{t_1}$.
It needs to be shown that the loop effect $\effect^\sqcap_\SCC = \UTime(t_1) \cdot \effect^\sqcap_{t_1}$ equals $0$.
The time bound of $t_1$ can be computed to be $\UTime(t_1) = \maxO{x}$ and therefore does not equal $0$ for every state.
The \textbf{transition effect} $\effect^\sqcap_{t_1} = \max \braced{\effect^\sqcap_\rv \mid \rv \in \SCC_{t_1} }$ selects the maximal \textbf{result variable effect} among all result variables in $\SCC_{t_1}$.
Since there is only one result variable $(t_1,y)$ in $\SCC_{t_1}$, it is left to show that the result variable effect $\effect^\sqcap_{(t_1,x)} = \maxO{e^\sqcap_{(t_1,x)}} + \sum_{v \in P_{(t_1,x)}^\sqcap \setminus \VSet_{(t_1,x)}} \maxO{\incoming^\sqcap_{(t_1,x)}(v)} + \sum_{v \in N_{(t_1,x)}^\sqcap} \maxO{\incoming^\sqcup_{(t_1,x)}(v)}$ equals $0$.
The constant $e^\sqcap_{(t_1,y)}$ of the local size bound $\ULSB(t_1,y) = 2 \cdot y$ of $(t_1,y)$ is $0$.
Also, this local size bound only depends on the variable $y \in \P^\sqcap_{(t_1,y)}$.
This variable is an SCC-variable and therefore $\VSet_{(t_1,y)} = \braced{y}$.
Since there are no other variables affecting $(t_1,y)$, it holds that $\sum_{v \in P_{(t_1,x)}^\sqcap \setminus \VSet_{(t_1,x)}} \maxO{\incoming^\sqcap_{(t_1,x)}(v)} + \sum_{v \in N_{(t_1,x)}^\sqcap} \maxO{\incoming^\sqcup_{(t_1,x)}(v)}$ equals $0$.
Therefore, it is shown that the loop effect $\effect^\sqcap_\SCC$ is actually $0$.

\todo{Go on}{}

The second part, which we did not cover yet, is the factor $\maximum{\abs{V_\rv} \mid \rv \in \SCC_t}$.
This factor was not yet mentioned, but is part of the \textbf{transition scaling factor} $s^\sqcap_t = \maximum{s^\sqcap_\rv \mid \rv \in \SCC_t} \cdot \maximum{\abs{V_\rv} \mid \rv \in \SCC_t}$.
In the example, this part of the transition scaling factor is $1$, but in general it can be a number greater than $1$.
This factor reflects, that exponential bounds can not only result from scaling factors which are greater than $1$, but also from variables, which affect each other consecutively in a loop.

\input{graphs/exp_with_vars}

Consider the example in figure \ref{fig:exp_with_vars}.
The program has three variables $x$, $y$ and $z$.
The variable $x$ determines the number of runs of the loop $t_1$.
With each run of the transition $t_1$ the value of $y$ increases by the value of $z$ (or decreases for $z < 0$).
The value of $z$ is set in each step of the loop to the previous value of $y$.

Let $(a,b,c)$ be a notation for a state $\valuation \in \Valuation$ with $\valuation(x) = a$, $\valuation(y) = b$ and $\valuation(z) = c$.
Then, for starting values $x$, $y$ and $z$, we can define a possible evaluation.
\begin{align*}
  (\location_0, (x,1,1)) & \rightarrow_{t_0} (\location_1, (x,1,1)) \\
  & \rightarrow_{t_1} (\location_1, (x-1,2,1)) \\
  & \rightarrow_{t_1} (\location_1, (x-2,3,2)) \\
  & \rightarrow_{t_1} (\location_1, (x-3,5,3)) \\
  & \rightarrow_{t_1} (\location_1, (x-4,8,5)) \\
  & \rightarrow_{t_1} (\location_1, (x-5,13,8)) \\
  & \rightarrow_{t_1} \dots
\end{align*}
We can observe, that the variables $y$ and $z$ enumerate the Fibonacci numbers.
They affect each other in the loop and as a result their value is not bounded by a polynomial.

Since the Fibonacci sequence itself can not be represented with the bound set $\BoundSet(\PVSet)$, it is necessary to use an overapproximation.
Lets consider the update $\update(y) = y + z$.
We have a non-polynomial bound, because the values of $y$ and $z$ can change during the loop $t_1$.
For this reason they are by definition part of the set $\VSet_{(t_1,y)} = \braced{y,z}$.
The idea of the factor $\maximum{\abs{V_\rv} \mid \rv \in \SCC_t}$ is, that we can overapproximate the effect of $\update(y)$ with a scaling factor of $2$ in a bound $2 \cdot \max(y,z)$.
Such a bound is representable in the bound set $\BoundSet(\PVSet)$.
If the update $\update(y)$ would be a sum of $n$ variables $v_1, \dots, v_n$ of the set $\VSet_{(t_1,y)}$, then the effect of $\update(y)$ could be overapproximated with a bound $n \cdot \max \braced{v_1, \dots, v_n}$.

\subsubsection{Step Two: Dependency on outside variables}

The second component, we consider, is the addition with constant values from outside of the SCC $\SCC$.
Consider the program in figure \ref{fig:additive_loop}.

\input{graphs/additive_loop}

The program is very similar to the program in figure \ref{fig:exp_with_vars}.
The difference is, that the value of $z$ does not depend on the value of $y$ anymore.
Instead, the value of $z$ is constant throughout the loop $t_1$.
The consequence is, that the update $\update(y) = y + z$ can not result in exponential growth anymore, since the variables mutated during the loop are $V_{(t_1,y)} = \braced{y}$ instead of $\braced{y,z}$.
Therefore, we can find a better bound than an exponential bound, if we consider the update $\update(y) = y + z$ to be an addition of $y$ with a constant $z$.

We now want to determine a size bound for the variable $y$ after the transition $t_1$.
The result variable graph shows, that the value of $y$ affects itself in the loop $t_1$, while it also depends on the value of $y$ after the transition $t_0$ and the value of $z$ after the transitions $t_0$ and $t_1$.
The \textbf{starting value} $\start^\sqcap = \maximum{\USize(\prerv) \mid \exists \rv \in \SCC: \prerv \in \pre(\rv) \setminus \SCC}$ is $\maximum{y,z}$.
Now, we must approximate the effect of the addition of the value of $z$ in each step of the loop $t_1$.
If $z$ is negative, then each iteration of the loop decreases the value of $y$ and therefore the starting value is already an upper size bound.
Since we do not consider lower time bounds, it is not possible to utilize this decrease to find a better upper size bound.
On the other hand, if $z$ is positive, then each iteration of the loop increases the value of $y$ and therefore we can approximate the increase by the upper time bound $\UTime(t_1)$ multiplied with the effect $z$.

For lower size bounds this logic is contrary.
If $z$ is negative, then each iteration of the loop decreases the value of $y$ and therefore, in contrast to the definition of upper size bounds, we can approximate the decrease by the upper time bound $\UTime(t_1)$ multiplied with the effect $z$.
If $z$ is positive, we can infer the starting value as lower size bound.
Note that for an update $\update(y) = y - z$ instead of $\update(y) = y + z$ for the transition $t_1$, the presented logic is the other way around.

This is all reflected in the definitions of the \textbf{transition effects} $\effect^\sqcap_t$ and $\effect^\sqcup_t$.
While the positive transition effect $\effect^\sqcap_t$ describes a bound for the upper case, the negative transition effect $\effect^\sqcup_t$ describes a bound for the lower case.
In the example program, for the computation of the upper size bound we have to consider the transition effect $\effect^\sqcap_{t_1}$ of the transition $t_1$.
For this purpose, we need to consider the maximal \textbf{result variable effects} of all result variables in the SCC $\SCC$ which use the transition $t_1$.
We only consider the maximal effect, because in one evaluation step with a transition $t$ only the effect of one result variable $\rv \in \SCC_t$ can happen.
In the example, there is only one result variable $(t_1,y) \in \SCC$, which uses the transition $t_1$.
Therefore, we have $\effect^\sqcap_{t_1} = \effect^\sqcap_{(t_1,y)}$ and as a direct consequence $\effect^\sqcap_\SCC = \sum_{t \in \TSet_\SCC} \UTime(t) \cdot \effect^\sqcap_{t} = \UTime(t_1) \cdot \effect^\sqcap_{(t_1,y)}$.
The result variable effect $\effect^\sqcap_{(t_1,y)}$ consists of the factor $e^\sqcap_\rv = 0$ of the local size bound of this result variable and the sum of all incoming variables from outside of the SCC.
It is not necessary to consider variables from inside the SCC, since their value is already covered by the starting value $\start^\sqcap$.
Only additions with outside variables or constants and multiplications with constants can increase the upper size bound.
In the example, we have with $z$ one variable from outside the SCC for the result variable $(t_1,x)$.
Again, we can only consider the positive effect of this variable.
The result is a result variable effect $\effect^\sqcap_{(t_1,y)} = \maxO{e^\sqcap_\rv} + \sum_{v \in P_\rv^\sqcap \setminus \VSet_\rv} \maxO{\incoming^\sqcap_\rv(v)} + \sum_{v \in N_\rv^\sqcap} \maxO{\incoming^\sqcup_\rv(v)} = 0 + \maxO{z} + 0$.
Therefore, the loop effect $\effect^\sqcap_\SCC$ equals $\UTime(t_1) \cdot \maxO{z} = \maxO{x} \cdot \maxO{z}$ and as a consequence the inferred upper size bound is $\USize'(t_1,x) = 1 \cdot (\maximum{y,z} + \maxO{x} \cdot \maxO{z})$.

\subsubsection{Step Three: All together}

\todo{Useful?}{If, then use lower case for this}
