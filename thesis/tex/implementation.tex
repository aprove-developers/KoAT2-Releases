\section{Implementation}

We developed a prototype which implements the search for non-monotonic bounds.
This implementation is focused on high modularity and maintainability.
The tool is implemented with the ML-derived language OCaml.
\todo{Will we?}{In this chapter we give an overview of the modules of the implementation.}

\subsection{Preprocessors}

In the implementation we use several common preprocessors.
A preprocessor is a function $p: 2^{\LSet \times \TSet} \rightarrow 2^{\LSet \times \TSet}$ which maps a program to an equivalent program.
We say that a preprocessor $p$ changes a program $\Program = ((\LSet, \TSet), \location_0, \VSet, \cost)$ iff $p(\Program) \neq \Program$.
We say that a preprocessor $p_1$ affects another preprocessor $p_2$ iff there are programs $\Program = ((\LSet, \TSet), \location_0, \VSet, \cost)$ such that $p_2(\Program) = \Program$, but $p_2$ changes the preprocessed program $p_1(\Program)$, e.g. $p_2(p_1(\Program)) \neq p_1(\Program)$.

We provide two different execution strategies.
The trivial execution strategy executes a given sequence of preprocessors $p_1, \dots, p_n$.
The second execution strategy is a work-list algorithm, which executes every preprocessor and appends all affected preprocessors to the work-list if a preprocessor changed the program.

We will now define three common preprocessors $p_{\text{reachable}}$, $p_{\text{sat}}$ and $p_{\text{chaining}}$.

\subsubsection{Removal of unreachable locations}

The preprocessor $p_{\text{reachable}}$ removes all locations, which are unreachable from the start location.
To achieve that, the preprocessor follows the transitions of the graph and marks each visited location, adding them to a set $\LSet'$.
The set of locations $\LSet \setminus \LSet'$ is then the set of all unreachable locations.
The result of the preprocessor is a program $((\LSet', \TSet'), \location_0, \VSet, \cost)$, where $\TSet' = \braced{(\location,\update,\guard,\location') \mid \exists (\location,\update,\guard,\location') \in \TSet: \location \in \LSet' \wedge \location' \in \LSet'}$ is the set of transitions whose start and end locations are both in the reachable set $\LSet'$.

The preprocessor $p_{\text{reachable}}$ does not affect any defined preprocessor.

\subsubsection{Removal of unsatisfiable transitions}

The preprocessor $p_{\text{sat}}$ removes transitions which conditions are unsatisfiable.
The result of the preprocessor is a program $((\LSet, \TSet'), \location_0, \VSet, \cost)$, where $\TSet' = \braced{(\location,\update,\guard,\location') \mid \exists (\location,\update,\guard,\location') \in \TSet: \neg (\bigwedge \guard \models \emptyset)}$ is the set of all satisfiable transitions.

The preprocessor $p_{\text{sat}}$ affects the preprocessors $p_{\text{reachable}}$ and $p_{\text{chaining}}$.
The preprocessor $p_{\text{reachable}}$ is affected in a scenario $\Program = ((\braced{\location_0, \location_1}, \braced{(\location_0,\update,\text{false},\location_1)}), \location_0, \emptyset, \cost)$.
In this example the transition $(\location_0,\update,\text{false},\location_1)$ will be removed by $p_{\text{sat}}$.
This leaves the location $\location_1$ unreachable.
The preprocessor $p_{\text{chaining}}$ is affected in a scenario $\Program = ((\braced{\location_0, \location_1, \location_2}, \braced{(\location_0,\update_1,\text{true},\location_1), (\location_1,\update_2,\text{true},\location_2), (\location_1,\update_3,\text{false},\location_1)}), \location_0, \emptyset, \cost)$.
In this example the transition $(\location_1,\update_3,\text{false},\location_1)$ will be removed by $p_{\text{sat}}$.
This enables the preprocessor $p_{\text{chaining}}$ to skip the location $\location_1$.

\subsubsection{Chaining}

\todo{Chaining does not work anymore with lower and upper updates (for non-monotonic updates)}{}

The preprocessor $p_{\text{chaining}}$ does a single run on all locations $\location \in \LSet$ to check if they can be skipped by chaining.
For such a location a chaining step is possible iff there does not exist a transition $(\location,\update,\guard,\location)$ with any update $\update$ and guard $\guard$, e.g. iff the location forms a trivial SCC $\braced{\location}$.
Then and only then we can define the equivalent program without this location $((\LSet', \TSet'), \location_0, \VSet, \cost')$ with the reduced location set $\LSet' = \LSet \setminus \braced{\location}$ and the replaced transition set $\TSet' = (\TSet \setminus \TSet^-) \cup \TSet^+$ with $\TSet^- = \braced{(\location',\update,\guard,\location'') \mid \exists (\location',\update,\guard,\location'') \in \TSet: \location \neq \location' \wedge \location \neq \location''}$ and $\TSet^+ = \braced{(\location_1,\update_2 \circ \update_1,\eval{\guard_2}{\update_1} \cup \guard_1,\location_2') \mid \exists (\location_1,\update_1,\guard_1,\location) \in \TSet, \exists (\location,\update_2,\guard_2,\location_2') \in \TSet}$. \todo{More precise}{}
The new transition represents the execution of both transitions.
Therefore for all $t \in \TSet^+$ the costs are defined as $\eval{\cost'(t)}{\valuation} = \eval{\cost(t_1)}{\valuation} + \eval{\cost(t_2)}{\valuation}$, where $t_1, t_2 \in \TSet^-$ are the corresponding removed transitions.
The preprocessor $p_{\text{chaining}}$ performs consecutive chaining steps for all locations $\location \in \LSet$.

It affects the preprocessor $p_{\text{sat}}$.
The preprocessor $p_{\text{sat}}$ is affected in a scenario $P = (\braced{\location_0, \location_1, \location_2}, \braced{(\location_0,x>0 \wedge x'=x,\location_1), (\location_1,x<0,\location_2)})$.
The location $\location_1$ will be removed by the preprocessor $p_{\text{chaining}}$, resulting in a program $P = (\braced{\location_0, \location_2}, \braced{(\location_0,x>0 \wedge x<0,\location_2)})$
This enables the preprocessor $p_{\text{sat}}$ to remove the unsatisfiable transition $(\location_0,x>0 \wedge x<0,\location_2)$.
\todo{Does it affect itself?}{The preprocessor $p_{\text{chaining}}$ affects itself, }

\todo{Define condition composition}{}

\subsection{Trivial time bounds}

For a program $\Program = ((\LSet, \TSet), \location_0, \VSet, \cost)$ the algorithm needs an initial time and size bound prior to the execution.
Obviously a time bound $\UTime$ with $\UTime(t) = \infty$ for all transitions $t \in \TSet$ is sound for all programs $\Program$.
Also an upper size bound $\USize$ with $\USize(\alpha) = \infty$ for all result variables $\alpha \in \RV$ and a lower size bound $\LSize$ with $\LSize(\alpha) = -\infty$ for all result variables $\alpha \in \RV$ are sound for all programs $\Program$.

For time bounds it is possible to infer a better time bound prior to the execution.
For all transitions $t \in \TSet$ which are not part of an SCC, we know, that they can only occur once in every evaluation.
Therefore, it is sound to use the initial time bound $\UTime$ with $\UTime(t) = \cost(t)$ for all transitions which does not occur in an SCC of the program $\Program$ and $\UTime(t) = \infty$ for all transitions which does occur in an SCC of the program $\Program$.

\subsection{Algorithm}

In the last two chapters we presented the theorems for the computation of time and size bounds.
For the computation of a time bound for a whole program, it is necessary to define an algorithm, which uses the time and size bound theorems to infer the global time bound.
In this chapter we will present such an algorithm and show its execution on a detailed example.
While the actual code is written in a functional style, we will present the algorithm in an imperative style to make the execution order explicit.

\begin{algorithm}
\caption{Inferring a global time bound}\label{complete_algorithm}
\begin{algorithmic}[1]
  \State Input: A program graph $P = (\LSet, \TSet)$
  \State Run preprocessors
  \State Create a trivial time bound $\UTime$ and a trivial size bound $\Size$
  \State Infer time bounds for transitions between SCCs
  \State Construct the result variable graph RVG from $P$
  \State Compute local size bounds $\ULSB$ and $\LLSB$
  \Repeat
    \ForAll{SCCs $\SCC$ of RVG in topological order}
      \State Run $\text{SizeBounds}(\UTime, \Size, \SCC)$
    \EndFor
    \ForAll{SCCs $\TSet'$ of $P$ in topological order}
      \State Run $\text{TimeBounds}(\UTime, \Size, \TSet')$
    \EndFor
  \Until{all TimeBounds executions did not improve any time bound}
\end{algorithmic}
\end{algorithm}
